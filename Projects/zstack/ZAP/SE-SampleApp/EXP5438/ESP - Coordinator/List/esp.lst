###############################################################################
#                                                                             #
#                                                       29/Jan/2012  16:16:13 #
# IAR C/C++ Compiler V5.40.2.20380/W32, Evaluation edition for MSP430         #
# Copyright 1996-2011 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\SE-SampleApp\Source\ESP\esp.c                        #
#    Command line  =  -f "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\Source\zap.cfg"       #
#                     (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=!ZAP_PHY_SPI            #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f   #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\..\..\..\Tools\MSP5438\f8wZCL. #
#                     cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC                #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE) "C:\Texas Instruments\ZAP-MSP430-2.5.0\P #
#                     rojects\zstack\ZAP\SE-SampleApp\Source\ESP\esp.c" -D    #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D             #
#                     TC_LINKKEY_JOIN -D ZCL_REPORT -D INTER_PAN -lC          #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\List\" -lA   #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\List\"       #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\Obj\"        #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\" -I "C:\Texas                 #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\Source\" -I "C:\Texas                 #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\Source\" -I "C:\Texas              #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\hal\target\MSP #
#                     5438ZAP\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pro #
#                     jects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Co #
#                     mponents\hal\include\" -I "C:\Texas                     #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\mac\include\"  #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\m #
#                     t\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\ #
#                     zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Componen #
#                     ts\osal\include\" -I "C:\Texas                          #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\osal\mcu\msp43 #
#                     0\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\ #
#                     zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Componen #
#                     ts\services\saddr\" -I "C:\Texas                        #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\services\sdata #
#                     \" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\z #
#                     stack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\ #
#                     Projects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\.. #
#                     \Components\stack\nwk\" -I "C:\Texas                    #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\stack\sapi\"   #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\s #
#                     tack\sec\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pr #
#                     ojects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\C #
#                     omponents\stack\sys\" -I "C:\Texas                      #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\stack\zcl\"    #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\s #
#                     tack\zdo\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pr #
#                     ojects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\C #
#                     omponents\zmac\" -I "C:\Texas                           #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\zmac\f8w\"     #
#                     --core=430X --data_model=small -Ohz --multiplier=32     #
#                     --multiplier_location=4C0 --require_prototypes          #
#                     --hw_workaround=CPU40                                   #
#    List file     =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\SE-SampleApp\EXP5438\ESP - Coordinator\List\esp.lst  #
#    Object file   =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\SE-SampleApp\EXP5438\ESP - Coordinator\Obj\esp.r43   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-SampleApp\Source\ESP\esp.c
      1          /**************************************************************************************************
      2            Filename:       esp.c
      3            Revised:        $Date: 2011-07-22 08:49:19 -0700 (Fri, 22 Jul 2011) $
      4            Revision:       $Revision: 26887 $
      5          
      6            Description:    This module implements the ESP functionality and contains the
      7                            init and event loop functions
      8          
      9          
     10            Copyright 2009-2011 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42            This application is designed for the test purpose of the SE profile which
     43            exploits the following clusters for an ESP configuration:
     44          
     45            General Basic
     46            General Alarms
     47            General Time
     48            General Key Establishment
     49            SE     Price
     50            SE     Demand Response and Load Control
     51            SE     Simple Metering
     52            SE     Message
     53          
     54            Key control:
     55              SW1:  Send out Cooling Load Control Event to PCT
     56              SW2:  Send out Load Control Event to Load Control Device
     57              SW3:  Send out Message to In Premise Display
     58              SW4:  Not used
     59          *********************************************************************/
     60          
     61          /*********************************************************************
     62           * INCLUDES
     63           */
     64          
     65          #include "OSAL.h"
     66          #include "OSAL_Clock.h"
     67          #include "OSAL_Nv.h"
     68          #include "MT.h"
     69          #include "MT_APP.h"
     70          #include "ZDObject.h"
     71          #include "AddrMgr.h"
     72          
     73          #include "se.h"
     74          #include "esp.h"
     75          #include "zcl_general.h"
     76          #include "zcl_se.h"
     77          #include "zcl_key_establish.h"
     78          
     79          #if defined( INTER_PAN )
     80            #include "stub_aps.h"
     81          #endif
     82          
     83          #include "onboard.h"
     84          
     85          /* HAL */
     86          #include "hal_lcd.h"
     87          #include "hal_led.h"
     88          #include "hal_key.h"
     89          
     90          
     91          /*********************************************************************
     92           * MACROS
     93           */
     94          
     95          // There is no attribute in the Mandatory Reportable Attribute list for now
     96          #define zcl_MandatoryReportableAttribute( a ) ( a == NULL )
     97          
     98          /*********************************************************************
     99           * CONSTANTS
    100           */
    101          
    102          #define ESP_MIN_REPORTING_INTERVAL       5
    103          
    104          /*********************************************************************
    105           * TYPEDEFS
    106           */
    107          
    108          /*********************************************************************
    109           * GLOBAL VARIABLES
    110           */
    111          
    112          /*********************************************************************
    113           * GLOBAL FUNCTIONS
    114           */
    115          
    116          /*********************************************************************
    117           * LOCAL VARIABLES
    118           */
    119          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    120          static uint8 espTaskID;                              // esp osal task id
   \                     espTaskID:
   \   000000                DS8 1

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    121          static afAddrType_t ipdAddr;                         // destination address of in premise display
   \                     ipdAddr:
   \   000000                DS8 12

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    122          static afAddrType_t pctAddr;                         // destination address of PCT
   \                     pctAddr:
   \   000000                DS8 12

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    123          static afAddrType_t loadControlAddr;                 // destination address of load control device
   \                     loadControlAddr:
   \   000000                DS8 12

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    124          static zAddrType_t simpleDescReqAddr;                // destination addresses for simple desc request
   \                     simpleDescReqAddr:
   \   000000                DS8 10

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    125          static zclCCLoadControlEvent_t loadControlCmd;       // command structure for load control command
   \                     loadControlCmd:
   \   000000                DS8 26

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    126          static uint16 espFastPollModeDuration;               // number of fast poll events
   \                     espFastPollModeDuration:
   \   000000                DS8 2
    127          
    128          #if defined ( INTER_PAN )
    129          // define endpoint structure to register with STUB APS for INTER-PAN support

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    130          static endPointDesc_t espEp =
   \                     espEp:
   \   000000                DS8 8
   \   000008                REQUIRE `?<Initializer for espEp>`
    131          {
    132            ESP_ENDPOINT,
    133            &espTaskID,
    134            (SimpleDescriptionFormat_t *)&espSimpleDesc,
    135            (afNetworkLatencyReq_t)0
    136          };
    137          #endif
    138          
    139          /*********************************************************************
    140           * LOCAL FUNCTIONS
    141           */
    142          static void esp_HandleKeys( uint8 shift, uint8 keys );
    143          static void esp_ProcessAppMsg( uint8 *msg );
    144          
    145          #if defined (ZCL_ALARMS)
    146          static void esp_ProcessAlarmCmd( uint8 srcEP, afAddrType_t *dstAddr,
    147                                  uint16 clusterID, zclFrameHdr_t *hdr, uint8 len, uint8 *data );
    148          #endif // ZCL_ALARMS
    149          
    150          static void esp_ProcessIdentifyTimeChange( void );
    151          
    152          /*************************************************************************/
    153          /*** Application Callback Functions                                    ***/
    154          /*************************************************************************/
    155          
    156          // Foundation Callback functions
    157          static uint8 esp_ValidateAttrDataCB( zclAttrRec_t *pAttr, zclWriteRec_t *pAttrInfo );
    158          
    159          // General Cluster Callback functions
    160          static void esp_BasicResetCB( void );
    161          static void esp_IdentifyCB( zclIdentify_t *pCmd );
    162          static void esp_IdentifyQueryRspCB( zclIdentifyQueryRsp_t *pRsp );
    163          static void esp_AlarmCB( zclAlarm_t *pAlarm );
    164          
    165          // SE Callback functions
    166          static void esp_GetProfileCmdCB( zclCCGetProfileCmd_t *pCmd,
    167                                                 afAddrType_t *srcAddr, uint8 seqNum );
    168          static void esp_GetProfileRspCB( zclCCGetProfileRsp_t *pCmd,
    169                                                 afAddrType_t *srcAddr, uint8 seqNum );
    170          static void esp_ReqMirrorCmdCB( afAddrType_t *srcAddr, uint8 seqNum );
    171          static void esp_ReqMirrorRspCB( zclCCReqMirrorRsp_t *pCmd,
    172                                                 afAddrType_t *srcAddr, uint8 seqNum );
    173          static void esp_MirrorRemCmdCB( afAddrType_t *srcAddr, uint8 seqNum );
    174          static void esp_MirrorRemRspCB( zclCCMirrorRemRsp_t *pCmd,
    175                                                 afAddrType_t *srcAddr, uint8 seqNum );
    176          static void esp_ReqFastPollModeCmdCB( zclCCReqFastPollModeCmd_t *pCmd,
    177                                                 afAddrType_t *srcAddr, uint8 seqNum ) ;
    178          static void esp_ReqFastPollModeRspCB( zclCCReqFastPollModeRsp_t *pRsp,
    179                                                 afAddrType_t *srcAddr, uint8 seqNum ) ;
    180          static void esp_GetCurrentPriceCB( zclCCGetCurrentPrice_t *pCmd,
    181                                                 afAddrType_t *srcAddr, uint8 seqNum );
    182          static void esp_GetScheduledPriceCB( zclCCGetScheduledPrice_t *pCmd,
    183                                                 afAddrType_t *srcAddr, uint8 seqNum );
    184          static void esp_PriceAcknowledgementCB( zclCCPriceAcknowledgement_t *pCmd,
    185                                                 afAddrType_t *srcAddr, uint8 seqNum );
    186          static void esp_GetBlockPeriodCB( zclCCGetBlockPeriod_t *pCmd,
    187                                                 afAddrType_t *srcAddr, uint8 seqNum );
    188          static void esp_PublishPriceCB( zclCCPublishPrice_t *pCmd,
    189                                                 afAddrType_t *srcAddr, uint8 seqNum );
    190          static void esp_PublishBlockPeriodCB( zclCCPublishBlockPeriod_t *pCmd,
    191                                                 afAddrType_t *srcAddr, uint8 seqNum );
    192          static void esp_DisplayMessageCB( zclCCDisplayMessage_t *pCmd,
    193                                                 afAddrType_t *srcAddr, uint8 seqNum );
    194          static void esp_CancelMessageCB( zclCCCancelMessage_t *pCmd,
    195                                                 afAddrType_t *srcAddr, uint8 seqNum );
    196          static void esp_GetLastMessageCB( afAddrType_t *srcAddr, uint8 seqNum );
    197          static void esp_MessageConfirmationCB( zclCCMessageConfirmation_t *pCmd,
    198                                                 afAddrType_t *srcAddr, uint8 seqNum );
    199          static void esp_LoadControlEventCB( zclCCLoadControlEvent_t *pCmd,
    200                                                 afAddrType_t *srcAddr, uint8 status, uint8 seqNum);
    201          static void esp_CancelLoadControlEventCB( zclCCCancelLoadControlEvent_t *pCmd,
    202                                                 afAddrType_t *srcAddr, uint8 seqNum );
    203          static void esp_CancelAllLoadControlEventsCB( zclCCCancelAllLoadControlEvents_t *pCmd,
    204                                                 afAddrType_t *srcAddr, uint8 seqNum );
    205          static void esp_ReportEventStatusCB( zclCCReportEventStatus_t *pCmd,
    206                                                 afAddrType_t *srcAddr, uint8 seqNum );
    207          static void esp_GetScheduledEventCB( zclCCGetScheduledEvent_t *pCmd,
    208                                                 afAddrType_t *srcAddr, uint8 seqNum );
    209          static void esp_SelAvailEmergencyCreditCmdCB( zclCCSelAvailEmergencyCredit_t *pCmd,
    210                                                 afAddrType_t *srcAddr, uint8 seqNum );
    211          static void esp_ChangeSupplyCmdCB( zclCCChangeSupply_t *pCmd,
    212                                                 afAddrType_t *srcAddr, uint8 seqNum );
    213          static void esp_SupplyStatusRspCB( zclCCSupplyStatusResponse_t *pCmd,
    214                                                 afAddrType_t *srcAddr, uint8 seqNum );
    215          
    216          /************************************************************************/
    217          /***               Functions to process ZCL Foundation                ***/
    218          /***               incoming Command/Response messages                 ***/
    219          /************************************************************************/
    220          static void esp_ProcessZCLMsg( zclIncomingMsg_t *msg );
    221          #if defined ( ZCL_READ )
    222          static uint8 esp_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg );
    223          #endif // ZCL_READ
    224          #if defined ( ZCL_WRITE )
    225          static uint8 esp_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg );
    226          #endif // ZCL_WRITE
    227          #if defined ( ZCL_REPORT )
    228          static uint8 esp_ProcessInConfigReportCmd( zclIncomingMsg_t *pInMsg );
    229          static uint8 esp_ProcessInConfigReportRspCmd( zclIncomingMsg_t *pInMsg );
    230          static uint8 esp_ProcessInReadReportCfgCmd( zclIncomingMsg_t *pInMsg );
    231          static uint8 esp_ProcessInReadReportCfgRspCmd( zclIncomingMsg_t *pInMsg );
    232          static uint8 esp_ProcessInReportCmd( zclIncomingMsg_t *pInMsg );
    233          #endif // ZCL_REPORT
    234          static uint8 esp_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg );
    235          #if defined ( ZCL_DISCOVER )
    236          static uint8 esp_ProcessInDiscRspCmd( zclIncomingMsg_t *pInMsg );
    237          #endif // ZCL_DISCOVER
    238          
    239          // Functions to handle ZDO messages
    240          static void esp_ProcessZDOMsg( zdoIncomingMsg_t *inMsg );
    241          
    242          /*********************************************************************
    243           * ZCL General Clusters Callback table
    244           */

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    245          static zclGeneral_AppCallbacks_t esp_GenCmdCallbacks =
   \                     esp_GenCmdCallbacks:
   \   000000                DS8 60
   \   00003C                REQUIRE `?<Initializer for esp_GenCmdCallbacks>`
    246          {
    247            esp_BasicResetCB,              // Basic Cluster Reset command
    248            esp_IdentifyCB,                // Identify command
    249            esp_IdentifyQueryRspCB,        // Identify Query Response command
    250            NULL,                          // On/Off cluster commands
    251            NULL,                          // Level Control Move to Level command
    252            NULL,                          // Level Control Move command
    253            NULL,                          // Level Control Step command
    254            NULL,                          // Level Control Stop command
    255            NULL,                          // Group Response commands
    256            NULL,                          // Scene Store Request command
    257            NULL,                          // Scene Recall Request command
    258            NULL,                          // Scene Response command
    259            esp_AlarmCB,                   // Alarm (Response) command
    260            NULL,                          // RSSI Location command
    261            NULL                           // RSSI Location Response command
    262          };
    263          
    264          /*********************************************************************
    265           * ZCL SE Clusters Callback table
    266           */

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    267          static zclSE_AppCallbacks_t esp_SECmdCallbacks =			
   \                     esp_SECmdCallbacks:
   \   000000                DS8 104
   \   000068                REQUIRE `?<Initializer for esp_SECmdCallbacks>`
    268          {
    269            esp_GetProfileCmdCB,                     // Get Profile Command
    270            esp_GetProfileRspCB,                     // Get Profile Response
    271            esp_ReqMirrorCmdCB,                      // Request Mirror Command
    272            esp_ReqMirrorRspCB,                      // Request Mirror Response
    273            esp_MirrorRemCmdCB,                      // Mirror Remove Command
    274            esp_MirrorRemRspCB,                      // Mirror Remove Response
    275            esp_GetCurrentPriceCB,                   // Get Current Price
    276            esp_GetScheduledPriceCB,                 // Get Scheduled Price
    277            esp_PublishPriceCB,                      // Publish Price
    278            esp_DisplayMessageCB,                    // Display Message Command
    279            esp_CancelMessageCB,                     // Cancel Message Command
    280            esp_GetLastMessageCB,                    // Get Last Message Command
    281            esp_MessageConfirmationCB,               // Message Confirmation
    282            esp_LoadControlEventCB,                  // Load Control Event
    283            esp_CancelLoadControlEventCB,            // Cancel Load Control Event
    284            esp_CancelAllLoadControlEventsCB,        // Cancel All Load Control Events
    285            esp_ReportEventStatusCB,                 // Report Event Status
    286            esp_GetScheduledEventCB,                 // Get Scheduled Event
    287            esp_ReqFastPollModeCmdCB,                // Request Fast Poll Mode Command
    288            esp_ReqFastPollModeRspCB,                // Request Fast Poll Mode Response
    289            esp_PriceAcknowledgementCB,              // Price Acknowledgement
    290            esp_GetBlockPeriodCB,                    // Get Block Period
    291            esp_PublishBlockPeriodCB,                // Publish Block Period
    292            esp_SelAvailEmergencyCreditCmdCB,        // Select Available Emergency Credit Command
    293            esp_ChangeSupplyCmdCB,                   // Change Supply Command
    294            esp_SupplyStatusRspCB                    // Supply Status Response
    295          };
    296          
    297          /*********************************************************************
    298           * @fn          esp_Init
    299           *
    300           * @brief       Initialization function for the ZCL App Application.
    301           *
    302           * @param       uint8 task_id - esp task id
    303           *
    304           * @return      none
    305           */

   \                                 In  segment CODE, align 2
    306          void esp_Init( uint8 task_id )
   \                     esp_Init:
    307          {
   \   000000   1B15         PUSHM.W #0x2, R11
    308            espTaskID = task_id;
   \   000002   C24C....     MOV.B   R12, &espTaskID
    309          
    310            // Register for an SE endpoint
    311            zclSE_Init( &espSimpleDesc );
   \   000006   3C40....     MOV.W   #espSimpleDesc, R12
   \   00000A   ........     CALLA   #zclSE_Init
    312          
    313            // Register the ZCL General Cluster Library callback functions
    314            zclGeneral_RegisterCmdCallbacks( ESP_ENDPOINT, &esp_GenCmdCallbacks );
   \   00000E   7A400900     MOV.B   #0x9, R10
   \   000012   3D40....     MOV.W   #esp_GenCmdCallbacks, R13
   \   000016   4C4A         MOV.B   R10, R12
   \   000018   ........     CALLA   #zclGeneral_RegisterCmdCallbacks
    315          
    316            // Register the ZCL SE Cluster Library callback functions
    317            zclSE_RegisterCmdCallbacks( ESP_ENDPOINT, &esp_SECmdCallbacks );
   \   00001C   3D40....     MOV.W   #esp_SECmdCallbacks, R13
   \   000020   4C4A         MOV.B   R10, R12
   \   000022   ........     CALLA   #zclSE_RegisterCmdCallbacks
    318          
    319            // Register the application's attribute list
    320            zcl_registerAttrList( ESP_ENDPOINT, ESP_MAX_ATTRIBUTES, espAttrs );
   \   000026   3E40....     MOV.W   #espAttrs, R14
   \   00002A   7D405900     MOV.B   #0x59, R13
   \   00002E   4C4A         MOV.B   R10, R12
   \   000030   ........     CALLA   #zcl_registerAttrList
    321          
    322            // Register the application's cluster option list
    323            zcl_registerClusterOptionList( ESP_ENDPOINT, ESP_MAX_OPTIONS, espOptions );
   \   000034   3E40....     MOV.W   #espOptions, R14
   \   000038   7D400700     MOV.B   #0x7, R13
   \   00003C   4C4A         MOV.B   R10, R12
   \   00003E   ........     CALLA   #zcl_registerClusterOptionList
    324          
    325            // Register the application's attribute data validation callback function
    326            zcl_registerValidateAttrData( esp_ValidateAttrDataCB );
   \   000042   3C40....     MOV.W   #LWRD(esp_ValidateAttrDataCB), R12
   \   000046   3D40....     MOV.W   #HWRD(esp_ValidateAttrDataCB), R13
   \   00004A   ........     CALLA   #zcl_registerValidateAttrData
    327          
    328            // Register the Application to receive the unprocessed Foundation command/response messages
    329            zcl_registerForMsg( espTaskID );
   \   00004E   3B40....     MOV.W   #espTaskID, R11
   \   000052   6C4B         MOV.B   @R11, R12
   \   000054   ........     CALLA   #zcl_registerForMsg
    330          
    331            // register for end device annce and simple descriptor responses
    332            ZDO_RegisterForZDOMsg( espTaskID, Device_annce );
   \   000058   3D401300     MOV.W   #0x13, R13
   \   00005C   6C4B         MOV.B   @R11, R12
   \   00005E   ........     CALLA   #ZDO_RegisterForZDOMsg
    333            ZDO_RegisterForZDOMsg( espTaskID, Simple_Desc_rsp );
   \   000062   3D400480     MOV.W   #0x8004, R13
   \   000066   6C4B         MOV.B   @R11, R12
   \   000068   ........     CALLA   #ZDO_RegisterForZDOMsg
    334          
    335            // Register for all key events - This app will handle all key events
    336            RegisterForKeys( espTaskID );
   \   00006C   6C4B         MOV.B   @R11, R12
   \   00006E   ........     CALLA   #RegisterForKeys
    337          
    338          #if defined ( INTER_PAN )
    339            // Register with Stub APS
    340            StubAPS_RegisterApp( &espEp );
   \   000072   3C40....     MOV.W   #espEp, R12
   \   000076   ........     CALLA   #StubAPS_RegisterApp
    341          #endif
    342          
    343            // Start the timer to sync esp timer with the osal timer
    344            osal_start_timerEx( espTaskID, ESP_UPDATE_TIME_EVT, ESP_UPDATE_TIME_PERIOD );
   \   00007A   3E40E803     MOV.W   #0x3e8, R14
   \   00007E   2D43         MOV.W   #0x2, R13
   \   000080   6C4B         MOV.B   @R11, R12
   \   000082   ........     CALLA   #osal_start_timerEx
    345          
    346            // setup address mode and destination endpoint fields for PCT
    347            pctAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000086   E243....     MOV.B   #0x2, &pctAddr + 8
    348            pctAddr.endPoint = ESP_ENDPOINT;
   \   00008A   C24A....     MOV.B   R10, &pctAddr + 9
    349          
    350            // setup address mode and destination endpoint fields for load control device
    351            loadControlAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   00008E   E243....     MOV.B   #0x2, &loadControlAddr + 8
    352            loadControlAddr.endPoint = ESP_ENDPOINT;
   \   000092   C24A....     MOV.B   R10, &loadControlAddr + 9
    353          
    354            //setup load control command structure
    355            loadControlCmd.issuerEvent = 0x12345678;            // arbitrary id
   \   000096   B2407856.... MOV.W   #0x5678, &loadControlCmd
   \   00009C   B2403412.... MOV.W   #0x1234, &loadControlCmd + 2
    356            loadControlCmd.deviceGroupClass = 0x000000;         // addresses all groups
   \   0000A2   8243....     MOV.W   #0x0, &loadControlCmd + 4
   \   0000A6   8243....     MOV.W   #0x0, &loadControlCmd + 6
    357            loadControlCmd.startTime = 0x00000000;              // start time = NOW
   \   0000AA   8243....     MOV.W   #0x0, &loadControlCmd + 8
   \   0000AE   8243....     MOV.W   #0x0, &loadControlCmd + 10
    358            loadControlCmd.durationInMinutes = 0x0001;          // duration of one minute
   \   0000B2   9243....     MOV.W   #0x1, &loadControlCmd + 12
    359            loadControlCmd.criticalityLevel = 0x01;             // green level
   \   0000B6   D243....     MOV.B   #0x1, &loadControlCmd + 14
    360            loadControlCmd.coolingTemperatureSetPoint = 0x076C; // 19 degrees C, 66.2 degress fahrenheit
   \   0000BA   B2406C07.... MOV.W   #0x76c, &loadControlCmd + 18
    361            loadControlCmd.eventControl = 0x00;                 // no randomized start or end applied
   \   0000C0   C243....     MOV.B   #0x0, &loadControlCmd + 24
    362          
    363            // Initialize variable used to control number of fast poll events
    364            espFastPollModeDuration = 0;
   \   0000C4   8243....     MOV.W   #0x0, &espFastPollModeDuration
    365          }
   \   0000C8   1A17         POPM.W  #0x2, R11
   \   0000CA   1001         RETA
    366          
    367          /*********************************************************************
    368           * @fn          esp_event_loop
    369           *
    370           * @brief       Event Loop Processor for esp.
    371           *
    372           * @param       uint8 task_id - esp task id
    373           * @param       uint16 events - event bitmask
    374           *
    375           * @return      none
    376           */

   \                                 In  segment CODE, align 2
    377          uint16 esp_event_loop( uint8 task_id, uint16 events )
   \                     esp_event_loop:
    378          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
    379            afIncomingMSGPacket_t *MSGpkt;
    380          
    381            if ( events & SYS_EVENT_MSG )
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   1038         JL      ??esp_event_loop_3
    382            {
    383              while ( (MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( espTaskID )) )
    384              {
    385                switch ( MSGpkt->hdr.event )
    386                {
    387                  case MT_SYS_APP_MSG:
    388                    // Message received from MT (serial port)
    389                    esp_ProcessAppMsg( ((mtSysAppMsg_t *)MSGpkt)->appData );
    390                    break;
    391          
    392                  case ZCL_INCOMING_MSG:
    393                    // Incoming ZCL foundation command/response messages
    394                    esp_ProcessZCLMsg( (zclIncomingMsg_t *)MSGpkt );
    395                    break;
    396          
    397                  case KEY_CHANGE:
    398                    esp_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    399                    break;
    400          
    401                  case ZDO_CB_MSG:
    402                    // ZDO sends the message that we registered for
    403                    esp_ProcessZDOMsg( (zdoIncomingMsg_t *)MSGpkt );
    404                    break;
    405          
    406                  default:
    407                    break;
    408                }
    409          
    410                // Release the memory
    411                osal_msg_deallocate( (uint8 *)MSGpkt );
    412          
    413              }
    414          
    415              // return unprocessed events
    416              return (events ^ SYS_EVENT_MSG);
    417            }
    418          
    419            // handle processing of identify timeout event triggered by an identify command
    420            if ( events & ESP_IDENTIFY_TIMEOUT_EVT )
   \   000008   1DB3         BIT.W   #0x1, R13
   \   00000A   2D28         JNC     ??esp_event_loop_4
    421            {
    422              if ( espIdentifyTime > 0 )
   \   00000C   8293....     CMP.W   #0x0, &espIdentifyTime
   \   000010   0224         JEQ     ??esp_event_loop_5
    423              {
    424                espIdentifyTime--;
   \   000012   B253....     ADD.W   #0xffff, &espIdentifyTime
    425              }
    426              esp_ProcessIdentifyTimeChange();
   \                     ??esp_event_loop_5:
   \   000016   ........     CALLA   #esp_ProcessIdentifyTimeChange
    427          
    428              return ( events ^ ESP_IDENTIFY_TIMEOUT_EVT );
   \   00001A   1AE3         XOR.W   #0x1, R10
   \   00001C   4A3C         JMP     ??esp_event_loop_2
    429            }
   \                     ??esp_event_loop_0:
   \   00001E   ........     CALLA   #esp_ProcessZDOMsg
   \                     ??esp_event_loop_1:
   \   000022   0C4B         MOV.W   R11, R12
   \   000024   ........     CALLA   #osal_msg_deallocate
   \                     ??esp_event_loop_3:
   \   000028   5C42....     MOV.B   &espTaskID, R12
   \   00002C   ........     CALLA   #osal_msg_receive
   \   000030   0B4C         MOV.W   R12, R11
   \   000032   0C93         CMP.W   #0x0, R12
   \   000034   1524         JEQ     ??esp_event_loop_6
   \   000036   6E4C         MOV.B   @R12, R14
   \   000038   7E803400     SUB.B   #0x34, R14
   \   00003C   0724         JEQ     ??esp_event_loop_7
   \   00003E   7E808C00     SUB.B   #0x8c, R14
   \   000042   0724         JEQ     ??esp_event_loop_8
   \   000044   7E801300     SUB.B   #0x13, R14
   \   000048   EA27         JEQ     ??esp_event_loop_0
   \   00004A   EB3F         JMP     ??esp_event_loop_1
   \                     ??esp_event_loop_7:
   \   00004C   ........     CALLA   #esp_ProcessZCLMsg
   \   000050   E83F         JMP     ??esp_event_loop_1
   \                     ??esp_event_loop_8:
   \   000052   5D4C0300     MOV.B   0x3(R12), R13
   \   000056   5C4B0200     MOV.B   0x2(R11), R12
   \   00005A   ........     CALLA   #esp_HandleKeys
   \   00005E   E13F         JMP     ??esp_event_loop_1
   \                     ??esp_event_loop_6:
   \   000060   3AE00080     XOR.W   #0x8000, R10
   \   000064   263C         JMP     ??esp_event_loop_2
    430          
    431            // event to get current time
    432            if ( events & ESP_UPDATE_TIME_EVT )
   \                     ??esp_event_loop_4:
   \   000066   2DB3         BIT.W   #0x2, R13
   \   000068   0D28         JNC     ??esp_event_loop_9
    433            {
    434              espTime = osal_getClock();
   \   00006A   ........     CALLA   #osal_getClock
   \   00006E   824C....     MOV.W   R12, &espTime
   \   000072   824D....     MOV.W   R13, &espTime + 2
    435              osal_start_timerEx( espTaskID, ESP_UPDATE_TIME_EVT, ESP_UPDATE_TIME_PERIOD );
   \   000076   3E40E803     MOV.W   #0x3e8, R14
   \   00007A   2D43         MOV.W   #0x2, R13
   \   00007C   ........     CALLA   #??Subroutine3_0
    436          
    437              return ( events ^ ESP_UPDATE_TIME_EVT );
   \                     ??CrossCallReturnLabel_12:
   \   000080   2AE3         XOR.W   #0x2, R10
   \   000082   173C         JMP     ??esp_event_loop_2
    438            }
    439          
    440          
    441            // event to get simple descriptor of the newly joined device
    442            if ( events & SIMPLE_DESC_QUERY_EVT )
   \                     ??esp_event_loop_9:
   \   000084   2DB2         BIT.W   #0x4, R13
   \   000086   0B28         JNC     ??esp_event_loop_10
    443            {
    444                ZDP_SimpleDescReq( &simpleDescReqAddr, simpleDescReqAddr.addr.shortAddr,
    445                                  ESP_ENDPOINT, 0);
   \   000088   4F43         MOV.B   #0x0, R15
   \   00008A   7E400900     MOV.B   #0x9, R14
   \   00008E   1D42....     MOV.W   &simpleDescReqAddr, R13
   \   000092   3C40....     MOV.W   #simpleDescReqAddr, R12
   \   000096   ........     CALLA   #ZDP_SimpleDescReq
    446          
    447                return ( events ^ SIMPLE_DESC_QUERY_EVT );
   \   00009A   2AE2         XOR.W   #0x4, R10
   \   00009C   0A3C         JMP     ??esp_event_loop_2
    448            }
    449          
    450            // handle processing of timeout event triggered by request fast polling command
    451            if ( events & ESP_FAST_POLL_MODE_EVT )
   \                     ??esp_event_loop_10:
   \   00009E   3DB2         BIT.W   #0x8, R13
   \   0000A0   0A28         JNC     ??esp_event_loop_11
    452            {
    453              if (espFastPollModeDuration)
   \   0000A2   8293....     CMP.W   #0x0, &espFastPollModeDuration
   \   0000A6   0424         JEQ     ??esp_event_loop_12
    454              {
    455                espFastPollModeDuration--;
   \   0000A8   B253....     ADD.W   #0xffff, &espFastPollModeDuration
    456                // Start the timer for the fast poll period
    457                osal_start_timerEx( espTaskID, ESP_FAST_POLL_MODE_EVT, ESP_FAST_POLL_TIMER_PERIOD );
   \   0000AC   ........     CALLA   #?Subroutine3
    458              }
    459          
    460              return ( events ^ ESP_FAST_POLL_MODE_EVT );
   \                     ??esp_event_loop_12:
   \   0000B0   3AE2         XOR.W   #0x8, R10
   \                     ??esp_event_loop_2:
   \   0000B2   0C4A         MOV.W   R10, R12
   \   0000B4   013C         JMP     ??esp_event_loop_13
    461            }
    462          
    463            // Discard unknown events
    464            return 0;
   \                     ??esp_event_loop_11:
   \   0000B6   0C43         MOV.W   #0x0, R12
   \                     ??esp_event_loop_13:
   \   0000B8   1A17         POPM.W  #0x2, R11
   \   0000BA   1001         RETA
    465          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   3E40E803     MOV.W   #0x3e8, R14
   \   000004   3D42         MOV.W   #0x8, R13
   \   000006                REQUIRE ??Subroutine3_0
   \   000006                // Fall through to label ??Subroutine3_0

   \                                 In  segment CODE, align 2
   \                     ??Subroutine3_0:
   \   000000   5C42....     MOV.B   &espTaskID, R12
   \   000004   ........     BRA     #osal_start_timerEx
    466          
    467          /*********************************************************************
    468           * @fn      esp_ProcessAppMsg
    469           *
    470           * @brief   Process MT SYS APP MSG
    471           *
    472           * @param   msg - pointer to message
    473           *
    474           * @return  none
    475           */
    476          static void esp_ProcessAppMsg( uint8 *msg )
    477          {
    478            // user should include code to handle MT SYS APP MSG here
    479          }
    480          
    481          /*********************************************************************
    482           * @fn      esp_ProcessIdentifyTimeChange
    483           *
    484           * @brief   Called to blink led for specified IdentifyTime attribute value
    485           *
    486           * @param   none
    487           *
    488           * @return  none
    489           */

   \                                 In  segment CODE, align 2
    490          static void esp_ProcessIdentifyTimeChange( void )
   \                     esp_ProcessIdentifyTimeChange:
    491          {
    492            if ( espIdentifyTime > 0 )
   \   000000   8293....     CMP.W   #0x0, &espIdentifyTime
   \   000004   0D24         JEQ     ??esp_ProcessIdentifyTimeChange_0
    493            {
    494              osal_start_timerEx( espTaskID, ESP_IDENTIFY_TIMEOUT_EVT, 1000 );
   \   000006   3E40E803     MOV.W   #0x3e8, R14
   \   00000A   1D43         MOV.W   #0x1, R13
   \   00000C   ........     CALLA   #??Subroutine3_0
    495              HalLedBlink ( HAL_LED_4, 0xFF, HAL_LED_DEFAULT_DUTY_CYCLE, HAL_LED_DEFAULT_FLASH_TIME );
   \                     ??CrossCallReturnLabel_13:
   \   000010   3F40E803     MOV.W   #0x3e8, R15
   \   000014   7E400500     MOV.B   #0x5, R14
   \   000018   7D43         MOV.B   #0xff, R13
   \   00001A   7C42         MOV.B   #0x8, R12
   \   00001C   ........     BRA     #HalLedBlink
    496            }
    497            else
    498            {
    499              HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
   \                     ??esp_ProcessIdentifyTimeChange_0:
   \   000020   4D43         MOV.B   #0x0, R13
   \   000022   7C42         MOV.B   #0x8, R12
   \   000024   ........     CALLA   #HalLedSet
    500              osal_stop_timerEx( espTaskID, ESP_IDENTIFY_TIMEOUT_EVT );
   \   000028   1D43         MOV.W   #0x1, R13
   \   00002A   5C42....     MOV.B   &espTaskID, R12
   \   00002E   ........     BRA     #osal_stop_timerEx
    501            }
    502          }
    503          
    504          
    505          /*********************************************************************
    506           * @fn      esp_HandleKeys
    507           *
    508           * @brief   Handles all key events for this device.
    509           *
    510           * @param   shift - true if in shift/alt.
    511           * @param   keys - bit field for key events. Valid entries:
    512           *                 HAL_KEY_SW_4
    513           *                 HAL_KEY_SW_3
    514           *                 HAL_KEY_SW_2
    515           *                 HAL_KEY_SW_1
    516           *
    517           * @return  none
    518           */

   \                                 In  segment CODE, align 2
    519          static void esp_HandleKeys( uint8 shift, uint8 keys )
   \                     esp_HandleKeys:
    520          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31802400     SUB.W   #0x24, SP
   \   000006   4A4D         MOV.B   R13, R10
    521            // Shift is used to make each button/switch dual purpose.
    522            if ( shift )
   \   000008   4C93         CMP.B   #0x0, R12
   \   00000A   4220         JNE     ??esp_HandleKeys_0
    523            {
    524              if ( keys & HAL_KEY_SW_1 )
    525              {
    526              }
    527              if ( keys & HAL_KEY_SW_2 )
    528              {
    529              }
    530              if ( keys & HAL_KEY_SW_3 )
    531              {
    532              }
    533              if ( keys & HAL_KEY_SW_4 )
    534              {
    535              }
    536            }
    537            else
    538            {
    539              if ( keys & HAL_KEY_SW_1 )
   \   00000C   5DB3         BIT.B   #0x1, R13
   \   00000E   0F28         JNC     ??esp_HandleKeys_1
    540              {
    541                // send out cooling event to PCT
    542                loadControlCmd.deviceGroupClass = HVAC_DEVICE_CLASS; // HVAC compressor or furnace - bit 0 is set
   \   000010   9243....     MOV.W   #0x1, &loadControlCmd + 4
   \   000014   8243....     MOV.W   #0x0, &loadControlCmd + 6
    543                zclSE_LoadControl_Send_LoadControlEvent( ESP_ENDPOINT, &pctAddr, &loadControlCmd, TRUE, 0 );
   \   000018   4312         PUSH.B  #0x0
   \   00001A   5F43         MOV.B   #0x1, R15
   \   00001C   3E40....     MOV.W   #loadControlCmd, R14
   \   000020   3D40....     MOV.W   #pctAddr, R13
   \   000024   7C400900     MOV.B   #0x9, R12
   \   000028   ........     CALLA   #zclSE_LoadControl_Send_LoadControlEvent
   \   00002C   2153         ADD.W   #0x2, SP
    544              }
    545          
    546              if ( keys & HAL_KEY_SW_2 )
   \                     ??esp_HandleKeys_1:
   \   00002E   6AB3         BIT.B   #0x2, R10
   \   000030   1028         JNC     ??esp_HandleKeys_2
    547              {
    548                // send out load control event to load control device
    549                loadControlCmd.deviceGroupClass = ONOFF_LOAD_DEVICE_CLASS; // simple misc residential on/off loads - bit 7 is set
   \   000032   B2408000.... MOV.W   #0x80, &loadControlCmd + 4
   \   000038   8243....     MOV.W   #0x0, &loadControlCmd + 6
    550                zclSE_LoadControl_Send_LoadControlEvent( ESP_ENDPOINT, &loadControlAddr, &loadControlCmd, TRUE, 0 );
   \   00003C   4312         PUSH.B  #0x0
   \   00003E   5F43         MOV.B   #0x1, R15
   \   000040   3E40....     MOV.W   #loadControlCmd, R14
   \   000044   3D40....     MOV.W   #loadControlAddr, R13
   \   000048   7C400900     MOV.B   #0x9, R12
   \   00004C   ........     CALLA   #zclSE_LoadControl_Send_LoadControlEvent
   \   000050   2153         ADD.W   #0x2, SP
    551              }
    552          
    553              if ( keys & HAL_KEY_SW_3 )
   \                     ??esp_HandleKeys_2:
   \   000052   7AB01000     BIT.B   #0x10, R10
   \   000056   1C28         JNC     ??esp_HandleKeys_0
    554              {
    555                zclCCDisplayMessage_t displayCmd;             // command structure for message being sent to in premise display
    556          
    557                // Define to zero to send the TI IPD message, non-zero to send a string of abc's.
    558          #if   !defined IPD_MSG_SZ
    559                #define  IPD_MSG_SZ  0
    560          #endif
    561          #if   (IPD_MSG_SZ == 0)
    562                uint8 msgBuf[]="TI IPD Test Msg!";
   \   000058   0C41         MOV.W   SP, R12
   \   00005A   3C501200     ADD.W   #0x12, R12
   \   00005E   3E40....     MOV.W   #`?<Constant "TI IPD Test Msg!">`, R14
   \   000062   3D401100     MOV.W   #0x11, R13
   \   000066   ........     CALLA   #?CopyMemoryBytes
    563                const uint8 msgLen = sizeof(msgBuf);
    564          #else
    565                uint8 *msgBuf = osal_mem_alloc(IPD_MSG_SZ);
    566                const uint8 msgLen = IPD_MSG_SZ;
    567                uint8 idx;
    568          
    569                if (!msgBuf)  return;
    570          
    571                for (idx = 0; idx < msgLen; idx ++)
    572                {
    573                  msgBuf[idx] = 'a' + idx % 26;
    574                }
    575          #endif
    576          
    577                displayCmd.msgString.strLen = msgLen;
   \   00006A   F14011000E00 MOV.B   #0x11, 0xe(SP)
    578                displayCmd.msgString.pStr = msgBuf;
   \   000070   0F41         MOV.W   SP, R15
   \   000072   3F501200     ADD.W   #0x12, R15
   \   000076   814F1000     MOV.W   R15, 0x10(SP)
    579          
    580                zclSE_Message_Send_DisplayMessage( ESP_ENDPOINT, &ipdAddr, &displayCmd, TRUE, 0 );
   \   00007A   4312         PUSH.B  #0x0
   \   00007C   5F43         MOV.B   #0x1, R15
   \   00007E   0E41         MOV.W   SP, R14
   \   000080   2E53         ADD.W   #0x2, R14
   \   000082   3D40....     MOV.W   #ipdAddr, R13
   \   000086   7C400900     MOV.B   #0x9, R12
   \   00008A   ........     CALLA   #zclSE_Message_Send_DisplayMessage
   \   00008E   2153         ADD.W   #0x2, SP
    581          
    582          #if   (IPD_MSG_SZ != 0)
    583                osal_mem_free(msgBuf);
    584          #endif
    585              }
    586          
    587              if ( keys & HAL_KEY_SW_4 )
    588              {
    589          
    590              }
    591            }
    592          }
   \                     ??esp_HandleKeys_0:
   \   000090   31502400     ADD.W   #0x24, SP
   \   000094   3A41         POP.W   R10
   \   000096   1001         RETA
    593          
    594          /*********************************************************************
    595           * @fn      esp_ValidateAttrDataCB
    596           *
    597           * @brief   Check to see if the supplied value for the attribute data
    598           *          is within the specified range of the attribute.
    599           *
    600           *
    601           * @param   pAttr - pointer to attribute
    602           * @param   pAttrInfo - pointer to attribute info
    603           *
    604           * @return  TRUE if data valid. FALSE otherwise.
    605           */

   \                                 In  segment CODE, align 2
    606          static uint8 esp_ValidateAttrDataCB( zclAttrRec_t *pAttr, zclWriteRec_t *pAttrInfo )
   \                     esp_ValidateAttrDataCB:
    607          {
    608            uint8 valid = TRUE;
   \   000000   5C43         MOV.B   #0x1, R12
    609          
    610            switch ( pAttrInfo->dataType )
   \   000002   FD9010000200 CMP.B   #0x10, 0x2(R13)
   \   000008   0820         JNE     ??esp_ValidateAttrDataCB_0
    611            {
    612              case ZCL_DATATYPE_BOOLEAN:
    613                if ( ( *(pAttrInfo->attrData) != 0 ) && ( *(pAttrInfo->attrData) != 1 ) )
   \   00000A   1F4D0400     MOV.W   0x4(R13), R15
   \   00000E   6E4F         MOV.B   @R15, R14
   \   000010   4E93         CMP.B   #0x0, R14
   \   000012   0324         JEQ     ??esp_ValidateAttrDataCB_0
   \   000014   5E93         CMP.B   #0x1, R14
   \   000016   0124         JEQ     ??esp_ValidateAttrDataCB_0
    614                {
    615                  valid = FALSE;
   \   000018   4C43         MOV.B   #0x0, R12
    616                }
    617                break;
    618          
    619              default:
    620                break;
    621            }
    622          
    623            return ( valid );
   \                     ??esp_ValidateAttrDataCB_0:
   \   00001A   1001         RETA
    624          }
    625          
    626          /*********************************************************************
    627           * @fn      esp_BasicResetCB
    628           *
    629           * @brief   Callback from the ZCL General Cluster Library to set all
    630           *          the attributes of all the clusters to their factory defaults
    631           *
    632           * @param   none
    633           *
    634           * @return  none
    635           */

   \                                 In  segment CODE, align 2
    636          static void esp_BasicResetCB( void )
   \                     esp_BasicResetCB:
    637          {
    638            // user should handle setting attributes to factory defaults here
    639          }
   \   000000   1001         RETA
    640          
    641          /*********************************************************************
    642           * @fn      esp_IdentifyCB
    643           *
    644           * @brief   Callback from the ZCL General Cluster Library when
    645           *          it received an Identify Command for this application.
    646           *
    647           * @param   pCmd - pointer to structure for identify command
    648           *
    649           * @return  none
    650           */

   \                                 In  segment CODE, align 2
    651          static void esp_IdentifyCB( zclIdentify_t *pCmd )
   \                     esp_IdentifyCB:
    652          {
    653            espIdentifyTime = pCmd->identifyTime;
   \   000000   924C0200.... MOV.W   0x2(R12), &espIdentifyTime
    654            esp_ProcessIdentifyTimeChange();
   \   000006   ........     BRA     #esp_ProcessIdentifyTimeChange
    655          }
    656          
    657          /*********************************************************************
    658           * @fn      esp_IdentifyQueryRspCB
    659           *
    660           * @brief   Callback from the ZCL General Cluster Library when
    661           *          it received an Identity Query Response Command for this application.
    662           *
    663           * @param   pRsp - pointer to structure for identify query response
    664           *
    665           * @return  none
    666           */

   \                                 In  segment CODE, align 2
    667          static void esp_IdentifyQueryRspCB( zclIdentifyQueryRsp_t *pRsp )
   \                     esp_IdentifyQueryRspCB:
    668          {
    669            // add user code here
    670          }
   \   000000   1001         RETA
    671          
    672          /*********************************************************************
    673           * @fn      esp_AlarmCB
    674           *
    675           * @brief   Callback from the ZCL General Cluster Library when
    676           *          it received an Alam request or response command for
    677           *          this application.
    678           *
    679           * @param   pAlarm - pointer to structure for alarm command
    680           *
    681           * @return  none
    682           */

   \                                 In  segment CODE, align 2
    683          static void esp_AlarmCB( zclAlarm_t *pAlarm )
   \                     esp_AlarmCB:
    684          {
    685            // add user code here
    686          }
   \   000000   1001         RETA
    687          
    688          /*********************************************************************
    689           * @fn      esp_GetProfileCmdCB
    690           *
    691           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    692           *          it received a Get Profile Command for
    693           *          this application.
    694           *
    695           * @param   pCmd - pointer to get profile command structure
    696           * @param   srcAddr - pointer to source address
    697           * @param   seqNum - sequence number of this command
    698           *
    699           * @return  none
    700           */

   \                                 In  segment CODE, align 2
    701          static void esp_GetProfileCmdCB( zclCCGetProfileCmd_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_GetProfileCmdCB:
    702          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31801400     SUB.W   #0x14, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
   \   00000A   4F4E         MOV.B   R14, R15
    703          #if defined ( ZCL_SIMPLE_METERING )
    704            // Upon receipt of the Get Profile Command, the metering device shall send
    705            // Get Profile Response back.
    706          
    707            // Variables in the following are initialized to arbitrary value for test purpose
    708            // In real application, user shall look up the interval data captured during
    709            // the period specified in the pCmd->endTime and return corresponding data.
    710          
    711            uint32 endTime;
    712            uint8  status = zclSE_SimpleMeter_GetProfileRsp_Status_Success;
    713            uint8  profileIntervalPeriod = PROFILE_INTERVAL_PERIOD_60MIN;
    714            uint8  numberOfPeriodDelivered = 5;
    715            uint24 intervals[] = {0xa00001, 0xa00002, 0xa00003, 0xa00004, 0xa00005};
   \   00000C   0C41         MOV.W   SP, R12
   \   00000E   3E40....     MOV.W   #`?<Constant {10485761L, 10485762L, 10485763L, 1`, R14
   \   000012   3D400A00     MOV.W   #0xa, R13
   \   000016   ........     CALLA   #?CopyMemoryWords
    716          
    717            // endTime: 32 bit value (in UTC) representing the end time of the most
    718            // chronologically recent interval being requested.
    719            // Example: Data collected from 2:00 PM to 3:00 PM would be specified as a
    720            // 3:00 PM interval (end time).
    721          
    722            // The Intervals block returned shall be the most recent block with
    723            // its EndTime equal or older to the one in the request (pCmd->endTime).
    724            // Requested End Time with value 0xFFFFFFFF indicats the most recent
    725            // Intervals block is requested.
    726          
    727            // Sample Code - assuming the end time of the requested block is the same as
    728            // it in the request.
    729            endTime = pCmd->endTime;
    730          
    731            // Send Get Profile Response Command back
    732          
    733            zclSE_SimpleMetering_Send_GetProfileRsp( ESP_ENDPOINT, srcAddr, endTime,
    734                                                     status,
    735                                                     profileIntervalPeriod,
    736                                                     numberOfPeriodDelivered, intervals,
    737                                                     FALSE, seqNum );
   \   00001A   4F12         PUSH.B  R15
   \   00001C   4312         PUSH.B  #0x0
   \   00001E   0F41         MOV.W   SP, R15
   \   000020   2F52         ADD.W   #0x4, R15
   \   000022   0F12         PUSH.W  R15
   \   000024   70120500     PUSH.B  #0x5
   \   000028   5312         PUSH.B  #0x1
   \   00002A   4312         PUSH.B  #0x0
   \   00002C   1E4A0200     MOV.W   0x2(R10), R14
   \   000030   1F4A0400     MOV.W   0x4(R10), R15
   \   000034   0D4B         MOV.W   R11, R13
   \   000036   7C400900     MOV.B   #0x9, R12
   \   00003A   ........     CALLA   #zclSE_SimpleMetering_Send_GetProfileRsp
    738          #endif // ZCL_SIMPLE_METERING
    739          }
   \   00003E   31502000     ADD.W   #0x20, SP
   \   000042   1A17         POPM.W  #0x2, R11
   \   000044   1001         RETA
    740          
    741          /*********************************************************************
    742           * @fn      esp_GetProfileRspCB
    743           *
    744           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    745           *          it received a Get Profile Response for
    746           *          this application.
    747           *
    748           * @param   pCmd - pointer to get profile response structure
    749           * @param   srcAddr - pointer to source address
    750           * @param   seqNum - sequence number of this command
    751           *
    752           * @return  none
    753           */

   \                                 In  segment CODE, align 2
    754          static void esp_GetProfileRspCB( zclCCGetProfileRsp_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_GetProfileRspCB:
    755          {
    756            // add user code here
    757          }
   \   000000   1001         RETA
    758          
    759          /*********************************************************************
    760           * @fn      esp_ReqMirrorCmdCB
    761           *
    762           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    763           *          it received a Request Mirror Command for
    764           *          this application.
    765           *
    766           * @param   srcAddr - pointer to source address
    767           * @param   seqNum - sequence number of this command
    768           *
    769           * @return  none
    770           */

   \                                 In  segment CODE, align 2
    771          static void esp_ReqMirrorCmdCB( afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_ReqMirrorCmdCB:
    772          {
    773            // add user code here
    774          }
   \   000000   1001         RETA
    775          /*********************************************************************
    776           * @fn      esp_ReqMirrorRspCB
    777           *
    778           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    779           *          it received a Request Mirror Response for
    780           *          this application.
    781           *
    782           * @param   pRsp - pointer to request mirror response structure
    783           * @param   srcAddr - pointer to source address
    784           * @param   seqNum - sequence number of this command
    785           *
    786           * @return  none
    787           */

   \                                 In  segment CODE, align 2
    788          static void esp_ReqMirrorRspCB( zclCCReqMirrorRsp_t *pRsp, afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_ReqMirrorRspCB:
    789          {
    790            // add user code here
    791          }
   \   000000   1001         RETA
    792          /*********************************************************************
    793           * @fn      esp_MirrorRemCmdCB
    794           *
    795           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    796           *          it received a Mirror Remove Command for
    797           *          this application.
    798           *
    799           * @param   srcAddr - pointer to source address
    800           * @param   seqNum - sequence number of this command
    801           *
    802           * @return  none
    803           */

   \                                 In  segment CODE, align 2
    804          static void esp_MirrorRemCmdCB( afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_MirrorRemCmdCB:
    805          {
    806            // add user code here
    807          }
   \   000000   1001         RETA
    808          /*********************************************************************
    809           * @fn      esp_MirrorRemRspCB
    810           *
    811           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    812           *          it received a Mirror Remove Response for
    813           *          this application.
    814           *
    815           * @param   pCmd - pointer to mirror remove response structure
    816           * @param   srcAddr - pointer to source address
    817           * @param   seqNum - sequence number of this command
    818           *
    819           * @return  none
    820           */

   \                                 In  segment CODE, align 2
    821          static void esp_MirrorRemRspCB( zclCCMirrorRemRsp_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_MirrorRemRspCB:
    822          {
    823            // add user code here
    824          }
   \   000000   1001         RETA
    825          
    826          /*********************************************************************
    827           * @fn      esp_ReqFastPollModeCmdCB
    828           *
    829           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    830           *          it received a Request Fast Poll Mode Command for
    831           *          this application.
    832           *
    833           * @param   pCmd - pointer to Request Fast Poll Mode Command structure
    834           * @param   srcAddr - pointer to source address
    835           * @param   seqNum - sequence number of this command
    836           *
    837           * @return  none
    838           */

   \                                 In  segment CODE, align 2
    839          static void esp_ReqFastPollModeCmdCB( zclCCReqFastPollModeCmd_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_ReqFastPollModeCmdCB:
    840          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   084D         MOV.W   R13, R8
   \   000008   494E         MOV.B   R14, R9
    841          #if defined ( ZCL_SIMPLE_METERING )
    842            if ( pCmd != NULL )
   \   00000A   0C93         CMP.W   #0x0, R12
   \   00000C   4E24         JEQ     ??esp_ReqFastPollModeCmdCB_1
    843            {
    844              zclCCReqFastPollModeRsp_t fastPollRsp;
    845              UTCTime utcSecs;
    846          
    847              if (pCmd->fastPollUpdatePeriod < espFastPollUpdatePeriod)
   \   00000E   5E42....     MOV.B   &espFastPollUpdatePeriod, R14
   \   000012   6F4C         MOV.B   @R12, R15
   \   000014   4F9E         CMP.B   R14, R15
   \   000016   032C         JC      ??esp_ReqFastPollModeCmdCB_2
    848              {
    849                // handles client requests for a fast poll rate that is less than the
    850                // value of the its FastPollUpdateRate attribute
    851                fastPollRsp.appliedUpdatePeriod = espFastPollUpdatePeriod;
   \   000018   C14E0000     MOV.B   R14, 0(SP)
   \   00001C   023C         JMP     ??esp_ReqFastPollModeCmdCB_3
    852              }
    853              else
    854              {
    855                fastPollRsp.appliedUpdatePeriod = pCmd->fastPollUpdatePeriod;
   \                     ??esp_ReqFastPollModeCmdCB_2:
   \   00001E   C14F0000     MOV.B   R15, 0(SP)
    856              }
    857          
    858              if ((espFastPollModeDuration == 0) && (pCmd->duration > 0))
   \                     ??esp_ReqFastPollModeCmdCB_3:
   \   000022   8293....     CMP.W   #0x0, &espFastPollModeDuration
   \   000026   1520         JNE     ??esp_ReqFastPollModeCmdCB_4
   \   000028   5F4C0100     MOV.B   0x1(R12), R15
   \   00002C   4F93         CMP.B   #0x0, R15
   \   00002E   1124         JEQ     ??esp_ReqFastPollModeCmdCB_4
    859              {
    860                if (pCmd->duration > MAX_DURATION_IN_MINUTES_FAST_POLL_MODE)
   \   000030   7F901000     CMP.B   #0x10, R15
   \   000034   0228         JNC     ??esp_ReqFastPollModeCmdCB_0
    861                {
    862                  // handles client requests for duration that is greater than the
    863                  // maximum allowable 15 minutes.
    864                  espFastPollModeDuration = MAX_DURATION_IN_MINUTES_FAST_POLL_MODE;
   \   000036   3F400F00     MOV.W   #0xf, R15
    865                }
    866                else
    867                {
    868                  espFastPollModeDuration = pCmd->duration;
    869                }
    870          
    871                // This controls the counter for ZCLTESTAPP_FAST_POLL_MODE_EVT based on a 1 second timer
    872                espFastPollModeDuration *= 60;  // Duration in seconds
   \                     ??esp_ReqFastPollModeCmdCB_0:
   \   00003A   5F06         RLAM.W  #0x2, R15
   \   00003C   0B4F         MOV.W   R15, R11
   \   00003E   0F5F         RLA.W   R15
   \   000040   0B5F         ADD.W   R15, R11
   \   000042   0F5F         RLA.W   R15
   \   000044   0B5F         ADD.W   R15, R11
   \   000046   0F5F         RLA.W   R15
   \   000048   0F5B         ADD.W   R11, R15
   \   00004A   824F....     MOV.W   R15, &espFastPollModeDuration
    873          
    874                // Start the timer for the fast poll period
    875                osal_start_timerEx( espTaskID, ESP_FAST_POLL_MODE_EVT, ESP_FAST_POLL_TIMER_PERIOD );
   \   00004E   ........     CALLA   #?Subroutine3
    876              }
    877          
    878              // get UTC time and update with requested duration in seconds
    879              utcSecs = osal_getClock();
   \                     ??esp_ReqFastPollModeCmdCB_4:
   \   000052   ........     CALLA   #osal_getClock
   \   000056   0A4C         MOV.W   R12, R10
    880              fastPollRsp.fastPollModeEndTime = utcSecs + espFastPollModeDuration;
   \   000058   1E42....     MOV.W   &espFastPollModeDuration, R14
   \   00005C   0C5E         ADD.W   R14, R12
   \   00005E   0D63         ADDC.W  #0x0, R13
   \   000060   814C0200     MOV.W   R12, 0x2(SP)
   \   000064   814D0400     MOV.W   R13, 0x4(SP)
    881          
    882              zclSE_SimpleMetering_Send_ReqFastPollModeRsp( ESP_ENDPOINT, srcAddr,
    883                                                            &fastPollRsp,
    884                                                            TRUE, seqNum );
   \   000068   4912         PUSH.B  R9
   \   00006A   5F43         MOV.B   #0x1, R15
   \   00006C   0E41         MOV.W   SP, R14
   \   00006E   2E53         ADD.W   #0x2, R14
   \   000070   0D48         MOV.W   R8, R13
   \   000072   7C400900     MOV.B   #0x9, R12
   \   000076   ........     CALLA   #zclSE_SimpleMetering_Send_ReqFastPollModeRsp
    885          
    886          #if defined ( LCD_SUPPORTED )
    887              HalLcdWriteString("Fast Polling", HAL_LCD_LINE_1);
   \   00007A   5D43         MOV.B   #0x1, R13
   \   00007C   3C40....     MOV.W   #`?<Constant "Fast Polling">`, R12
   \   000080   ........     CALLA   #HalLcdWriteString
    888              HalLcdWriteStringValue("Cur 0x", utcSecs, 16, HAL_LCD_LINE_2 );
   \   000084   6F43         MOV.B   #0x2, R15
   \   000086   7E401000     MOV.B   #0x10, R14
   \   00008A   0D4A         MOV.W   R10, R13
   \   00008C   3C40....     MOV.W   #`?<Constant "Cur 0x">`, R12
   \   000090   ........     CALLA   #HalLcdWriteStringValue
    889              HalLcdWriteStringValue("End 0x", fastPollRsp.fastPollModeEndTime, 16, HAL_LCD_LINE_3 );
   \   000094   7F400300     MOV.B   #0x3, R15
   \   000098   7E401000     MOV.B   #0x10, R14
   \   00009C   1D410400     MOV.W   0x4(SP), R13
   \   0000A0   3C40....     MOV.W   #`?<Constant "End 0x">`, R12
   \   0000A4   ........     CALLA   #HalLcdWriteStringValue
   \   0000A8   2153         ADD.W   #0x2, SP
    890          #endif
    891            }
    892          #endif // ZCL_SIMPLE_METERING
    893          }
   \                     ??esp_ReqFastPollModeCmdCB_1:
   \   0000AA   31500600     ADD.W   #0x6, SP
   \   0000AE   3817         POPM.W  #0x4, R11
   \   0000B0   1001         RETA
    894          
    895          /*********************************************************************
    896           * @fn      esp_ReqFastPollModeRspCB
    897           *
    898           * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
    899           *          it received a Request Fast Poll Mode Response for
    900           *          this application.
    901           *
    902           * @param   pCmd - pointer to Request Fast Poll Mode response structure
    903           * @param   srcAddr - pointer to source address
    904           * @param   seqNum - sequence number of this command
    905           *
    906           * @return  none
    907           */

   \                                 In  segment CODE, align 2
    908          static void esp_ReqFastPollModeRspCB( zclCCReqFastPollModeRsp_t *pRsp, afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_ReqFastPollModeRspCB:
    909          {
    910            // add user code here
    911          }
   \   000000   1001         RETA
    912          
    913          /*********************************************************************
    914           * @fn      esp_GetCurrentPriceCB
    915           *
    916           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
    917           *          it received a Get Current Price for
    918           *          this application.
    919           *
    920           * @param   pCmd - pointer to structure for Get Current Price command
    921           * @param   srcAddr - source address
    922           * @param   seqNum - sequence number for this command
    923           *
    924           * @return  none
    925           */

   \                                 In  segment CODE, align 2
    926          static void esp_GetCurrentPriceCB( zclCCGetCurrentPrice_t *pCmd,
   \                     esp_GetCurrentPriceCB:
    927                                                   afAddrType_t *srcAddr, uint8 seqNum )
    928          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31803000     SUB.W   #0x30, SP
   \   000006   0B4D         MOV.W   R13, R11
   \   000008   4A4E         MOV.B   R14, R10
    929          #if defined ( ZCL_PRICING )
    930            // On receipt of Get Current Price command, the device shall send a
    931            // Publish Price command with the information for the current time.
    932            zclCCPublishPrice_t cmd;
    933            uint8 rateLabelLen = 4; // adjust this value if different label is set, test label "BASE"
    934          
    935            osal_memset( &cmd, 0, sizeof( zclCCPublishPrice_t ) );
   \   00000A   3E403000     MOV.W   #0x30, R14
   \   00000E   4D43         MOV.B   #0x0, R13
   \   000010   0C41         MOV.W   SP, R12
   \   000012   ........     CALLA   #?Subroutine5
    936          
    937            // Set Pricing information
    938            cmd.providerId = 0xbabeface;
    939            cmd.rateLabel.pStr = (uint8 *)osal_mem_alloc(rateLabelLen);
   \                     ??CrossCallReturnLabel_8:
   \   000016   2C42         MOV.W   #0x4, R12
   \   000018   ........     CALLA   #osal_mem_alloc
   \   00001C   814C0600     MOV.W   R12, 0x6(SP)
    940            if (cmd.rateLabel.pStr != NULL)
   \   000020   0C93         CMP.W   #0x0, R12
   \   000022   0924         JEQ     ??esp_GetCurrentPriceCB_1
    941            {
    942              cmd.rateLabel.strLen = rateLabelLen;
   \   000024   E1420400     MOV.B   #0x4, 0x4(SP)
    943              osal_memcpy(cmd.rateLabel.pStr, "BASE", rateLabelLen);
   \   000028   2E42         MOV.W   #0x4, R14
   \   00002A   3D40....     MOV.W   #`?<Constant "BASE">`, R13
   \   00002E   1C410600     MOV.W   0x6(SP), R12
   \   000032   ........     CALLA   #osal_memcpy
    944            }
    945            cmd.issuerEventId = 0x00000000;
   \                     ??esp_GetCurrentPriceCB_1:
   \   000036   81430800     MOV.W   #0x0, 0x8(SP)
   \   00003A   81430A00     MOV.W   #0x0, 0xa(SP)
    946            cmd.currentTime = osal_getClock();
   \   00003E   ........     CALLA   #osal_getClock
   \   000042   814C0C00     MOV.W   R12, 0xc(SP)
   \   000046   814D0E00     MOV.W   R13, 0xe(SP)
    947            cmd.unitOfMeasure = 0x00;
   \   00004A   C1431000     MOV.B   #0x0, 0x10(SP)
    948            cmd.currency = 0x0348;
   \   00004E   B14048031200 MOV.W   #0x348, 0x12(SP)
    949            cmd.priceTrailingDigit = 0x11;
   \   000054   F14011001400 MOV.B   #0x11, 0x14(SP)
    950            cmd.numberOfPriceTiers = 0x21;
   \   00005A   F14021001500 MOV.B   #0x21, 0x15(SP)
    951            cmd.startTime = 0x00000000;
   \   000060   81431600     MOV.W   #0x0, 0x16(SP)
   \   000064   81431800     MOV.W   #0x0, 0x18(SP)
    952            cmd.durationInMinutes = 0x003C;
   \   000068   B1403C001A00 MOV.W   #0x3c, 0x1a(SP)
    953            cmd.price = 0x00000018;
   \   00006E   B14018001C00 MOV.W   #0x18, 0x1c(SP)
   \   000074   81431E00     MOV.W   #0x0, 0x1e(SP)
    954            cmd.priceRatio = SE_OPTIONAL_FIELD_UINT8;
   \   000078   F1432000     MOV.B   #0xff, 0x20(SP)
    955            cmd.generationPrice = SE_OPTIONAL_FIELD_UINT32;
   \   00007C   B1432200     MOV.W   #0xffff, 0x22(SP)
   \   000080   B1432400     MOV.W   #0xffff, 0x24(SP)
    956            cmd.generationPriceRatio = SE_OPTIONAL_FIELD_UINT8;
   \   000084   F1432600     MOV.B   #0xff, 0x26(SP)
    957            cmd.alternateCostDelivered = SE_OPTIONAL_FIELD_UINT32;
   \   000088   B1432800     MOV.W   #0xffff, 0x28(SP)
   \   00008C   B1432A00     MOV.W   #0xffff, 0x2a(SP)
    958            cmd.alternateCostUnit = SE_OPTIONAL_FIELD_UINT8;
   \   000090   F1432C00     MOV.B   #0xff, 0x2c(SP)
    959            cmd.alternateCostTrailingDigit = SE_OPTIONAL_FIELD_UINT8;
   \   000094   F1432D00     MOV.B   #0xff, 0x2d(SP)
    960            cmd.numberOfBlockThresholds = SE_OPTIONAL_FIELD_UINT8;
   \   000098   F1432E00     MOV.B   #0xff, 0x2e(SP)
    961            cmd.priceControl = SE_PROFILE_PRICEACK_REQUIRED_MASK;
   \   00009C   D1432F00     MOV.B   #0x1, 0x2f(SP)
    962          
    963            // copy source address of display device that requested current pricing info so
    964            // that esp can send messages to it using destination address of IPDAddr
    965            osal_memcpy( &ipdAddr, srcAddr, sizeof ( afAddrType_t ) );
   \   0000A0   3E400C00     MOV.W   #0xc, R14
   \   0000A4   0D4B         MOV.W   R11, R13
   \   0000A6   3C40....     MOV.W   #ipdAddr, R12
   \   0000AA   ........     CALLA   #osal_memcpy
    966          
    967            zclSE_Pricing_Send_PublishPrice( ESP_ENDPOINT, srcAddr, &cmd, FALSE, seqNum );
   \   0000AE   4A12         PUSH.B  R10
   \   0000B0   ........     CALLA   #?Subroutine4
    968          
    969            if (cmd.rateLabel.pStr != NULL)
   \                     ??CrossCallReturnLabel_5:
   \   0000B4   1C410800     MOV.W   0x8(SP), R12
   \   0000B8   2153         ADD.W   #0x2, SP
   \   0000BA   ........     CALLA   #?Subroutine2
    970            {
    971              osal_mem_free(cmd.rateLabel.pStr);
    972            }
    973          #endif // ZCL_PRICING
    974          }
   \                     ??CrossCallReturnLabel_4:
   \   0000BE   31503000     ADD.W   #0x30, SP
   \   0000C2   1A17         POPM.W  #0x2, R11
   \   0000C4   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine5:
   \   000000   ........     CALLA   #osal_memset
   \   000004   B140CEFA0400 MOV.W   #0xface, 0x4(SP)
   \   00000A   B140BEBA0600 MOV.W   #0xbabe, 0x6(SP)
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine4:
   \   000000   4F43         MOV.B   #0x0, R15
   \   000002   0E41         MOV.W   SP, R14
   \   000004   3E500600     ADD.W   #0x6, R14
   \   000008   0D4B         MOV.W   R11, R13
   \   00000A   7C400900     MOV.B   #0x9, R12
   \   00000E   ........     BRA     #zclSE_Pricing_Send_PublishPrice

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   0C93         CMP.W   #0x0, R12
   \   000002   0224         JEQ     ??esp_ProcessZDOMsg_0
   \   000004   ........     CALLA   #osal_mem_free
   \                     ??esp_ProcessZDOMsg_0:
   \   000008   1001         RETA
    975          
    976          /*********************************************************************
    977           * @fn      esp_GetScheduledPriceCB
    978           *
    979           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
    980           *          it received a Get Scheduled Price for
    981           *          this application.
    982           *
    983           * @param   pCmd - pointer to structure for Get Scheduled Price command
    984           * @param   srcAddr - source address
    985           * @param   seqNum - sequence number for this command
    986           *
    987           * @return  none
    988           */

   \                                 In  segment CODE, align 2
    989          static void esp_GetScheduledPriceCB( zclCCGetScheduledPrice_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum  )
   \                     esp_GetScheduledPriceCB:
    990          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31803000     SUB.W   #0x30, SP
   \   000006   0B4D         MOV.W   R13, R11
   \   000008   4A4E         MOV.B   R14, R10
    991            // On receipt of Get Scheduled Price command, the device shall send a
    992            // Publish Price command for all currently scheduled price events.
    993            // The sample code as follows only sends one.
    994          
    995          #if defined ( ZCL_PRICING )
    996            zclCCPublishPrice_t cmd;
    997          
    998            osal_memset( &cmd, 0, sizeof( zclCCPublishPrice_t ) );
   \   00000A   3E403000     MOV.W   #0x30, R14
   \   00000E   4D43         MOV.B   #0x0, R13
   \   000010   0C41         MOV.W   SP, R12
   \   000012   ........     CALLA   #?Subroutine5
    999          
   1000            cmd.providerId = 0xbabeface;
   1001            cmd.numberOfPriceTiers = 0xfe;
   \                     ??CrossCallReturnLabel_7:
   \   000016   F140FE001500 MOV.B   #0xfe, 0x15(SP)
   1002          
   1003            zclSE_Pricing_Send_PublishPrice( ESP_ENDPOINT, srcAddr, &cmd, FALSE, seqNum );
   \   00001C   4A12         PUSH.B  R10
   \   00001E   ........     CALLA   #?Subroutine4
   1004          
   1005          #endif // ZCL_PRICING
   1006          }
   \                     ??CrossCallReturnLabel_6:
   \   000022   31503200     ADD.W   #0x32, SP
   \   000026   1A17         POPM.W  #0x2, R11
   \   000028   1001         RETA
   1007          
   1008          /*********************************************************************
   1009           * @fn      esp_PriceAcknowledgementCB
   1010           *
   1011           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1012           *          it received a Price Acknowledgement for this application.
   1013           *
   1014           * @param   pCmd - pointer to structure for Publish Price command
   1015           * @param   srcAddr - source address
   1016           * @param   seqNum - sequence number for this command
   1017           *
   1018           * @return  none
   1019           */

   \                                 In  segment CODE, align 2
   1020          static void esp_PriceAcknowledgementCB( zclCCPriceAcknowledgement_t *pCmd,
   \                     esp_PriceAcknowledgementCB:
   1021                                                afAddrType_t *srcAddr, uint8 seqNum )
   1022          {
   1023            // add user code here
   1024          }
   \   000000   1001         RETA
   1025          
   1026          /*********************************************************************
   1027           * @fn      esp_GetBlockPeriodCB
   1028           *
   1029           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1030           *          it received a Get Block Period for this application.
   1031           *
   1032           * @param   pCmd - pointer to structure for Get Block Period command
   1033           * @param   srcAddr - source address
   1034           * @param   seqNum - sequence number for this command
   1035           *
   1036           * @return  none
   1037           */

   \                                 In  segment CODE, align 2
   1038          static void esp_GetBlockPeriodCB( zclCCGetBlockPeriod_t *pCmd,
   \                     esp_GetBlockPeriodCB:
   1039                                            afAddrType_t *srcAddr, uint8 seqNum )
   1040          {
   1041            // add user code here
   1042          }
   \   000000   1001         RETA
   1043          
   1044          /*********************************************************************
   1045           * @fn      esp_PublishPriceCB
   1046           *
   1047           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1048           *          it received a Publish Price for this application.
   1049           *
   1050           * @param   pCmd - pointer to structure for Publish Price command
   1051           * @param   srcAddr - source address
   1052           * @param   seqNum - sequence number for this command
   1053           *
   1054           * @return  none
   1055           */

   \                                 In  segment CODE, align 2
   1056          static void esp_PublishPriceCB( zclCCPublishPrice_t *pCmd,
   \                     esp_PublishPriceCB:
   1057                                                afAddrType_t *srcAddr, uint8 seqNum )
   1058          {
   1059            // add user code here
   1060          }
   \   000000   1001         RETA
   1061          
   1062          /*********************************************************************
   1063           * @fn      esp_PublishBlockPeriodCB
   1064           *
   1065           * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
   1066           *          it received a Publish Block Period for this application.
   1067           *
   1068           * @param   pCmd - pointer to structure for Get Block Period command
   1069           * @param   srcAddr - source address
   1070           * @param   seqNum - sequence number for this command
   1071           *
   1072           * @return  none
   1073           */

   \                                 In  segment CODE, align 2
   1074          static void esp_PublishBlockPeriodCB( zclCCPublishBlockPeriod_t *pCmd,
   \                     esp_PublishBlockPeriodCB:
   1075                                                afAddrType_t *srcAddr, uint8 seqNum )
   1076          {
   1077            // add user code here
   1078          }
   \   000000   1001         RETA
   1079          
   1080          /*********************************************************************
   1081           * @fn      esp_DisplayMessageCB
   1082           *
   1083           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1084           *          it received a Display Message Command for
   1085           *          this application.
   1086           *
   1087           * @param   pCmd - pointer to structure for Display Message command
   1088           * @param   srcAddr - source address
   1089           * @param   seqNum - sequence number for this command
   1090           *
   1091           * @return  none
   1092           */

   \                                 In  segment CODE, align 2
   1093          static void esp_DisplayMessageCB( zclCCDisplayMessage_t *pCmd,
   \                     esp_DisplayMessageCB:
   1094                                                  afAddrType_t *srcAddr, uint8 seqNum )
   1095          {
   1096            // Upon receipt of the Display Message Command, the device shall
   1097            // display the message. If the Message Confirmation bit indicates
   1098            // the message originator require a confirmation of receipt from
   1099            // a Utility Customer, the device should display the message or
   1100            // alert the user until it is either confirmed via a button or by
   1101            // selecting a confirmation option on the device.  Confirmation is
   1102            // typically used when the Utility is sending down information
   1103            // such as a disconnection notice, or prepaid billing information.
   1104            // Message duration is ignored when confirmation is requested and
   1105            // the message is displayed until confirmed.
   1106          
   1107          #if defined ( LCD_SUPPORTED )
   1108              HalLcdWriteString( (char*)pCmd->msgString.pStr, HAL_LCD_LINE_1 );
   \   000000   5D43         MOV.B   #0x1, R13
   \   000002   1C4C1000     MOV.W   0x10(R12), R12
   \   000006   ........     BRA     #HalLcdWriteString
   1109          #endif // LCD_SUPPORTED
   1110          }
   1111          
   1112          /*********************************************************************
   1113           * @fn      esp_CancelMessageCB
   1114           *
   1115           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1116           *          it received a Cancel Message Command for
   1117           *          this application.
   1118           *
   1119           * @param   pCmd - pointer to structure for Cancel Message command
   1120           * @param   srcAddr - source address
   1121           * @param   seqNum - sequence number for this command
   1122           *
   1123           * @return  none
   1124           */

   \                                 In  segment CODE, align 2
   1125          static void esp_CancelMessageCB( zclCCCancelMessage_t *pCmd,
   \                     esp_CancelMessageCB:
   1126                                                  afAddrType_t *srcAddr, uint8 seqNum )
   1127          {
   1128            // add user code here
   1129          }
   \   000000   1001         RETA
   1130          
   1131          /*********************************************************************
   1132           * @fn      esp_GetLastMessageCB
   1133           *
   1134           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1135           *          it received a Get Last Message Command for
   1136           *          this application.
   1137           *
   1138           * @param   pCmd - pointer to structure for Get Last Message command
   1139           * @param   srcAddr - source address
   1140           * @param   seqNum - sequence number for this command
   1141           *
   1142           * @return  none
   1143           */

   \                                 In  segment CODE, align 2
   1144          static void esp_GetLastMessageCB( afAddrType_t *srcAddr, uint8 seqNum )
   \                     esp_GetLastMessageCB:
   1145          {
   \   000000   0A12         PUSH.W  R10
   \   000002   31801C00     SUB.W   #0x1c, SP
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   4F4D         MOV.B   R13, R15
   1146            // On receipt of Get Last Message command, the device shall send a
   1147            // Display Message command back to the sender
   1148          
   1149          #if defined ( ZCL_MESSAGE )
   1150            zclCCDisplayMessage_t cmd;
   1151            uint8 msg[10] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29 };
   \   00000A   0C41         MOV.W   SP, R12
   \   00000C   3C501200     ADD.W   #0x12, R12
   \   000010   3E40....     MOV.W   #`?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40`, R14
   \   000014   3D400A00     MOV.W   #0xa, R13
   \   000018   ........     CALLA   #?CopyMemoryBytes
   1152          
   1153            // Fill in the command with information for the last message
   1154            cmd.messageId = 0xaabbccdd;
   \   00001C   B140DDCC0000 MOV.W   #0xccdd, 0(SP)
   \   000022   B140BBAA0200 MOV.W   #0xaabb, 0x2(SP)
   1155            cmd.messageCtrl.transmissionMode = 0;
   \   000028   C1430400     MOV.B   #0x0, 0x4(SP)
   1156            cmd.messageCtrl.importance = 1;
   \   00002C   D1430500     MOV.B   #0x1, 0x5(SP)
   1157            cmd.messageCtrl.confirmationRequired = 1;
   \   000030   D1430600     MOV.B   #0x1, 0x6(SP)
   1158            cmd.durationInMinutes = 60;
   \   000034   B1403C000C00 MOV.W   #0x3c, 0xc(SP)
   1159          
   1160            cmd.msgString.strLen = 10;
   \   00003A   F1400A000E00 MOV.B   #0xa, 0xe(SP)
   1161            cmd.msgString.pStr = msg;
   \   000040   0E41         MOV.W   SP, R14
   \   000042   3E501200     ADD.W   #0x12, R14
   \   000046   814E1000     MOV.W   R14, 0x10(SP)
   1162          
   1163            zclSE_Message_Send_DisplayMessage( ESP_ENDPOINT, srcAddr, &cmd,
   1164                                               FALSE, seqNum );
   \   00004A   4F12         PUSH.B  R15
   \   00004C   4F43         MOV.B   #0x0, R15
   \   00004E   3E50EEFF     ADD.W   #0xffee, R14
   \   000052   0D4A         MOV.W   R10, R13
   \   000054   7C400900     MOV.B   #0x9, R12
   \   000058   ........     CALLA   #zclSE_Message_Send_DisplayMessage
   1165          #endif // ZCL_MESSAGe
   1166          }
   \   00005C   31501E00     ADD.W   #0x1e, SP
   \   000060   3A41         POP.W   R10
   \   000062   1001         RETA
   1167          
   1168          /*********************************************************************
   1169           * @fn      esp_MessageConfirmationCB
   1170           *
   1171           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1172           *          it received a Message Confirmation Command for
   1173           *          this application.
   1174           *
   1175           * @param   pCmd - pointer to structure for Message Confirmation command
   1176           * @param   srcAddr - source address
   1177           * @param   seqNum - sequence number for this command
   1178           *
   1179           * @return  none
   1180           */

   \                                 In  segment CODE, align 2
   1181          static void esp_MessageConfirmationCB( zclCCMessageConfirmation_t *pCmd,
   \                     esp_MessageConfirmationCB:
   1182                                                       afAddrType_t *srcAddr, uint8 seqNum)
   1183          {
   1184            // add user code here
   1185          }
   \   000000   1001         RETA
   1186          
   1187          #if defined (ZCL_LOAD_CONTROL)
   1188          /*********************************************************************
   1189           * @fn      esp_SendReportEventStatus
   1190           *
   1191           * @brief   Callback from the ZCL SE Profile Message Cluster Library when
   1192           *          it received a Load Control Event Command for
   1193           *          this application.
   1194           *
   1195           * @param   afAddrType_t *srcAddr - pointer to source address
   1196           * @param   uint8 seqNum - sequence number for this event
   1197           * @param   uint32 eventID - event ID for this event
   1198           * @param   uint32 startTime - start time for this event
   1199           * @param   uint8 eventStatus - status for this event
   1200           * @param   uint8 criticalityLevel - criticality level for this event
   1201           * @param   uint8 eventControl - event control for this event
   1202           *
   1203           * @return  none
   1204           */

   \                                 In  segment CODE, align 2
   1205          static void esp_SendReportEventStatus( afAddrType_t *srcAddr, uint8 seqNum,
   \                     esp_SendReportEventStatus:
   1206                                                        uint32 eventID, uint32 startTime,
   1207                                                        uint8 eventStatus, uint8 criticalityLevel,
   1208                                                        uint8 eventControl )
   1209          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   094C         MOV.W   R12, R9
   \   000004   484D         MOV.B   R13, R8
   \   000006   0A4E         MOV.W   R14, R10
   \   000008   0B4F         MOV.W   R15, R11
   1210            zclCCReportEventStatus_t *pRsp;
   1211          
   1212            pRsp = (zclCCReportEventStatus_t *)osal_mem_alloc( sizeof( zclCCReportEventStatus_t ) );
   \   00000A   3C403C00     MOV.W   #0x3c, R12
   \   00000E   ........     CALLA   #osal_mem_alloc
   \   000012   064C         MOV.W   R12, R6
   1213          
   1214            if ( pRsp != NULL)
   \   000014   0C93         CMP.W   #0x0, R12
   \   000016   3424         JEQ     ??esp_SendReportEventStatus_0
   1215            {
   1216              // Mandatory fields - use the incoming data
   1217              pRsp->issuerEventID = eventID;
   \   000018   8C4A0000     MOV.W   R10, 0(R12)
   \   00001C   8C4B0200     MOV.W   R11, 0x2(R12)
   1218              pRsp->eventStartTime = startTime;
   \   000020   9C4110000400 MOV.W   0x10(SP), 0x4(R12)
   \   000026   9C4112000600 MOV.W   0x12(SP), 0x6(R12)
   1219              pRsp->criticalityLevelApplied = criticalityLevel;
   \   00002C   DC4116000900 MOV.B   0x16(SP), 0x9(R12)
   1220              pRsp->eventControl = eventControl;
   \   000032   DC4118001000 MOV.B   0x18(SP), 0x10(R12)
   1221              pRsp->eventStatus = eventStatus;
   \   000038   DC4114000800 MOV.B   0x14(SP), 0x8(R12)
   1222              pRsp->signatureType = SE_PROFILE_SIGNATURE_TYPE_ECDSA;
   \   00003E   DC431100     MOV.B   #0x1, 0x11(R12)
   1223          
   1224              // esp_Signature is a static array.
   1225              // value can be changed in esp_data.c
   1226              osal_memcpy( pRsp->signature, espSignature, 16 );
   \   000042   3E401000     MOV.W   #0x10, R14
   \   000046   3D40....     MOV.W   #espSignature, R13
   \   00004A   3C501200     ADD.W   #0x12, R12
   \   00004E   ........     CALLA   #osal_memcpy
   1227          
   1228              // Optional fields - fill in with non-used value by default
   1229              pRsp->coolingTemperatureSetPointApplied = SE_OPTIONAL_FIELD_TEMPERATURE_SET_POINT;
   \   000052   B64000800A00 MOV.W   #0x8000, 0xa(R6)
   1230              pRsp->heatingTemperatureSetPointApplied = SE_OPTIONAL_FIELD_TEMPERATURE_SET_POINT;
   \   000058   B64000800C00 MOV.W   #0x8000, 0xc(R6)
   1231              pRsp->averageLoadAdjustment = SE_OPTIONAL_FIELD_INT8;
   \   00005E   F64080000E00 MOV.B   #0x80, 0xe(R6)
   1232              pRsp->dutyCycleApplied = SE_OPTIONAL_FIELD_UINT8;
   \   000064   F6430F00     MOV.B   #0xff, 0xf(R6)
   1233          
   1234              // Send response back
   1235              // DisableDefaultResponse is set to FALSE - it is recommended to turn on
   1236              // default response since Report Event Status Command does not have
   1237              // a response.
   1238              zclSE_LoadControl_Send_ReportEventStatus( ESP_ENDPOINT, srcAddr,
   1239                                                      pRsp, FALSE, seqNum );
   \   000068   4812         PUSH.B  R8
   \   00006A   4F43         MOV.B   #0x0, R15
   \   00006C   0E46         MOV.W   R6, R14
   \   00006E   0D49         MOV.W   R9, R13
   \   000070   7C400900     MOV.B   #0x9, R12
   \   000074   ........     CALLA   #zclSE_LoadControl_Send_ReportEventStatus
   1240              osal_mem_free( pRsp );
   \   000078   0C46         MOV.W   R6, R12
   \   00007A   ........     CALLA   #osal_mem_free
   \   00007E   2153         ADD.W   #0x2, SP
   1241            }
   1242          }
   \                     ??esp_SendReportEventStatus_0:
   \   000080   5617         POPM.W  #0x6, R11
   \   000082   1001         RETA
   1243          #endif // ZCL_LOAD_CONTROL
   1244          
   1245          /*********************************************************************
   1246           * @fn      esp_LoadControlEventCB
   1247           *
   1248           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1249           *          it received a Load Control Event Command for
   1250           *          this application.
   1251           *
   1252           * @param   pCmd - pointer to load control event command
   1253           * @param   srcAddr - source address
   1254           * @param   status - event status
   1255           * @param   seqNum - sequence number of this command
   1256           *
   1257           * @return  none
   1258           */

   \                                 In  segment CODE, align 2
   1259          static void esp_LoadControlEventCB( zclCCLoadControlEvent_t *pCmd,
   \                     esp_LoadControlEventCB:
   1260                                                         afAddrType_t *srcAddr, uint8 status,
   1261                                                         uint8 seqNum)
   1262          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0C4D         MOV.W   R13, R12
   \   000006   4D4F         MOV.B   R15, R13
   1263          #if defined ( ZCL_LOAD_CONTROL )
   1264            // According to the Smart Metering Specification, upon receipt
   1265            // of the Load Control Event command, the receiving device shall
   1266            // send Report Event Status command back.
   1267            uint8 eventStatus;
   1268          
   1269            if ( status == ZCL_STATUS_INVALID_FIELD )
   \   000008   7E908500     CMP.B   #0x85, R14
   \   00000C   0224         JEQ     ??esp_LoadControlEventCB_0
   \   00000E   5E43         MOV.B   #0x1, R14
   \   000010   023C         JMP     ??esp_LoadControlEventCB_1
   \                     ??esp_LoadControlEventCB_0:
   \   000012   7E40FE00     MOV.B   #0xfe, R14
   1270            {
   1271              // If the incoming message has invalid fields in it
   1272              // Send response back with status: rejected
   1273              eventStatus = EVENT_STATUS_LOAD_CONTROL_EVENT_REJECTED;
   1274            }
   1275            else
   1276            { // Send response back with status: received
   1277              eventStatus = EVENT_STATUS_LOAD_CONTROL_EVENT_RECEIVED;
   1278            }
   1279          
   1280            // Send response back
   1281            esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEvent,
   1282                                             pCmd->startTime, eventStatus,
   1283                                             pCmd->criticalityLevel, pCmd->eventControl);
   \                     ??esp_LoadControlEventCB_1:
   \   000016   5A121800     PUSH.B  0x18(R10)
   \   00001A   5A120E00     PUSH.B  0xe(R10)
   \   00001E   4E12         PUSH.B  R14
   \   000020   1A120A00     PUSH.W  0xa(R10)
   \   000024   1A120800     PUSH.W  0x8(R10)
   \   000028   3E4A         MOV.W   @R10+, R14
   \   00002A   3F4A         MOV.W   @R10+, R15
   \   00002C   ........     CALLA   #esp_SendReportEventStatus
   1284          
   1285            if ( status != ZCL_STATUS_INVALID_FIELD )
   1286            {
   1287              // add user load control event handler here
   1288            }
   1289          #endif // ZCL_LOAD_CONTROL
   1290          }
   \   000030   31500A00     ADD.W   #0xa, SP
   \   000034   3A41         POP.W   R10
   \   000036   1001         RETA
   1291          
   1292          /*********************************************************************
   1293           * @fn      esp_CancelLoadControlEventCB
   1294           *
   1295           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1296           *          it received a Cancel Load Control Event Command for
   1297           *          this application.
   1298           *
   1299           * @param   pCmd - pointer to structure for Cancel Load Control Event command
   1300           * @param   scrAddr - source address
   1301           * @param   seqNum - sequence number for this command
   1302           *
   1303           * @return  none
   1304           */

   \                                 In  segment CODE, align 2
   1305          static void esp_CancelLoadControlEventCB( zclCCCancelLoadControlEvent_t *pCmd,
   \                     esp_CancelLoadControlEventCB:
   1306                                                          afAddrType_t *srcAddr, uint8 seqNum )
   1307          {
   \   000000   0F4C         MOV.W   R12, R15
   \   000002   0C4D         MOV.W   R13, R12
   \   000004   4D4E         MOV.B   R14, R13
   1308          #if defined ( ZCL_LOAD_CONTROL )
   1309            if ( 0 )  // User shall replace the if condition with "if the event exist"
   1310            {
   1311              // If the event exist, stop the event, and respond with status: cancelled
   1312          
   1313              // Cancel the event here
   1314          
   1315              // Use the following sample code to send response back.
   1316              /*
   1317              esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEventID,
   1318                                               // startTime
   1319                                               EVENT_STATUS_LOAD_CONTROL_EVENT_CANCELLED, // eventStatus
   1320                                               // Criticality level
   1321                                               // eventControl };
   1322              */
   1323          
   1324            }
   1325            else
   1326            {
   1327              // If the event does not exist, respond with status: rejected
   1328              // The rest of the mandatory fields are not available, therefore,
   1329              // set to optional value
   1330              esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEventID,
   1331                                               SE_OPTIONAL_FIELD_UINT32,                  // startTime
   1332                                               EVENT_STATUS_LOAD_CONTROL_EVENT_RECEIVED,  // eventStatus
   1333                                               SE_OPTIONAL_FIELD_UINT8,                   // Criticality level
   1334                                               SE_OPTIONAL_FIELD_UINT8 );                 // eventControl
   \   000006   7312         PUSH.B  #0xff
   \   000008   7312         PUSH.B  #0xff
   \   00000A   5312         PUSH.B  #0x1
   \   00000C   3312         PUSH.W  #0xffff
   \   00000E   3312         PUSH.W  #0xffff
   \   000010   3E4F         MOV.W   @R15+, R14
   \   000012   3F4F         MOV.W   @R15+, R15
   \   000014   ........     CALLA   #esp_SendReportEventStatus
   1335            }
   1336          
   1337          #endif // ZCL_LOAD_CONTROL
   1338          }
   \   000018   31500A00     ADD.W   #0xa, SP
   \   00001C   1001         RETA
   1339          
   1340          /*********************************************************************
   1341           * @fn      esp_CancelAllLoadControlEventsCB
   1342           *
   1343           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1344           *          it received a Cancel All Load Control Event Command for
   1345           *          this application.
   1346           *
   1347           * @param   pCmd - pointer to structure for Cancel All Load Control Event command
   1348           * @param   scrAddr - source address
   1349           * @param   seqNum - sequence number for this command
   1350           *
   1351           * @return  none
   1352           */

   \                                 In  segment CODE, align 2
   1353          static void esp_CancelAllLoadControlEventsCB( zclCCCancelAllLoadControlEvents_t *pCmd,
   \                     esp_CancelAllLoadControlEventsCB:
   1354                                                              afAddrType_t *srcAddr, uint8 seqNum )
   1355          {
   1356            // Upon receipt of Cancel All Load Control Event Command,
   1357            // the receiving device shall look up the table for all events
   1358            // and send a seperate response for each event
   1359          
   1360          }
   \   000000   1001         RETA
   1361          
   1362          /*********************************************************************
   1363           * @fn      esp_ReportEventStatusCB
   1364           *
   1365           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1366           *          it received a Report Event Status Command for
   1367           *          this application.
   1368           *
   1369           * @param   pCmd - pointer to structure for Report Event Status command
   1370           * @param   scrAddr - source address
   1371           * @param   seqNum - sequence number for this command
   1372           *
   1373           * @return  none
   1374           */

   \                                 In  segment CODE, align 2
   1375          static void esp_ReportEventStatusCB( zclCCReportEventStatus_t *pCmd,
   \                     esp_ReportEventStatusCB:
   1376                                                     afAddrType_t *srcAddr, uint8 seqNum)
   1377          {
   1378            // add user code here
   1379          }
   \   000000   1001         RETA
   1380          /*********************************************************************
   1381           * @fn      esp_GetScheduledEventCB
   1382           *
   1383           * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
   1384           *          it received a Get Scheduled Event Command for
   1385           *          this application.
   1386           *
   1387           * @param   pCmd - pointer to structure for Get Scheduled Event command
   1388           * @param   scrAddr - source address
   1389           * @param   seqNum - sequence number for this command
   1390           *
   1391           * @return  none
   1392           */

   \                                 In  segment CODE, align 2
   1393          static void esp_GetScheduledEventCB( zclCCGetScheduledEvent_t *pCmd,
   \                     esp_GetScheduledEventCB:
   1394                                                     afAddrType_t *srcAddr, uint8 seqNum )
   1395          {
   1396            // add user code here
   1397          }
   \   000000   1001         RETA
   1398          
   1399          /*********************************************************************
   1400           * @fn      esp_SelAvailEmergencyCreditCmdCB
   1401           *
   1402           * @brief   Callback from the ZCL SE Prepayment Cluster Library when it recieved
   1403           *          Select Available Emergency Credit command in the application
   1404           *
   1405           * @param   pCmd - Pointer to zclCCSelAvailEmergencyCredit_t
   1406           * @param   srcAddr - where the command is generated
   1407           * @param   seqNum - Sequence no of the message
   1408           *
   1409           * @return  none
   1410           */

   \                                 In  segment CODE, align 2
   1411          static void esp_SelAvailEmergencyCreditCmdCB( zclCCSelAvailEmergencyCredit_t *pCmd,
   \                     esp_SelAvailEmergencyCreditCmdCB:
   1412                                                        afAddrType_t *srcAddr, uint8 seqNum )
   1413          {
   1414          #if defined ( ZCL_PREPAYMENT )
   1415          #if defined ( LCD_SUPPORTED )
   1416            HalLcdWriteString("Emergency Credit", HAL_LCD_LINE_1);
   1417          
   1418            if ((pCmd->siteId.strLen > 0) &&
   1419                (pCmd->siteId.strLen <= HAL_LCD_MAX_CHARS) &&
   1420                (pCmd->siteId.pStr != NULL))
   1421            {
   1422              HalLcdWriteString((char*)pCmd->siteId.pStr, HAL_LCD_LINE_2);
   1423            }
   1424          
   1425            if ((pCmd->meterSerialNumber.strLen > 0) &&
   1426                (pCmd->meterSerialNumber.strLen <= HAL_LCD_MAX_CHARS) &&
   1427                (pCmd->meterSerialNumber.pStr != NULL))
   1428            {
   1429              HalLcdWriteString((char*)pCmd->meterSerialNumber.pStr, HAL_LCD_LINE_3);
   1430            }
   1431          #endif
   1432          #endif  // ZCL_PREPAYMENT
   1433          }
   \   000000   1001         RETA
   1434          
   1435          /*********************************************************************
   1436           * @fn      esp_ChangeSupplyCmdCB
   1437           *
   1438           * @brief   Callback from the ZCL SE Prepayment Cluster Library when it recieved
   1439           *          Change Supply command in the application
   1440           *
   1441           * @param   pCmd - Pointer to zclCCChangeSupply_t
   1442           * @param   srcAddr - where the command is generated
   1443           * @param   seqNum - Sequence no of the message
   1444           *
   1445           * @return  none
   1446           */

   \                                 In  segment CODE, align 2
   1447          static void esp_ChangeSupplyCmdCB( zclCCChangeSupply_t *pCmd,
   \                     esp_ChangeSupplyCmdCB:
   1448                                                 afAddrType_t *srcAddr, uint8 seqNum )
   1449          {
   1450          #if defined ( ZCL_PREPAYMENT )
   1451            zclCCSupplyStatusResponse_t SupplyStatus_cmd;
   1452          
   1453            osal_memset( &SupplyStatus_cmd, 0, sizeof( zclCCSupplyStatusResponse_t ) );
   1454          
   1455            SupplyStatus_cmd.providerId = pCmd->providerId;
   1456            SupplyStatus_cmd.implementationDateTime = osal_getClock();
   1457            SupplyStatus_cmd.supplyStatus = pCmd->proposedSupplyStatus;
   1458          
   1459            zclSE_Prepayment_Send_SupplyStatusResponse( ESP_ENDPOINT, srcAddr, &SupplyStatus_cmd,
   1460                                                        FALSE, seqNum );
   1461          #endif  // ZCL_PREPAYMENT
   1462          }
   \   000000   1001         RETA
   1463          
   1464          /*********************************************************************
   1465           * @fn      esp_SupplyStatusRspCB
   1466           *
   1467           * @brief    Callback from the ZCL SE Prepayment Cluster Library when it recieved
   1468           *           Supply Status Response command in the application
   1469           *
   1470           * @param   pCmd - Pointer to zclCCSupplyStatusResponse_t
   1471           * @param   srcAddr - where the command is generated
   1472           * @param   seqNum - Sequence no of the message
   1473           *
   1474           * @return  none
   1475           */

   \                                 In  segment CODE, align 2
   1476          static void esp_SupplyStatusRspCB( zclCCSupplyStatusResponse_t *pCmd,
   \                     esp_SupplyStatusRspCB:
   1477                                                 afAddrType_t *srcAddr, uint8 seqNum )
   1478          {
   1479            // add user code here
   1480          }
   \   000000   1001         RETA
   1481          
   1482          /******************************************************************************
   1483           *
   1484           *  Functions for processing ZDO incoming messages
   1485           *
   1486           *****************************************************************************/
   1487          
   1488          /*********************************************************************
   1489           * @fn      esp_ProcessZDOMsg
   1490           *
   1491           * @brief   Process the incoming ZDO messages.
   1492           *
   1493           * @param   inMsg - message to process
   1494           *
   1495           * @return  none
   1496           */

   \                                 In  segment CODE, align 2
   1497          static void esp_ProcessZDOMsg( zdoIncomingMsg_t *inMsg )
   \                     esp_ProcessZDOMsg:
   1498          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   31800C00     SUB.W   #0xc, SP
   \   000006   0A4C         MOV.W   R12, R10
   1499            ZDO_DeviceAnnce_t devAnnce;
   1500          
   1501            switch ( inMsg->clusterID )
   \   000008   1F4C0E00     MOV.W   0xe(R12), R15
   \   00000C   3F801300     SUB.W   #0x13, R15
   \   000010   0424         JEQ     ??esp_ProcessZDOMsg_2
   \   000012   3F80F17F     SUB.W   #0x7ff1, R15
   \   000016   0E24         JEQ     ??esp_ProcessZDOMsg_3
   \   000018   363C         JMP     ??esp_ProcessZDOMsg_4
   1502            {
   1503              case Device_annce:
   1504                {
   1505                  ZDO_ParseDeviceAnnce( inMsg, &devAnnce );
   \                     ??esp_ProcessZDOMsg_2:
   \   00001A   0D41         MOV.W   SP, R13
   \   00001C   ........     CALLA   #ZDO_ParseDeviceAnnce
   1506                  simpleDescReqAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000020   E243....     MOV.B   #0x2, &simpleDescReqAddr + 8
   1507                  simpleDescReqAddr.addr.shortAddr = devAnnce.nwkAddr;
   \   000024   A241....     MOV.W   @SP, &simpleDescReqAddr
   1508          
   1509                  // set simple descriptor query event
   1510                  osal_set_event( espTaskID, SIMPLE_DESC_QUERY_EVT );
   \   000028   2D42         MOV.W   #0x4, R13
   \   00002A   5C42....     MOV.B   &espTaskID, R12
   \   00002E   ........     CALLA   #osal_set_event
   1511                }
   1512                break;
   \   000032   293C         JMP     ??esp_ProcessZDOMsg_4
   1513          
   1514              case Simple_Desc_rsp:
   1515                {
   1516                  ZDO_SimpleDescRsp_t *pSimpleDescRsp;   // pointer to received simple desc response
   1517                  pSimpleDescRsp = (ZDO_SimpleDescRsp_t *)osal_mem_alloc( sizeof( ZDO_SimpleDescRsp_t ) );
   \                     ??esp_ProcessZDOMsg_3:
   \   000034   3C401200     MOV.W   #0x12, R12
   \   000038   ........     CALLA   #osal_mem_alloc
   \   00003C   0B4C         MOV.W   R12, R11
   1518          
   1519                  if(pSimpleDescRsp)
   \   00003E   0C93         CMP.W   #0x0, R12
   \   000040   2224         JEQ     ??esp_ProcessZDOMsg_4
   1520                  {
   1521                    pSimpleDescRsp->simpleDesc.pAppInClusterList = NULL;
   \   000042   8C430C00     MOV.W   #0x0, 0xc(R12)
   1522                    pSimpleDescRsp->simpleDesc.pAppOutClusterList = NULL;
   \   000046   8C431000     MOV.W   #0x0, 0x10(R12)
   1523          
   1524                    ZDO_ParseSimpleDescRsp( inMsg, pSimpleDescRsp );
   \   00004A   0D4C         MOV.W   R12, R13
   \   00004C   0C4A         MOV.W   R10, R12
   \   00004E   ........     CALLA   #ZDO_ParseSimpleDescRsp
   1525                    if( pSimpleDescRsp->simpleDesc.AppDeviceId == ZCL_SE_DEVICEID_PCT ) // this is a PCT
   \   000052   1F4B0800     MOV.W   0x8(R11), R15
   \   000056   3F900305     CMP.W   #0x503, R15
   \   00005A   0420         JNE     ??esp_ProcessZDOMsg_5
   1526                    {
   1527                      pctAddr.addr.shortAddr = pSimpleDescRsp->nwkAddr;
   \   00005C   924B0200.... MOV.W   0x2(R11), &pctAddr
   \   000062   063C         JMP     ??esp_ProcessZDOMsg_6
   1528                    }
   1529                    else if ( pSimpleDescRsp->simpleDesc.AppDeviceId == ZCL_SE_DEVICEID_LOAD_CTRL_EXTENSION ) // this is a load control device
   \                     ??esp_ProcessZDOMsg_5:
   \   000064   3F900405     CMP.W   #0x504, R15
   \   000068   0320         JNE     ??esp_ProcessZDOMsg_6
   1530                    {
   1531                      loadControlAddr.addr.shortAddr = pSimpleDescRsp->nwkAddr;
   \   00006A   924B0200.... MOV.W   0x2(R11), &loadControlAddr
   1532                    }
   1533          
   1534                    // free memory for InClusterList
   1535                    if (pSimpleDescRsp->simpleDesc.pAppInClusterList)
   \                     ??esp_ProcessZDOMsg_6:
   \   000070   1C4B0C00     MOV.W   0xc(R11), R12
   \   000074   ........     CALLA   #?Subroutine2
   1536                    {
   1537                      osal_mem_free(pSimpleDescRsp->simpleDesc.pAppInClusterList);
   1538                    }
   1539          
   1540                    // free memory for OutClusterList
   1541                    if (pSimpleDescRsp->simpleDesc.pAppOutClusterList)
   \                     ??CrossCallReturnLabel_2:
   \   000078   1C4B1000     MOV.W   0x10(R11), R12
   \   00007C   ........     CALLA   #?Subroutine2
   1542                    {
   1543                      osal_mem_free(pSimpleDescRsp->simpleDesc.pAppOutClusterList);
   1544                    }
   1545          
   1546                    osal_mem_free( pSimpleDescRsp );
   \                     ??CrossCallReturnLabel_3:
   \   000080   0C4B         MOV.W   R11, R12
   \   000082   ........     CALLA   #osal_mem_free
   1547                  }
   1548                }
   1549                break;
   1550            }
   1551          }
   \                     ??esp_ProcessZDOMsg_4:
   \   000086   31500C00     ADD.W   #0xc, SP
   \   00008A   1A17         POPM.W  #0x2, R11
   \   00008C   1001         RETA
   1552          
   1553          
   1554          /******************************************************************************
   1555           *
   1556           *  Functions for processing ZCL Foundation incoming Command/Response messages
   1557           *
   1558           *****************************************************************************/
   1559          
   1560          /*********************************************************************
   1561           * @fn      esp_ProcessZCLMsg
   1562           *
   1563           * @brief   Process ZCL Foundation incoming message
   1564           *
   1565           * @param   pInMsg - message to process
   1566           *
   1567           * @return  none
   1568           */

   \                                 In  segment CODE, align 2
   1569          static void esp_ProcessZCLMsg( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessZCLMsg:
   1570          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   5E4C0700     MOV.B   0x7(R12), R14
   \   000008   5E83         SUB.B   #0x1, R14
   \   00000A   0E24         JEQ     ??esp_ProcessZCLMsg_3
   \   00000C   7E800300     SUB.B   #0x3, R14
   \   000010   1224         JEQ     ??esp_ProcessZCLMsg_4
   \   000012   6E83         SUB.B   #0x2, R14
   \   000014   1724         JEQ     ??esp_ProcessZCLMsg_5
   \   000016   5E83         SUB.B   #0x1, R14
   \   000018   1824         JEQ     ??esp_ProcessZCLMsg_6
   \   00001A   5E83         SUB.B   #0x1, R14
   \   00001C   1924         JEQ     ??esp_ProcessZCLMsg_7
   \   00001E   5E83         SUB.B   #0x1, R14
   \   000020   1A24         JEQ     ??esp_ProcessZCLMsg_8
   \   000022   5E83         SUB.B   #0x1, R14
   \   000024   1F24         JEQ     ??esp_ProcessZCLMsg_9
   \   000026   203C         JMP     ??esp_ProcessZCLMsg_10
   1571            switch ( pInMsg->zclHdr.commandID )
   1572            {
   1573          #if defined ( ZCL_READ )
   1574              case ZCL_CMD_READ_RSP:
   1575                esp_ProcessInReadRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_3:
   \   000028   1F4C1800     MOV.W   0x18(R12), R15
   \   00002C   4E43         MOV.B   #0x0, R14
   \                     ??esp_ProcessZCLMsg_0:
   \   00002E   6E9F         CMP.B   @R15, R14
   \   000030   1B2C         JC      ??esp_ProcessZCLMsg_10
   \   000032   5E53         ADD.B   #0x1, R14
   \   000034   FC3F         JMP     ??esp_ProcessZCLMsg_0
   1576                break;
   1577          #endif // ZCL_READ
   1578          #if defined ( ZCL_WRITE )
   1579              case ZCL_CMD_WRITE_RSP:
   1580                esp_ProcessInWriteRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_4:
   \   000036   1F4C1800     MOV.W   0x18(R12), R15
   \   00003A   4E43         MOV.B   #0x0, R14
   \                     ??esp_ProcessZCLMsg_1:
   \   00003C   6E9F         CMP.B   @R15, R14
   \   00003E   142C         JC      ??esp_ProcessZCLMsg_10
   \   000040   5E53         ADD.B   #0x1, R14
   \   000042   FC3F         JMP     ??esp_ProcessZCLMsg_1
   1581                break;
   1582          #endif // ZCL_WRITE
   1583          #if defined ( ZCL_REPORT )
   1584              case ZCL_CMD_CONFIG_REPORT:
   1585                esp_ProcessInConfigReportCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_5:
   \   000044   ........     CALLA   #esp_ProcessInConfigReportCmd
   1586                break;
   \   000048   0F3C         JMP     ??esp_ProcessZCLMsg_10
   1587          
   1588              case ZCL_CMD_CONFIG_REPORT_RSP:
   1589                esp_ProcessInConfigReportRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_6:
   \   00004A   ........     CALLA   #esp_ProcessInConfigReportRspCmd
   1590                break;
   \   00004E   0C3C         JMP     ??esp_ProcessZCLMsg_10
   1591          
   1592              case ZCL_CMD_READ_REPORT_CFG:
   1593                esp_ProcessInReadReportCfgCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_7:
   \   000050   ........     CALLA   #esp_ProcessInReadReportCfgCmd
   1594                break;
   \   000054   093C         JMP     ??esp_ProcessZCLMsg_10
   1595          
   1596              case ZCL_CMD_READ_REPORT_CFG_RSP:
   1597                esp_ProcessInReadReportCfgRspCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_8:
   \   000056   1F4C1800     MOV.W   0x18(R12), R15
   \   00005A   4E43         MOV.B   #0x0, R14
   \                     ??esp_ProcessZCLMsg_2:
   \   00005C   6E9F         CMP.B   @R15, R14
   \   00005E   042C         JC      ??esp_ProcessZCLMsg_10
   \   000060   5E53         ADD.B   #0x1, R14
   \   000062   FC3F         JMP     ??esp_ProcessZCLMsg_2
   1598                break;
   1599          
   1600              case ZCL_CMD_REPORT:
   1601                esp_ProcessInReportCmd( pInMsg );
   \                     ??esp_ProcessZCLMsg_9:
   \   000064   ........     CALLA   #esp_ProcessInReportCmd
   1602                break;
   1603          #endif // ZCL_REPORT
   1604              case ZCL_CMD_DEFAULT_RSP:
   1605                esp_ProcessInDefaultRspCmd( pInMsg );
   1606                break;
   1607          #if defined ( ZCL_DISCOVER )
   1608              case ZCL_CMD_DISCOVER_RSP:
   1609                esp_ProcessInDiscRspCmd( pInMsg );
   1610                break;
   1611          #endif // ZCL_DISCOVER
   1612              default:
   1613                break;
   1614            }
   1615          
   1616            if ( pInMsg->attrCmd != NULL )
   \                     ??esp_ProcessZCLMsg_10:
   \   000068   1C4A1800     MOV.W   0x18(R10), R12
   \   00006C   0C93         CMP.W   #0x0, R12
   \   00006E   0424         JEQ     ??esp_ProcessZCLMsg_11
   1617            {
   1618              // free the parsed command
   1619              osal_mem_free( pInMsg->attrCmd );
   \   000070   ........     CALLA   #osal_mem_free
   1620              pInMsg->attrCmd = NULL;
   \   000074   8A431800     MOV.W   #0x0, 0x18(R10)
   1621            }
   1622          }
   \                     ??esp_ProcessZCLMsg_11:
   \   000078   3A41         POP.W   R10
   \   00007A   1001         RETA
   1623          
   1624          #if defined ( ZCL_READ )
   1625          /*********************************************************************
   1626           * @fn      esp_ProcessInReadRspCmd
   1627           *
   1628           * @brief   Process the "Profile" Read Response Command
   1629           *
   1630           * @param   pInMsg - incoming message to process
   1631           *
   1632           * @return  none
   1633           */
   1634          static uint8 esp_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg )
   1635          {
   1636            zclReadRspCmd_t *readRspCmd;
   1637            uint8 i;
   1638          
   1639            readRspCmd = (zclReadRspCmd_t *)pInMsg->attrCmd;
   1640            for (i = 0; i < readRspCmd->numAttr; i++)
   1641            {
   1642              // Notify the originator of the results of the original read attributes
   1643              // attempt and, for each successfull request, the value of the requested
   1644              // attribute
   1645            }
   1646          
   1647            return TRUE;
   1648          }
   1649          #endif // ZCL_READ
   1650          
   1651          #if defined ( ZCL_WRITE )
   1652          /*********************************************************************
   1653           * @fn      esp_ProcessInWriteRspCmd
   1654           *
   1655           * @brief   Process the "Profile" Write Response Command
   1656           *
   1657           * @param   pInMsg - incoming message to process
   1658           *
   1659           * @return  none
   1660           */
   1661          static uint8 esp_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg )
   1662          {
   1663            zclWriteRspCmd_t *writeRspCmd;
   1664            uint8 i;
   1665          
   1666            writeRspCmd = (zclWriteRspCmd_t *)pInMsg->attrCmd;
   1667            for (i = 0; i < writeRspCmd->numAttr; i++)
   1668            {
   1669              // Notify the device of the results of the its original write attributes
   1670              // command.
   1671            }
   1672          
   1673            return TRUE;
   1674          }
   1675          #endif // ZCL_WRITE
   1676          
   1677          #if defined ( ZCL_REPORT )
   1678          /*********************************************************************
   1679           * @fn      esp_ProcessInConfigReportCmd
   1680           *
   1681           * @brief   Process the "Profile" Configure Reporting Command
   1682           *
   1683           * @param   pInMsg - incoming message to process
   1684           *
   1685           * @return  TRUE if attribute was found in the Attribute list,
   1686           *          FALSE if not
   1687           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   3152         ADD.W   #0x8, SP
   \   000002   5617         POPM.W  #0x6, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   7C400900     MOV.B   #0x9, R12
   \   000004   ........     BRA     #zclFindAttrRec

   \                                 In  segment CODE, align 2
   1688          static uint8 esp_ProcessInConfigReportCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInConfigReportCmd:
   1689          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   084C         MOV.W   R12, R8
   1690            zclCfgReportCmd_t *cfgReportCmd;
   1691            zclCfgReportRec_t *reportRec;
   1692            zclCfgReportRspCmd_t *cfgReportRspCmd;
   1693            zclAttrRec_t attrRec;
   1694            uint8 status;
   1695            uint8 i, j = 0;
   \   000006   4A43         MOV.B   #0x0, R10
   1696          
   1697            cfgReportCmd = (zclCfgReportCmd_t *)pInMsg->attrCmd;
   \   000008   194C1800     MOV.W   0x18(R12), R9
   1698          
   1699            // Allocate space for the response command
   1700            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof ( zclCfgReportRspCmd_t ) +
   1701                                                  sizeof ( zclCfgReportStatus_t) * cfgReportCmd->numAttr );
   \   00000C   6C49         MOV.B   @R9, R12
   \   00000E   5C06         RLAM.W  #0x2, R12
   \   000010   2C53         ADD.W   #0x2, R12
   \   000012   ........     CALLA   #osal_mem_alloc
   \   000016   064C         MOV.W   R12, R6
   1702            if ( cfgReportRspCmd == NULL )
   \   000018   0C93         CMP.W   #0x0, R12
   \   00001A   0220         JNE     ??esp_ProcessInConfigReportCmd_3
   1703            {
   1704              return FALSE; // EMBEDDED RETURN
   \   00001C   4C43         MOV.B   #0x0, R12
   \   00001E   473C         JMP     ??esp_ProcessInConfigReportCmd_4
   1705            }
   1706          
   1707            // Process each Attribute Reporting Configuration record
   1708            for ( i = 0; i < cfgReportCmd->numAttr; i++ )
   \                     ??esp_ProcessInConfigReportCmd_3:
   \   000020   4B43         MOV.B   #0x0, R11
   \   000022   0D3C         JMP     ??esp_ProcessInConfigReportCmd_5
   1709            {
   1710              reportRec = &(cfgReportCmd->attrList[i]);
   1711          
   1712              status = ZCL_STATUS_SUCCESS;
   1713          
   1714              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId, reportRec->attrID, &attrRec ) )
   1715              {
   1716                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1717                {
   1718                  if ( reportRec->dataType == attrRec.attr.dataType )
   1719                  {
   1720                    // This the attribute that is to be reported
   1721                    if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
   1722                    {
   1723                      if ( reportRec->minReportInt < ESP_MIN_REPORTING_INTERVAL ||
   1724                           ( reportRec->maxReportInt != 0 &&
   1725                             reportRec->maxReportInt < reportRec->minReportInt ) )
   1726                      {
   1727                        // Invalid fields
   1728                        status = ZCL_STATUS_INVALID_VALUE;
   1729                      }
   1730                      else
   1731                      {
   1732                        // Set the Min and Max Reporting Intervals and Reportable Change
   1733                        //status = zclSetAttrReportInterval( pAttr, cfgReportCmd );
   1734                        status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE; // for now
   1735                      }
   1736                    }
   1737                    else
   1738                    {
   1739                      // Attribute cannot be reported
   1740                      status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE;
   1741                    }
   1742                  }
   1743                  else
   1744                  {
   1745                    // Attribute data type is incorrect
   1746                    status = ZCL_STATUS_INVALID_DATA_TYPE;
   1747                  }
   1748                }
   1749                else
   1750                {
   1751                  // We shall expect reports of values of this attribute
   1752                  if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
   1753                  {
   1754                    // Set the Timeout Period
   1755                    //status = zclSetAttrTimeoutPeriod( pAttr, cfgReportCmd );
   1756                    status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE; // for now
   1757                  }
   1758                  else
   1759                  {
   1760                    // Reports of attribute cannot be received
   1761                    status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   1762                  }
   1763                }
   1764              }
   1765              else
   1766              {
   1767                // Attribute is not supported
   1768                status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??esp_ProcessInConfigReportCmd_0:
   \   000024   7E408600     MOV.B   #0x86, R14
   1769              }
   1770          
   1771              // If not successful then record the status
   1772              if ( status != ZCL_STATUS_SUCCESS )
   1773              {
   1774                cfgReportRspCmd->attrList[j].status = status;
   \                     ??esp_ProcessInConfigReportCmd_1:
   \   000028   4D4A         MOV.B   R10, R13
   \   00002A   5D06         RLAM.W  #0x2, R13
   \   00002C   0F46         MOV.W   R6, R15
   \   00002E   0F5D         ADD.W   R13, R15
   \   000030   CF4E0200     MOV.B   R14, 0x2(R15)
   1775                cfgReportRspCmd->attrList[j++].attrID = reportRec->attrID;
   \   000034   9F4702000400 MOV.W   0x2(R7), 0x4(R15)
   \   00003A   5A53         ADD.B   #0x1, R10
   1776              }
   \   00003C   5B53         ADD.B   #0x1, R11
   \                     ??esp_ProcessInConfigReportCmd_5:
   \   00003E   6B99         CMP.B   @R9, R11
   \   000040   192C         JC      ??esp_ProcessInConfigReportCmd_6
   \   000042   0F4B         MOV.W   R11, R15
   \   000044                RPT     #0xd
   \   000044   4C180F5B     ADDX.W  R11, R15
   \   000048   0749         MOV.W   R9, R7
   \   00004A   075F         ADD.W   R15, R7
   \   00004C   2753         ADD.W   #0x2, R7
   \   00004E   0F41         MOV.W   SP, R15
   \   000050   1E470200     MOV.W   0x2(R7), R14
   \   000054   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_1:
   \   000058   E527         JEQ     ??esp_ProcessInConfigReportCmd_0
   \   00005A   C7930000     CMP.B   #0x0, 0(R7)
   \   00005E   E223         JNE     ??esp_ProcessInConfigReportCmd_0
   \   000060   D79104000400 CMP.B   0x4(SP), 0x4(R7)
   \   000066   0324         JEQ     ??esp_ProcessInConfigReportCmd_7
   \   000068   7E408D00     MOV.B   #0x8d, R14
   \   00006C   DD3F         JMP     ??esp_ProcessInConfigReportCmd_1
   \                     ??esp_ProcessInConfigReportCmd_7:
   \   00006E   7E408C00     MOV.B   #0x8c, R14
   \   000072   DA3F         JMP     ??esp_ProcessInConfigReportCmd_1
   1777            } // for loop
   1778          
   1779            if ( j == 0 )
   \                     ??esp_ProcessInConfigReportCmd_6:
   \   000074   4A93         CMP.B   #0x0, R10
   \   000076   0520         JNE     ??esp_ProcessInConfigReportCmd_8
   1780            {
   1781              // Since all attributes were configured successfully, include a single
   1782              // attribute status record in the response command with the status field
   1783              // set to SUCCESS and the attribute ID field omitted.
   1784              cfgReportRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000078   C6430200     MOV.B   #0x0, 0x2(R6)
   1785              cfgReportRspCmd->numAttr = 1;
   \   00007C   D6430000     MOV.B   #0x1, 0(R6)
   \   000080   023C         JMP     ??esp_ProcessInConfigReportCmd_9
   1786            }
   1787            else
   1788            {
   1789              cfgReportRspCmd->numAttr = j;
   \                     ??esp_ProcessInConfigReportCmd_8:
   \   000082   C64A0000     MOV.B   R10, 0(R6)
   1790            }
   1791          
   1792            // Send the response back
   1793            zcl_SendConfigReportRspCmd( ESP_ENDPOINT, &(pInMsg->srcAddr),
   1794                                        pInMsg->clusterId, cfgReportRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   1795                                        TRUE, pInMsg->zclHdr.transSeqNum );
   \                     ??esp_ProcessInConfigReportCmd_9:
   \   000086   58120600     PUSH.B  0x6(R8)
   \   00008A   5312         PUSH.B  #0x1
   \   00008C   5312         PUSH.B  #0x1
   \   00008E   0F46         MOV.W   R6, R15
   \   000090   1E480800     MOV.W   0x8(R8), R14
   \   000094   38500A00     ADD.W   #0xa, R8
   \   000098   0D48         MOV.W   R8, R13
   \   00009A   7C400900     MOV.B   #0x9, R12
   \   00009E   ........     CALLA   #zcl_SendConfigReportRspCmd
   1796            osal_mem_free( cfgReportRspCmd );
   \   0000A2   0C46         MOV.W   R6, R12
   \   0000A4   ........     CALLA   #osal_mem_free
   1797          
   1798            return TRUE ;
   \   0000A8   5C43         MOV.B   #0x1, R12
   \   0000AA   31500600     ADD.W   #0x6, SP
   \                     ??esp_ProcessInConfigReportCmd_4:
   \   0000AE   ....         JMP     ?Subroutine0
   \   0000B0   0343         NOP
   1799          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   1D480800     MOV.W   0x8(R8), R13
   \   000004   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_9:
   \   000008   4C93         CMP.B   #0x0, R12
   \   00000A   1001         RETA
   1800          
   1801          /*********************************************************************
   1802           * @fn      esp_ProcessInConfigReportRspCmd
   1803           *
   1804           * @brief   Process the "Profile" Configure Reporting Response Command
   1805           *
   1806           * @param   pInMsg - incoming message to process
   1807           *
   1808           * @return  none
   1809           */

   \                                 In  segment CODE, align 2, keep-with-next
   1810          static uint8 esp_ProcessInConfigReportRspCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInConfigReportRspCmd:
   1811          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0B4C         MOV.W   R12, R11
   1812            zclCfgReportRspCmd_t *cfgReportRspCmd;
   1813            zclAttrRec_t attrRec;
   1814            uint8 i;
   1815          
   1816            cfgReportRspCmd = (zclCfgReportRspCmd_t *)pInMsg->attrCmd;
   \   000006   184C1800     MOV.W   0x18(R12), R8
   1817            for (i = 0; i < cfgReportRspCmd->numAttr; i++)
   \   00000A   4A43         MOV.B   #0x0, R10
   \   00000C   0C3C         JMP     ??esp_ProcessInConfigReportRspCmd_1
   1818            {
   1819              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
   1820                                   cfgReportRspCmd->attrList[i].attrID, &attrRec ) )
   \                     ??esp_ProcessInConfigReportRspCmd_0:
   \   00000E   0F41         MOV.W   SP, R15
   \   000010   4E4A         MOV.B   R10, R14
   \   000012   5E06         RLAM.W  #0x2, R14
   \   000014   0D48         MOV.W   R8, R13
   \   000016   0D5E         ADD.W   R14, R13
   \   000018   1E4D0400     MOV.W   0x4(R13), R14
   \   00001C   1D4B0800     MOV.W   0x8(R11), R13
   \   000020   ........     CALLA   #?Subroutine6
   1821              {
   1822                // Notify the device of success (or otherwise) of the its original configure
   1823                // reporting command, for each attribute.
   1824              }
   1825            }
   \                     ??CrossCallReturnLabel_10:
   \   000024   5A53         ADD.B   #0x1, R10
   \                     ??esp_ProcessInConfigReportRspCmd_1:
   \   000026   6A98         CMP.B   @R8, R10
   \   000028   F22B         JNC     ??esp_ProcessInConfigReportRspCmd_0
   1826          
   1827            return TRUE;
   \   00002A   5C43         MOV.B   #0x1, R12
   \   00002C   3152         ADD.W   #0x8, SP
   \   00002E   3817         POPM.W  #0x4, R11
   \   000030   1001         RETA
   1828          }
   1829          
   1830          /*********************************************************************
   1831           * @fn      esp_ProcessInReadReportCfgCmd
   1832           *
   1833           * @brief   Process the "Profile" Read Reporting Configuration Command
   1834           *
   1835           * @param   pInMsg - incoming message to process
   1836           *
   1837           * @return  none
   1838           */

   \                                 In  segment CODE, align 2, keep-with-next
   1839          static uint8 esp_ProcessInReadReportCfgCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInReadReportCfgCmd:
   1840          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   084C         MOV.W   R12, R8
   1841            zclReadReportCfgCmd_t *readReportCfgCmd;
   1842            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   1843            zclReportCfgRspRec_t *reportRspRec;
   1844            zclAttrRec_t attrRec;
   1845            uint8 reportChangeLen;
   1846            uint8 *dataPtr;
   1847            uint8 hdrLen;
   1848            uint8 dataLen = 0;
   \   000006   4B43         MOV.B   #0x0, R11
   1849            uint8 status;
   1850            uint8 i;
   1851          
   1852            readReportCfgCmd = (zclReadReportCfgCmd_t *)pInMsg->attrCmd;
   \   000008   194C1800     MOV.W   0x18(R12), R9
   1853          
   1854            // Find out the response length (Reportable Change field is of variable length)
   1855            for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   00000C   4A43         MOV.B   #0x0, R10
   \   00000E   193C         JMP     ??esp_ProcessInReadReportCfgCmd_2
   1856            {
   1857              // For supported attributes with 'analog' data type, find out the length of
   1858              // the Reportable Change field
   1859              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
   1860                                   readReportCfgCmd->attrList[i].attrID, &attrRec ) )
   \                     ??esp_ProcessInReadReportCfgCmd_0:
   \   000010   0F41         MOV.W   SP, R15
   \   000012   474A         MOV.B   R10, R7
   \   000014   5706         RLAM.W  #0x2, R7
   \   000016   0E49         MOV.W   R9, R14
   \   000018   0E57         ADD.W   R7, R14
   \   00001A   1E4E0400     MOV.W   0x4(R14), R14
   \   00001E   ........     CALLA   #?Subroutine1
   \                     ??CrossCallReturnLabel_0:
   \   000022   0E24         JEQ     ??esp_ProcessInReadReportCfgCmd_3
   1861              {
   1862                if ( zclAnalogDataType( attrRec.attr.dataType ) )
   \   000024   5C410400     MOV.B   0x4(SP), R12
   \   000028   ........     CALLA   #zclAnalogDataType
   \   00002C   4C93         CMP.B   #0x0, R12
   \   00002E   0824         JEQ     ??esp_ProcessInReadReportCfgCmd_3
   1863                {
   1864                   reportChangeLen = zclGetDataTypeLength( attrRec.attr.dataType );
   \   000030   5C410400     MOV.B   0x4(SP), R12
   \   000034   ........     CALLA   #zclGetDataTypeLength
   1865          
   1866                   // add padding if neede
   1867                   if ( PADDING_NEEDED( reportChangeLen ) )
   \   000038   5CB3         BIT.B   #0x1, R12
   \   00003A   0128         JNC     ??esp_ProcessInReadReportCfgCmd_4
   1868                   {
   1869                     reportChangeLen++;
   \   00003C   5C53         ADD.B   #0x1, R12
   1870                   }
   1871                   dataLen += reportChangeLen;
   \                     ??esp_ProcessInReadReportCfgCmd_4:
   \   00003E   4B5C         ADD.B   R12, R11
   1872                }
   1873              }
   1874            }
   \                     ??esp_ProcessInReadReportCfgCmd_3:
   \   000040   5A53         ADD.B   #0x1, R10
   \                     ??esp_ProcessInReadReportCfgCmd_2:
   \   000042   6E49         MOV.B   @R9, R14
   \   000044   4A9E         CMP.B   R14, R10
   \   000046   E42B         JNC     ??esp_ProcessInReadReportCfgCmd_0
   1875          
   1876            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( readReportCfgCmd->numAttr * sizeof( zclReportCfgRspRec_t ) );
   1877          
   1878            // Allocate space for the response command
   1879            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   000048   6C43         MOV.B   #0x2, R12
   \   00004A                RPT     #0xe
   \   00004A   4D184C5E     ADDX.B  R14, R12
   \   00004E   4C4C         MOV.B   R12, R12
   \   000050   0C5B         ADD.W   R11, R12
   \   000052   ........     CALLA   #osal_mem_alloc
   \   000056   0B4C         MOV.W   R12, R11
   1880            if ( readReportCfgRspCmd == NULL )
   \   000058   0C93         CMP.W   #0x0, R12
   \   00005A   0220         JNE     ??esp_ProcessInReadReportCfgCmd_5
   1881            {
   1882              return FALSE; // EMBEDDED RETURN
   \   00005C   4C43         MOV.B   #0x0, R12
   \   00005E   363C         JMP     ??esp_ProcessInReadReportCfgCmd_6
   1883            }
   1884          
   1885            dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   1886            readReportCfgRspCmd->numAttr = readReportCfgCmd->numAttr;
   \                     ??esp_ProcessInReadReportCfgCmd_5:
   \   000060   EC490000     MOV.B   @R9, 0(R12)
   1887            for (i = 0; i < readReportCfgCmd->numAttr; i++)
   \   000064   4A43         MOV.B   #0x0, R10
   \   000066   1B3C         JMP     ??esp_ProcessInReadReportCfgCmd_7
   1888            {
   1889              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   \                     ??esp_ProcessInReadReportCfgCmd_1:
   \   000068   4F4A         MOV.B   R10, R15
   \   00006A   074F         MOV.W   R15, R7
   \   00006C                RPT     #0xd
   \   00006C   4C18075F     ADDX.W  R15, R7
   \   000070   064B         MOV.W   R11, R6
   \   000072   0657         ADD.W   R7, R6
   \   000074   2653         ADD.W   #0x2, R6
   1890          
   1891              if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
   1892                                   readReportCfgCmd->attrList[i].attrID, &attrRec ) )
   \   000076   5F06         RLAM.W  #0x2, R15
   \   000078   0749         MOV.W   R9, R7
   \   00007A   075F         ADD.W   R15, R7
   \   00007C   2752         ADD.W   #0x4, R7
   \   00007E   0F41         MOV.W   SP, R15
   \   000080   2E47         MOV.W   @R7, R14
   \   000082   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_11:
   \   000086   4C93         CMP.B   #0x0, R12
   \   000088   0320         JNE     ??esp_ProcessInReadReportCfgCmd_8
   \   00008A   7E408600     MOV.B   #0x86, R14
   \   00008E   023C         JMP     ??esp_ProcessInReadReportCfgCmd_9
   \                     ??esp_ProcessInReadReportCfgCmd_8:
   \   000090   7E408C00     MOV.B   #0x8c, R14
   1893              {
   1894                if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
   1895                {
   1896                  // Get the Reporting Configuration
   1897                  // status = zclReadReportCfg( readReportCfgCmd->attrID[i], reportRspRec );
   1898                  status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE; // for now
   1899                  if ( status == ZCL_STATUS_SUCCESS && zclAnalogDataType( attrRec.attr.dataType ) )
   1900                  {
   1901                    reportChangeLen = zclGetDataTypeLength( attrRec.attr.dataType );
   1902                    //osal_memcpy( dataPtr, pBuf, reportChangeLen );
   1903                    reportRspRec->reportableChange = dataPtr;
   1904          
   1905                    // add padding if needed
   1906                    if ( PADDING_NEEDED( reportChangeLen ) )
   1907                    {
   1908                      reportChangeLen++;
   1909                    }
   1910                    dataPtr += reportChangeLen;
   1911                  }
   1912                }
   1913                else
   1914                {
   1915                  // Attribute not in the Mandatory Reportable Attribute list
   1916                  status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE;
   1917                }
   1918              }
   1919              else
   1920              {
   1921                // Attribute not found
   1922                status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   1923              }
   1924          
   1925              reportRspRec->status = status;
   \                     ??esp_ProcessInReadReportCfgCmd_9:
   \   000094   C64E0000     MOV.B   R14, 0(R6)
   1926              reportRspRec->attrID = readReportCfgCmd->attrList[i].attrID;
   \   000098   A6470200     MOV.W   @R7, 0x2(R6)
   1927            }
   \   00009C   5A53         ADD.B   #0x1, R10
   \                     ??esp_ProcessInReadReportCfgCmd_7:
   \   00009E   1D480800     MOV.W   0x8(R8), R13
   \   0000A2   6A99         CMP.B   @R9, R10
   \   0000A4   E12B         JNC     ??esp_ProcessInReadReportCfgCmd_1
   1928          
   1929            // Send the response back
   1930            zcl_SendReadReportCfgRspCmd( ESP_ENDPOINT, &(pInMsg->srcAddr),
   1931                                         pInMsg->clusterId, readReportCfgRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   1932                                         TRUE, pInMsg->zclHdr.transSeqNum );
   \   0000A6   58120600     PUSH.B  0x6(R8)
   \   0000AA   5312         PUSH.B  #0x1
   \   0000AC   5312         PUSH.B  #0x1
   \   0000AE   0F4B         MOV.W   R11, R15
   \   0000B0   0E4D         MOV.W   R13, R14
   \   0000B2   38500A00     ADD.W   #0xa, R8
   \   0000B6   0D48         MOV.W   R8, R13
   \   0000B8   7C400900     MOV.B   #0x9, R12
   \   0000BC   ........     CALLA   #zcl_SendReadReportCfgRspCmd
   1933            osal_mem_free( readReportCfgRspCmd );
   \   0000C0   0C4B         MOV.W   R11, R12
   \   0000C2   ........     CALLA   #osal_mem_free
   1934          
   1935            return TRUE;
   \   0000C6   5C43         MOV.B   #0x1, R12
   \   0000C8   31500600     ADD.W   #0x6, SP
   \                     ??esp_ProcessInReadReportCfgCmd_6:
   \   0000CC                REQUIRE ?Subroutine0
   \   0000CC                // Fall through to label ?Subroutine0
   1936          }
   1937          
   1938          /*********************************************************************
   1939           * @fn      esp_ProcessInReadReportCfgRspCmd
   1940           *
   1941           * @brief   Process the "Profile" Read Reporting Configuration Response Command
   1942           *
   1943           * @param   pInMsg - incoming message to process
   1944           *
   1945           * @return  none
   1946           */
   1947          static uint8 esp_ProcessInReadReportCfgRspCmd( zclIncomingMsg_t *pInMsg )
   1948          {
   1949            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   1950            zclReportCfgRspRec_t *reportRspRec;
   1951            uint8 i;
   1952          
   1953            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)pInMsg->attrCmd;
   1954            for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   1955            {
   1956              reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1957          
   1958              // Notify the device of the results of the its original read reporting
   1959              // configuration command.
   1960          
   1961              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1962              {
   1963                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1964                {
   1965                  // add user code here
   1966                }
   1967                else
   1968                {
   1969                  // expecting attribute reports
   1970                }
   1971              }
   1972            }
   1973          
   1974            return TRUE;
   1975          }
   1976          
   1977          /*********************************************************************
   1978           * @fn      esp_ProcessInReportCmd
   1979           *
   1980           * @brief   Process the "Profile" Report Command
   1981           *
   1982           * @param   pInMsg - incoming message to process
   1983           *
   1984           * @return  none
   1985           */

   \                                 In  segment CODE, align 2
   1986          static uint8 esp_ProcessInReportCmd( zclIncomingMsg_t *pInMsg )
   \                     esp_ProcessInReportCmd:
   1987          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31800E00     SUB.W   #0xe, SP
   1988            zclReportCmd_t *reportCmd;
   1989            zclReport_t *reportRec;
   1990            uint8 i,j;
   1991            uint8 * meterData;
   1992            uint8 * meterData1;
   1993            uint8 * meterData2;
   1994           
   1995            char lcdBuf[13];
   1996          
   1997            reportCmd = (zclReportCmd_t *)pInMsg->attrCmd;
   \   000006   184C1800     MOV.W   0x18(R12), R8
   1998            
   1999            for (j = 0; j < reportCmd->numAttr; j++)
   \   00000A   4943         MOV.B   #0x0, R9
   \   00000C   193C         JMP     ??esp_ProcessInReportCmd_3
   2000            {
   2001              // Device is notified of the latest values of the attribute of another device.
   2002                reportRec = &(reportCmd->attrList[j]);
   2003              
   2004              if ( reportRec->attrID == ATTRID_SE_POWER_FACTOR ) 
   2005             {
   2006               meterData1 = reportRec->attrData;
   2007               //  uint8 buf[25];
   2008          
   2009             // _itoa( meterData, &buf[0], 10 );
   2010               HalLcdWriteString((char*)meterData1, HAL_LCD_LINE_4);
   2011             }
   2012             
   2013                 if ( reportRec->attrID == ATTRID_SE_CURRENT_SUMMATION_RECEIVED ) 
   2014             {
   2015               meterData2 = reportRec->attrData;
   2016               //  uint8 buf[25];
   2017          
   2018             // _itoa( meterData, &buf[0], 10 );
   2019               HalLcdWriteString((char*)meterData2, HAL_LCD_LINE_5);
   2020             }
   2021          
   2022              if ( reportRec->attrID == ATTRID_SE_CURRENT_SUMMATION_DELIVERED )
   2023              {
   2024                // process simple metering current summation delivered attribute
   2025                meterData = reportRec->attrData;
   2026          
   2027                // process to convert hex to ascii
   2028                for(i=0; i<6; i++)
   2029                {
   2030                  if(meterData[5-i] == 0)
   2031                  {
   2032                    lcdBuf[i*2] = '0';
   2033                    lcdBuf[i*2+1] = '0';
   2034                  }
   2035                  else if(meterData[5-i] <= 0x0A)
   2036                  {
   2037                    lcdBuf[i*2] = '0';
   2038                    _ltoa(meterData[5-i],(uint8*)&lcdBuf[i*2+1],16);
   2039                  }
   2040                  else
   2041                  {
   2042                    _ltoa(meterData[5-i],(uint8*)&lcdBuf[i*2],16);
   \                     ??esp_ProcessInReportCmd_2:
   \   00000E   7F401000     MOV.B   #0x10, R15
   \                     ??esp_ProcessInReportCmd_9:
   \   000012   0D43         MOV.W   #0x0, R13
   \   000014   ........     CALLA   #_ltoa
   2043                  }
   \                     ??esp_ProcessInReportCmd_1:
   \   000018   5B53         ADD.B   #0x1, R11
   \   00001A   7B900600     CMP.B   #0x6, R11
   \   00001E   3028         JNC     ??esp_ProcessInReportCmd_4
   2044                }
   2045          
   2046                // print out value of current summation delivered in hex
   2047                HalLcdWriteString("Zigbee Coord esp", HAL_LCD_LINE_1);
   \   000020   5D43         MOV.B   #0x1, R13
   \   000022   3C40....     MOV.W   #`?<Constant "Zigbee Coord esp">`, R12
   \   000026   ........     CALLA   #HalLcdWriteString
   2048                HalLcdWriteString("Curr Summ Dlvd", HAL_LCD_LINE_2);
   \   00002A   6D43         MOV.B   #0x2, R13
   \   00002C   3C40....     MOV.W   #`?<Constant "Curr Summ Dlvd">`, R12
   \   000030   ........     CALLA   #HalLcdWriteString
   2049                HalLcdWriteString(lcdBuf, HAL_LCD_LINE_3);
   \   000034   7D400300     MOV.B   #0x3, R13
   \   000038   0C41         MOV.W   SP, R12
   \   00003A   ........     CALLA   #HalLcdWriteString
   \                     ??esp_ProcessInReportCmd_0:
   \   00003E   5953         ADD.B   #0x1, R9
   \                     ??esp_ProcessInReportCmd_3:
   \   000040   6998         CMP.B   @R8, R9
   \   000042   3B2C         JC      ??esp_ProcessInReportCmd_5
   \   000044   0F49         MOV.W   R9, R15
   \   000046                RPT     #0x5
   \   000046   44180F59     ADDX.W  R9, R15
   \   00004A   0B48         MOV.W   R8, R11
   \   00004C   0B5F         ADD.W   R15, R11
   \   00004E   2B53         ADD.W   #0x2, R11
   \   000050   BB9006000000 CMP.W   #0x6, 0(R11)
   \   000056   0520         JNE     ??esp_ProcessInReportCmd_6
   \   000058   6D42         MOV.B   #0x4, R13
   \   00005A   1C4B0400     MOV.W   0x4(R11), R12
   \   00005E   ........     CALLA   #HalLcdWriteString
   \                     ??esp_ProcessInReportCmd_6:
   \   000062   9B930000     CMP.W   #0x1, 0(R11)
   \   000066   0620         JNE     ??esp_ProcessInReportCmd_7
   \   000068   7D400500     MOV.B   #0x5, R13
   \   00006C   1C4B0400     MOV.W   0x4(R11), R12
   \   000070   ........     CALLA   #HalLcdWriteString
   \                     ??esp_ProcessInReportCmd_7:
   \   000074   8B930000     CMP.W   #0x0, 0(R11)
   \   000078   E223         JNE     ??esp_ProcessInReportCmd_0
   \   00007A   1A4B0400     MOV.W   0x4(R11), R10
   \   00007E   4B43         MOV.B   #0x0, R11
   \                     ??esp_ProcessInReportCmd_4:
   \   000080   4F4B         MOV.B   R11, R15
   \   000082   0D4A         MOV.W   R10, R13
   \   000084   0D8F         SUB.W   R15, R13
   \   000086   5C4D0500     MOV.B   0x5(R13), R12
   \   00008A   0E41         MOV.W   SP, R14
   \   00008C   0F5F         RLA.W   R15
   \   00008E   0E5F         ADD.W   R15, R14
   \   000090   4C93         CMP.B   #0x0, R12
   \   000092   0720         JNE     ??esp_ProcessInReportCmd_8
   \   000094   FE4030000000 MOV.B   #0x30, 0(R14)
   \   00009A   FE4030000100 MOV.B   #0x30, 0x1(R14)
   \   0000A0   BB3F         JMP     ??esp_ProcessInReportCmd_1
   \                     ??esp_ProcessInReportCmd_8:
   \   0000A2   7C900B00     CMP.B   #0xb, R12
   \   0000A6   B32F         JC      ??esp_ProcessInReportCmd_2
   \   0000A8   FE4030000000 MOV.B   #0x30, 0(R14)
   \   0000AE   7F401000     MOV.B   #0x10, R15
   \   0000B2   1E53         ADD.W   #0x1, R14
   \   0000B4   5C4D0500     MOV.B   0x5(R13), R12
   \   0000B8   AC3F         JMP     ??esp_ProcessInReportCmd_9
   2050              }
   2051             
   2052            
   2053            }
   2054            return TRUE;
   \                     ??esp_ProcessInReportCmd_5:
   \   0000BA   5C43         MOV.B   #0x1, R12
   \   0000BC   31500E00     ADD.W   #0xe, SP
   \   0000C0   3817         POPM.W  #0x4, R11
   \   0000C2   1001         RETA
   2055          }

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for espEp>`:
   \   000000   0900         DC8 9, 0
   \   000002   ........     DC16 espTaskID, espSimpleDesc
   \   000006   0000         DC8 0, 0

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for esp_GenCmdCallbacks>`:
   \   000000   ............ DC32 esp_BasicResetCB, esp_IdentifyCB, esp_IdentifyQueryRspCB, 0H, 0H
   \            ............
   \            000000000000
   \            0000        
   \   000014   000000000000 DC32 0H, 0H, 0H, 0H, 0H, 0H, 0H, esp_AlarmCB, 0H, 0H
   \            000000000000
   \            000000000000
   \            000000000000
   \            00000000....
   \            ....00000000
   \            00000000    

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for esp_SECmdCallbacks>`:
   \   000000   ............ DC32 esp_GetProfileCmdCB, esp_GetProfileRspCB, esp_ReqMirrorCmdCB
   \            ............
   \   00000C   ............ DC32 esp_ReqMirrorRspCB, esp_MirrorRemCmdCB, esp_MirrorRemRspCB
   \            ............
   \   000018   ............ DC32 esp_GetCurrentPriceCB, esp_GetScheduledPriceCB, esp_PublishPriceCB
   \            ............
   \   000024   ............ DC32 esp_DisplayMessageCB, esp_CancelMessageCB, esp_GetLastMessageCB
   \            ............
   \   000030   ............ DC32 esp_MessageConfirmationCB, esp_LoadControlEventCB
   \            ....        
   \   000038   ............ DC32 esp_CancelLoadControlEventCB, esp_CancelAllLoadControlEventsCB
   \            ....        
   \   000040   ............ DC32 esp_ReportEventStatusCB, esp_GetScheduledEventCB
   \            ....        
   \   000048   ............ DC32 esp_ReqFastPollModeCmdCB, esp_ReqFastPollModeRspCB
   \            ....        
   \   000050   ............ DC32 esp_PriceAcknowledgementCB, esp_GetBlockPeriodCB
   \            ....        
   \   000058   ............ DC32 esp_PublishBlockPeriodCB, esp_SelAvailEmergencyCreditCmdCB
   \            ....        
   \   000060   ............ DC32 esp_ChangeSupplyCmdCB, esp_SupplyStatusRspCB
   \            ....        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "TI IPD Test Msg!">`:
   \   000000   544920495044 DC8 "TI IPD Test Msg!"
   \            205465737420
   \            4D73672100  

   \                                 In  segment DATA16_C, align 2, align-sorted
   \                     `?<Constant {10485761L, 10485762L, 10485763L, 1`:
   \   000000   0100A0000200 DC32 10485761, 10485762, 10485763, 10485764, 10485765
   \            A0000300A000
   \            0400A0000500
   \            A000        

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Fast Polling">`:
   \   000000   466173742050 DC8 "Fast Polling"
   \            6F6C6C696E67
   \            00          

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Cur 0x">`:
   \   000000   437572203078 DC8 "Cur 0x"
   \            00          

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "End 0x">`:
   \   000000   456E64203078 DC8 "End 0x"
   \            00          

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "BASE">`:
   \   000000   4241534500   DC8 "BASE"

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40`:
   \   000000   202122232425 DC8 32, 33, 34, 35, 36, 37, 38, 39, 40, 41
   \            26272829    

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Zigbee Coord esp">`:
   \   000000   5A6967626565 DC8 "Zigbee Coord esp"
   \            20436F6F7264
   \            2065737000  

   \                                 In  segment DATA16_C, align 1, align-sorted
   \                     `?<Constant "Curr Summ Dlvd">`:
   \   000000   437572722053 DC8 "Curr Summ Dlvd"
   \            756D6D20446C
   \            766400      
   2056          #endif // ZCL_REPORT
   2057          
   2058          /*********************************************************************
   2059           * @fn      esp_ProcessInDefaultRspCmd
   2060           *
   2061           * @brief   Process the "Profile" Default Response Command
   2062           *
   2063           * @param   pInMsg - incoming message to process
   2064           *
   2065           * @return  none
   2066           */
   2067          static uint8 esp_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg )
   2068          {
   2069            // zclDefaultRspCmd_t *defaultRspCmd = (zclDefaultRspCmd_t *)pInMsg->attrCmd;
   2070          
   2071            // Device is notified of the Default Response command.
   2072          
   2073            return TRUE;
   2074          }
   2075          
   2076          #if defined ( ZCL_DISCOVER )
   2077          /*********************************************************************
   2078           * @fn      esp_ProcessInDiscRspCmd
   2079           *
   2080           * @brief   Process the "Profile" Discover Response Command
   2081           *
   2082           * @param   pInMsg - incoming message to process
   2083           *
   2084           * @return  none
   2085           */
   2086          static uint8 esp_ProcessInDiscRspCmd( zclIncomingMsg_t *pInMsg )
   2087          {
   2088            zclDiscoverRspCmd_t *discoverRspCmd;
   2089            uint8 i;
   2090          
   2091            discoverRspCmd = (zclDiscoverRspCmd_t *)pInMsg->attrCmd;
   2092            for ( i = 0; i < discoverRspCmd->numAttr; i++ )
   2093            {
   2094              // Device is notified of the result of its attribute discovery command.
   2095            }
   2096          
   2097            return TRUE;
   2098          }
   2099          #endif // ZCL_DISCOVER
   2100          
   2101          /****************************************************************************
   2102          ****************************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       4  esp_AlarmCB
       4  esp_BasicResetCB
       4  esp_CancelAllLoadControlEventsCB
      14  esp_CancelLoadControlEventCB
            14 -> esp_SendReportEventStatus
       4  esp_CancelMessageCB
       4  esp_ChangeSupplyCmdCB
       4  esp_DisplayMessageCB
             4 -> HalLcdWriteString
       4  esp_GetBlockPeriodCB
      58  esp_GetCurrentPriceCB
            56 -> osal_getClock
            56 -> osal_mem_alloc
            56 -> osal_mem_free
            56 -> osal_memcpy
            56 -> osal_memset
            58 -> zclSE_Pricing_Send_PublishPrice
      36  esp_GetLastMessageCB
            36 -> zclSE_Message_Send_DisplayMessage
      40  esp_GetProfileCmdCB
            40 -> zclSE_SimpleMetering_Send_GetProfileRsp
       4  esp_GetProfileRspCB
       4  esp_GetScheduledEventCB
      58  esp_GetScheduledPriceCB
            56 -> osal_memset
            58 -> zclSE_Pricing_Send_PublishPrice
      44  esp_HandleKeys
            44 -> zclSE_LoadControl_Send_LoadControlEvent
            44 -> zclSE_Message_Send_DisplayMessage
       4  esp_IdentifyCB
             4 -> esp_ProcessIdentifyTimeChange
       4  esp_IdentifyQueryRspCB
       8  esp_Init
             8 -> RegisterForKeys
             8 -> StubAPS_RegisterApp
             8 -> ZDO_RegisterForZDOMsg
             8 -> osal_start_timerEx
             8 -> zclGeneral_RegisterCmdCallbacks
             8 -> zclSE_Init
             8 -> zclSE_RegisterCmdCallbacks
             8 -> zcl_registerAttrList
             8 -> zcl_registerClusterOptionList
             8 -> zcl_registerForMsg
             8 -> zcl_registerValidateAttrData
      16  esp_LoadControlEventCB
            16 -> esp_SendReportEventStatus
       4  esp_MessageConfirmationCB
       4  esp_MirrorRemCmdCB
       4  esp_MirrorRemRspCB
       4  esp_PriceAcknowledgementCB
       4  esp_ProcessIdentifyTimeChange
             4 -> HalLedBlink
             4 -> HalLedSet
             4 -> osal_start_timerEx
             4 -> osal_stop_timerEx
      30  esp_ProcessInConfigReportCmd
            24 -> osal_mem_alloc
            30 -> osal_mem_free
            24 -> zclFindAttrRec
            30 -> zcl_SendConfigReportRspCmd
      20  esp_ProcessInConfigReportRspCmd
            20 -> zclFindAttrRec
      30  esp_ProcessInReadReportCfgCmd
            24 -> osal_mem_alloc
            30 -> osal_mem_free
            24 -> zclAnalogDataType
            24 -> zclFindAttrRec
            24 -> zclGetDataTypeLength
            30 -> zcl_SendReadReportCfgRspCmd
      26  esp_ProcessInReportCmd
            26 -> HalLcdWriteString
            26 -> _ltoa
       6  esp_ProcessZCLMsg
             6 -> esp_ProcessInConfigReportCmd
             6 -> esp_ProcessInConfigReportRspCmd
             6 -> esp_ProcessInReadReportCfgCmd
             6 -> esp_ProcessInReportCmd
             6 -> osal_mem_free
      20  esp_ProcessZDOMsg
            20 -> ZDO_ParseDeviceAnnce
            20 -> ZDO_ParseSimpleDescRsp
            20 -> osal_mem_alloc
            20 -> osal_mem_free
            20 -> osal_set_event
       4  esp_PublishBlockPeriodCB
       4  esp_PublishPriceCB
       4  esp_ReportEventStatusCB
      20  esp_ReqFastPollModeCmdCB
            20 -> HalLcdWriteString
            20 -> HalLcdWriteStringValue
            18 -> osal_getClock
            18 -> osal_start_timerEx
            20 -> zclSE_SimpleMetering_Send_ReqFastPollModeRsp
       4  esp_ReqFastPollModeRspCB
       4  esp_ReqMirrorCmdCB
       4  esp_ReqMirrorRspCB
       4  esp_SelAvailEmergencyCreditCmdCB
      18  esp_SendReportEventStatus
            16 -> osal_mem_alloc
            18 -> osal_mem_free
            16 -> osal_memcpy
            18 -> zclSE_LoadControl_Send_ReportEventStatus
       4  esp_SupplyStatusRspCB
       4  esp_ValidateAttrDataCB
       8  esp_event_loop
             8 -> ZDP_SimpleDescReq
             8 -> esp_HandleKeys
             8 -> esp_ProcessIdentifyTimeChange
             8 -> esp_ProcessZCLMsg
             8 -> esp_ProcessZDOMsg
             8 -> osal_getClock
             8 -> osal_msg_deallocate
             8 -> osal_msg_receive
             8 -> osal_start_timerEx


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant "BASE">
       7  ?<Constant "Cur 0x">
      15  ?<Constant "Curr Summ Dlvd">
       7  ?<Constant "End 0x">
      13  ?<Constant "Fast Polling">
      17  ?<Constant "TI IPD Test Msg!">
      17  ?<Constant "Zigbee Coord esp">
      20  ?<Constant {10485761L, 10485762L, 10485763L, 1
      10  ?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40
       8  ?<Initializer for espEp>
      60  ?<Initializer for esp_GenCmdCallbacks>
     104  ?<Initializer for esp_SECmdCallbacks>
       8  ??Subroutine3_0
       6  ?Subroutine0
      12  ?Subroutine1
      10  ?Subroutine2
       6  ?Subroutine3
      18  ?Subroutine4
      18  ?Subroutine5
       8  ?Subroutine6
       8  espEp
       2  espFastPollModeDuration
       1  espTaskID
       2  esp_AlarmCB
       2  esp_BasicResetCB
       2  esp_CancelAllLoadControlEventsCB
      30  esp_CancelLoadControlEventCB
       2  esp_CancelMessageCB
       2  esp_ChangeSupplyCmdCB
      10  esp_DisplayMessageCB
      60  esp_GenCmdCallbacks
       2  esp_GetBlockPeriodCB
     198  esp_GetCurrentPriceCB
     100  esp_GetLastMessageCB
      70  esp_GetProfileCmdCB
       2  esp_GetProfileRspCB
       2  esp_GetScheduledEventCB
      42  esp_GetScheduledPriceCB
     152  esp_HandleKeys
      10  esp_IdentifyCB
       2  esp_IdentifyQueryRspCB
     204  esp_Init
      56  esp_LoadControlEventCB
       2  esp_MessageConfirmationCB
       2  esp_MirrorRemCmdCB
       2  esp_MirrorRemRspCB
       2  esp_PriceAcknowledgementCB
      50  esp_ProcessIdentifyTimeChange
     178  esp_ProcessInConfigReportCmd
      50  esp_ProcessInConfigReportRspCmd
     204  esp_ProcessInReadReportCfgCmd
     196  esp_ProcessInReportCmd
     124  esp_ProcessZCLMsg
     142  esp_ProcessZDOMsg
       2  esp_PublishBlockPeriodCB
       2  esp_PublishPriceCB
       2  esp_ReportEventStatusCB
     178  esp_ReqFastPollModeCmdCB
       2  esp_ReqFastPollModeRspCB
       2  esp_ReqMirrorCmdCB
       2  esp_ReqMirrorRspCB
     104  esp_SECmdCallbacks
       2  esp_SelAvailEmergencyCreditCmdCB
     132  esp_SendReportEventStatus
       2  esp_SupplyStatusRspCB
      28  esp_ValidateAttrDataCB
     188  esp_event_loop
      12  ipdAddr
      12  loadControlAddr
      26  loadControlCmd
      12  pctAddr
      10  simpleDescReqAddr

 
 2 470 bytes in segment CODE
   111 bytes in segment DATA16_C
   172 bytes in segment DATA16_I
   172 bytes in segment DATA16_ID
    75 bytes in segment DATA16_Z
 
 2 470 bytes of CODE  memory
   283 bytes of CONST memory
   247 bytes of DATA  memory

Errors: none
Warnings: none
