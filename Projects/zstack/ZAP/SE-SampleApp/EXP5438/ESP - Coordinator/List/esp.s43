///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      29/Jan/2012  16:16:13 /
// IAR C/C++ Compiler V5.40.2.20380/W32, Evaluation edition for MSP430        /
// Copyright 1996-2011 IAR Systems AB.                                        /
//                                                                            /
//    __rt_version  =  3                                                      /
//    __double_size =  32                                                     /
//    __reg_r4      =  free                                                   /
//    __reg_r5      =  free                                                   /
//    __pic         =  no                                                     /
//    __core        =  430X                                                   /
//    __data_model  =  small                                                  /
//    Source file   =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ /
//                     ZAP\SE-SampleApp\Source\ESP\esp.c                      /
//    Command line  =  -f "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zst /
//                     ack\ZAP\SE-SampleApp\EXP5438\..\..\Source\zap.cfg"     /
//                     (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=!ZAP_PHY_SPI           /
//                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE            /
//                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE              /
//                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE              /
//                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                 /
//                     -DZAP_AF_DATA_REQ_FRAG=FALSE                           /
//                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG           /
//                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC              /
//                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC         /
//                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0        /
//                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                /
//                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000          /
//                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f  /
//                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack /
//                     \ZAP\SE-SampleApp\EXP5438\..\..\..\Tools\MSP5438\f8wZC /
//                     L.cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC             /
//                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH        /
//                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4         /
//                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10        /
//                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10       /
//                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING               /
//                     -DZCL_PRICING -DZCL_MESSAGE) "C:\Texas                 /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\Source\ESP\esp.c" -D                           /
//                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D            /
//                     TC_LINKKEY_JOIN -D ZCL_REPORT -D INTER_PAN -lC         /
//                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack /
//                     \ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\List\"     /
//                     -lA "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zs /
//                     tack\ZAP\SE-SampleApp\EXP5438\ESP -                    /
//                     Coordinator\List\" --remarks --diag_suppress           /
//                     Pe001,Pe193,Pe236,Pe826 -o "C:\Texas                   /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\ESP - Coordinator\Obj\" --debug        /
//                     -D__MSP430F5438A__ -e --double=32 --clib -I "C:\Texas  /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\" -I "C:\Texas                         /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\..\Source\" -I "C:\Texas               /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\..\..\Source\" -I "C:\Texas            /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\..\..\..\..\..\Components\hal\target\M /
//                     SP5438ZAP\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\ /
//                     Projects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\. /
//                     .\Components\hal\include\" -I "C:\Texas                /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\..\..\..\..\..\Components\mac\include\ /
//                     " -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\z /
//                     stack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Componen /
//                     ts\mt\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Proj /
//                     ects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Co /
//                     mponents\osal\include\" -I "C:\Texas                   /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\..\..\..\..\..\Components\osal\mcu\msp /
//                     430\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projec /
//                     ts\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Comp /
//                     onents\services\saddr\" -I "C:\Texas                   /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\..\..\..\..\..\Components\services\sda /
//                     ta\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Project /
//                     s\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Compo /
//                     nents\stack\af\" -I "C:\Texas                          /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\..\..\..\..\..\Components\stack\nwk\"  /
//                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zst /
//                     ack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components /
//                     \stack\sapi\" -I "C:\Texas                             /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\..\..\..\..\..\Components\stack\sec\"  /
//                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zst /
//                     ack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components /
//                     \stack\sys\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0 /
//                     \Projects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\ /
//                     ..\Components\stack\zcl\" -I "C:\Texas                 /
//                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sa /
//                     mpleApp\EXP5438\..\..\..\..\..\Components\stack\zdo\"  /
//                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zst /
//                     ack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components /
//                     \zmac\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Proj /
//                     ects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Co /
//                     mponents\zmac\f8w\" --core=430X --data_model=small     /
//                     -Ohz --multiplier=32 --multiplier_location=4C0         /
//                     --require_prototypes --hw_workaround=CPU40             /
//    List file     =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ /
//                     ZAP\SE-SampleApp\EXP5438\ESP -                         /
//                     Coordinator\List\esp.s43                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME esp

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "small"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?CopyMemoryBytes
        EXTERN ?CopyMemoryWords
        EXTERN ?cstart_init_copy
        EXTERN ?cstart_init_zero
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        FUNCTION esp_AlarmCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_BasicResetCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_CancelAllLoadControlEventsCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_CancelLoadControlEventCB,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 14, STACK
        FUNCTION esp_CancelMessageCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_ChangeSupplyCmdCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_DisplayMessageCB,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_GetBlockPeriodCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_GetCurrentPriceCB,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 58, STACK
        FUNCTION esp_GetLastMessageCB,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 36, STACK
        FUNCTION esp_GetProfileCmdCB,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 40, STACK
        FUNCTION esp_GetProfileRspCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_GetScheduledEventCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_GetScheduledPriceCB,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 58, STACK
        FUNCTION esp_HandleKeys,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 44, STACK
        FUNCTION esp_IdentifyCB,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_IdentifyQueryRspCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC esp_Init
        FUNCTION esp_Init,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        FUNCTION esp_LoadControlEventCB,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 16, STACK
        FUNCTION esp_MessageConfirmationCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_MirrorRemCmdCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_MirrorRemRspCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_PriceAcknowledgementCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_ProcessIdentifyTimeChange,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_ProcessInConfigReportCmd,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 30, STACK
        FUNCTION esp_ProcessInConfigReportRspCmd,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        FUNCTION esp_ProcessInReadReportCfgCmd,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 30, STACK
        FUNCTION esp_ProcessInReportCmd,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 26, STACK
        FUNCTION esp_ProcessZCLMsg,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 6, STACK
        FUNCTION esp_ProcessZDOMsg,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        FUNCTION esp_PublishBlockPeriodCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_PublishPriceCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_ReportEventStatusCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_ReqFastPollModeCmdCB,021603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 20, STACK
        FUNCTION esp_ReqFastPollModeRspCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_ReqMirrorCmdCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_ReqMirrorRspCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_SelAvailEmergencyCreditCmdCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_SendReportEventStatus,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 18, STACK
        FUNCTION esp_SupplyStatusRspCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        FUNCTION esp_ValidateAttrDataCB,0603H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 4, STACK
        PUBLIC esp_event_loop
        FUNCTION esp_event_loop,021203H
        ARGFRAME CSTACK, 0, STACK
        LOCFRAME CSTACK, 8, STACK
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        
          CFI Common cfiCommon1 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H 0
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H 0
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H 0
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H 0
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H 0
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H 0
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H 0
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H 0
          CFI R11 Concat
          CFI R12L SameValue
          CFI R12H 0
          CFI R12 Concat
          CFI R13L SameValue
          CFI R13H 0
          CFI R13 Concat
          CFI R14L SameValue
          CFI R14H 0
          CFI R14 Concat
          CFI R15L SameValue
          CFI R15H 0
          CFI R15 Concat
          CFI EndCommon cfiCommon1
        
        EXTERN _ltoa
        FUNCTION _ltoa,0202H
        EXTERN HalLcdWriteString
        FUNCTION HalLcdWriteString,0202H
        EXTERN zclFindAttrRec
        FUNCTION zclFindAttrRec,0202H
        EXTERN zclAnalogDataType
        FUNCTION zclAnalogDataType,0202H
        EXTERN zclGetDataTypeLength
        FUNCTION zclGetDataTypeLength,0202H
        EXTERN osal_mem_alloc
        FUNCTION osal_mem_alloc,0202H
        EXTERN zcl_SendReadReportCfgRspCmd
        FUNCTION zcl_SendReadReportCfgRspCmd,0202H
        EXTERN osal_mem_free
        FUNCTION osal_mem_free,0202H
        EXTERN zcl_SendConfigReportRspCmd
        FUNCTION zcl_SendConfigReportRspCmd,0202H
        EXTERN ZDO_ParseDeviceAnnce
        FUNCTION ZDO_ParseDeviceAnnce,0202H
        EXTERN osal_set_event
        FUNCTION osal_set_event,0202H
        EXTERN ZDO_ParseSimpleDescRsp
        FUNCTION ZDO_ParseSimpleDescRsp,0202H
        EXTERN espSignature
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H
        EXTERN zclSE_LoadControl_Send_ReportEventStatus
        FUNCTION zclSE_LoadControl_Send_ReportEventStatus,0202H
        EXTERN zclSE_Message_Send_DisplayMessage
        FUNCTION zclSE_Message_Send_DisplayMessage,0202H
        EXTERN osal_memset
        FUNCTION osal_memset,0202H
        EXTERN zclSE_Pricing_Send_PublishPrice
        FUNCTION zclSE_Pricing_Send_PublishPrice,0202H
        EXTERN osal_getClock
        FUNCTION osal_getClock,0202H
        EXTERN espFastPollUpdatePeriod
        EXTERN osal_start_timerEx
        FUNCTION osal_start_timerEx,0202H
        EXTERN zclSE_SimpleMetering_Send_ReqFastPollModeRsp
        FUNCTION zclSE_SimpleMetering_Send_ReqFastPollModeRsp,0202H
        EXTERN HalLcdWriteStringValue
        FUNCTION HalLcdWriteStringValue,0202H
        EXTERN zclSE_SimpleMetering_Send_GetProfileRsp
        FUNCTION zclSE_SimpleMetering_Send_GetProfileRsp,0202H
        EXTERN espIdentifyTime
        EXTERN HalLedBlink
        FUNCTION HalLedBlink,0202H
        EXTERN HalLedSet
        FUNCTION HalLedSet,0202H
        EXTERN osal_stop_timerEx
        FUNCTION osal_stop_timerEx,0202H
        EXTERN zclSE_LoadControl_Send_LoadControlEvent
        FUNCTION zclSE_LoadControl_Send_LoadControlEvent,0202H
        EXTERN osal_msg_deallocate
        FUNCTION osal_msg_deallocate,0202H
        EXTERN osal_msg_receive
        FUNCTION osal_msg_receive,0202H
        EXTERN espTime
        EXTERN ZDP_SimpleDescReq
        FUNCTION ZDP_SimpleDescReq,0202H
        EXTERN espSimpleDesc
        EXTERN zclSE_Init
        FUNCTION zclSE_Init,0202H
        EXTERN zclGeneral_RegisterCmdCallbacks
        FUNCTION zclGeneral_RegisterCmdCallbacks,0202H
        EXTERN zclSE_RegisterCmdCallbacks
        FUNCTION zclSE_RegisterCmdCallbacks,0202H
        EXTERN espAttrs
        EXTERN zcl_registerAttrList
        FUNCTION zcl_registerAttrList,0202H
        EXTERN espOptions
        EXTERN zcl_registerClusterOptionList
        FUNCTION zcl_registerClusterOptionList,0202H
        EXTERN zcl_registerValidateAttrData
        FUNCTION zcl_registerValidateAttrData,0202H
        EXTERN zcl_registerForMsg
        FUNCTION zcl_registerForMsg,0202H
        EXTERN ZDO_RegisterForZDOMsg
        FUNCTION ZDO_RegisterForZDOMsg,0202H
        EXTERN RegisterForKeys
        FUNCTION RegisterForKeys,0202H
        EXTERN StubAPS_RegisterApp
        FUNCTION StubAPS_RegisterApp,0202H

// C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-SampleApp\Source\ESP\esp.c
//    1 /**************************************************************************************************
//    2   Filename:       esp.c
//    3   Revised:        $Date: 2011-07-22 08:49:19 -0700 (Fri, 22 Jul 2011) $
//    4   Revision:       $Revision: 26887 $
//    5 
//    6   Description:    This module implements the ESP functionality and contains the
//    7                   init and event loop functions
//    8 
//    9 
//   10   Copyright 2009-2011 Texas Instruments Incorporated. All rights reserved.
//   11 
//   12   IMPORTANT: Your use of this Software is limited to those specific rights
//   13   granted under the terms of a software license agreement between the user
//   14   who downloaded the software, his/her employer (which must be your employer)
//   15   and Texas Instruments Incorporated (the "License").  You may not use this
//   16   Software unless you agree to abide by the terms of the License. The License
//   17   limits your use, and you acknowledge, that the Software may not be modified,
//   18   copied or distributed unless embedded on a Texas Instruments microcontroller
//   19   or used solely and exclusively in conjunction with a Texas Instruments radio
//   20   frequency transceiver, which is integrated into your product.  Other than for
//   21   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   22   works of, modify, distribute, perform, display or sell this Software and/or
//   23   its documentation for any purpose.
//   24 
//   25   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   26   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   27   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   28   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   29   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   30   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   31   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   32   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   33   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   34   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   35   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   36 
//   37   Should you have any questions regarding your right to use this Software,
//   38   contact Texas Instruments Incorporated at www.TI.com.
//   39 **************************************************************************************************/
//   40 
//   41 /*********************************************************************
//   42   This application is designed for the test purpose of the SE profile which
//   43   exploits the following clusters for an ESP configuration:
//   44 
//   45   General Basic
//   46   General Alarms
//   47   General Time
//   48   General Key Establishment
//   49   SE     Price
//   50   SE     Demand Response and Load Control
//   51   SE     Simple Metering
//   52   SE     Message
//   53 
//   54   Key control:
//   55     SW1:  Send out Cooling Load Control Event to PCT
//   56     SW2:  Send out Load Control Event to Load Control Device
//   57     SW3:  Send out Message to In Premise Display
//   58     SW4:  Not used
//   59 *********************************************************************/
//   60 
//   61 /*********************************************************************
//   62  * INCLUDES
//   63  */
//   64 
//   65 #include "OSAL.h"
//   66 #include "OSAL_Clock.h"
//   67 #include "OSAL_Nv.h"
//   68 #include "MT.h"
//   69 #include "MT_APP.h"
//   70 #include "ZDObject.h"
//   71 #include "AddrMgr.h"
//   72 
//   73 #include "se.h"
//   74 #include "esp.h"
//   75 #include "zcl_general.h"
//   76 #include "zcl_se.h"
//   77 #include "zcl_key_establish.h"
//   78 
//   79 #if defined( INTER_PAN )
//   80   #include "stub_aps.h"
//   81 #endif
//   82 
//   83 #include "onboard.h"
//   84 
//   85 /* HAL */
//   86 #include "hal_lcd.h"
//   87 #include "hal_led.h"
//   88 #include "hal_key.h"
//   89 
//   90 
//   91 /*********************************************************************
//   92  * MACROS
//   93  */
//   94 
//   95 // There is no attribute in the Mandatory Reportable Attribute list for now
//   96 #define zcl_MandatoryReportableAttribute( a ) ( a == NULL )
//   97 
//   98 /*********************************************************************
//   99  * CONSTANTS
//  100  */
//  101 
//  102 #define ESP_MIN_REPORTING_INTERVAL       5
//  103 
//  104 /*********************************************************************
//  105  * TYPEDEFS
//  106  */
//  107 
//  108 /*********************************************************************
//  109  * GLOBAL VARIABLES
//  110  */
//  111 
//  112 /*********************************************************************
//  113  * GLOBAL FUNCTIONS
//  114  */
//  115 
//  116 /*********************************************************************
//  117  * LOCAL VARIABLES
//  118  */
//  119 

        RSEG DATA16_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero
//  120 static uint8 espTaskID;                              // esp osal task id
espTaskID:
        DS8 1

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  121 static afAddrType_t ipdAddr;                         // destination address of in premise display
ipdAddr:
        DS8 12

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  122 static afAddrType_t pctAddr;                         // destination address of PCT
pctAddr:
        DS8 12

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  123 static afAddrType_t loadControlAddr;                 // destination address of load control device
loadControlAddr:
        DS8 12

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  124 static zAddrType_t simpleDescReqAddr;                // destination addresses for simple desc request
simpleDescReqAddr:
        DS8 10

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  125 static zclCCLoadControlEvent_t loadControlCmd;       // command structure for load control command
loadControlCmd:
        DS8 26

        RSEG DATA16_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero
//  126 static uint16 espFastPollModeDuration;               // number of fast poll events
espFastPollModeDuration:
        DS8 2
//  127 
//  128 #if defined ( INTER_PAN )
//  129 // define endpoint structure to register with STUB APS for INTER-PAN support

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  130 static endPointDesc_t espEp =
espEp:
        DS8 8
        REQUIRE `?<Initializer for espEp>`
//  131 {
//  132   ESP_ENDPOINT,
//  133   &espTaskID,
//  134   (SimpleDescriptionFormat_t *)&espSimpleDesc,
//  135   (afNetworkLatencyReq_t)0
//  136 };
//  137 #endif
//  138 
//  139 /*********************************************************************
//  140  * LOCAL FUNCTIONS
//  141  */
//  142 static void esp_HandleKeys( uint8 shift, uint8 keys );
//  143 static void esp_ProcessAppMsg( uint8 *msg );
//  144 
//  145 #if defined (ZCL_ALARMS)
//  146 static void esp_ProcessAlarmCmd( uint8 srcEP, afAddrType_t *dstAddr,
//  147                         uint16 clusterID, zclFrameHdr_t *hdr, uint8 len, uint8 *data );
//  148 #endif // ZCL_ALARMS
//  149 
//  150 static void esp_ProcessIdentifyTimeChange( void );
//  151 
//  152 /*************************************************************************/
//  153 /*** Application Callback Functions                                    ***/
//  154 /*************************************************************************/
//  155 
//  156 // Foundation Callback functions
//  157 static uint8 esp_ValidateAttrDataCB( zclAttrRec_t *pAttr, zclWriteRec_t *pAttrInfo );
//  158 
//  159 // General Cluster Callback functions
//  160 static void esp_BasicResetCB( void );
//  161 static void esp_IdentifyCB( zclIdentify_t *pCmd );
//  162 static void esp_IdentifyQueryRspCB( zclIdentifyQueryRsp_t *pRsp );
//  163 static void esp_AlarmCB( zclAlarm_t *pAlarm );
//  164 
//  165 // SE Callback functions
//  166 static void esp_GetProfileCmdCB( zclCCGetProfileCmd_t *pCmd,
//  167                                        afAddrType_t *srcAddr, uint8 seqNum );
//  168 static void esp_GetProfileRspCB( zclCCGetProfileRsp_t *pCmd,
//  169                                        afAddrType_t *srcAddr, uint8 seqNum );
//  170 static void esp_ReqMirrorCmdCB( afAddrType_t *srcAddr, uint8 seqNum );
//  171 static void esp_ReqMirrorRspCB( zclCCReqMirrorRsp_t *pCmd,
//  172                                        afAddrType_t *srcAddr, uint8 seqNum );
//  173 static void esp_MirrorRemCmdCB( afAddrType_t *srcAddr, uint8 seqNum );
//  174 static void esp_MirrorRemRspCB( zclCCMirrorRemRsp_t *pCmd,
//  175                                        afAddrType_t *srcAddr, uint8 seqNum );
//  176 static void esp_ReqFastPollModeCmdCB( zclCCReqFastPollModeCmd_t *pCmd,
//  177                                        afAddrType_t *srcAddr, uint8 seqNum ) ;
//  178 static void esp_ReqFastPollModeRspCB( zclCCReqFastPollModeRsp_t *pRsp,
//  179                                        afAddrType_t *srcAddr, uint8 seqNum ) ;
//  180 static void esp_GetCurrentPriceCB( zclCCGetCurrentPrice_t *pCmd,
//  181                                        afAddrType_t *srcAddr, uint8 seqNum );
//  182 static void esp_GetScheduledPriceCB( zclCCGetScheduledPrice_t *pCmd,
//  183                                        afAddrType_t *srcAddr, uint8 seqNum );
//  184 static void esp_PriceAcknowledgementCB( zclCCPriceAcknowledgement_t *pCmd,
//  185                                        afAddrType_t *srcAddr, uint8 seqNum );
//  186 static void esp_GetBlockPeriodCB( zclCCGetBlockPeriod_t *pCmd,
//  187                                        afAddrType_t *srcAddr, uint8 seqNum );
//  188 static void esp_PublishPriceCB( zclCCPublishPrice_t *pCmd,
//  189                                        afAddrType_t *srcAddr, uint8 seqNum );
//  190 static void esp_PublishBlockPeriodCB( zclCCPublishBlockPeriod_t *pCmd,
//  191                                        afAddrType_t *srcAddr, uint8 seqNum );
//  192 static void esp_DisplayMessageCB( zclCCDisplayMessage_t *pCmd,
//  193                                        afAddrType_t *srcAddr, uint8 seqNum );
//  194 static void esp_CancelMessageCB( zclCCCancelMessage_t *pCmd,
//  195                                        afAddrType_t *srcAddr, uint8 seqNum );
//  196 static void esp_GetLastMessageCB( afAddrType_t *srcAddr, uint8 seqNum );
//  197 static void esp_MessageConfirmationCB( zclCCMessageConfirmation_t *pCmd,
//  198                                        afAddrType_t *srcAddr, uint8 seqNum );
//  199 static void esp_LoadControlEventCB( zclCCLoadControlEvent_t *pCmd,
//  200                                        afAddrType_t *srcAddr, uint8 status, uint8 seqNum);
//  201 static void esp_CancelLoadControlEventCB( zclCCCancelLoadControlEvent_t *pCmd,
//  202                                        afAddrType_t *srcAddr, uint8 seqNum );
//  203 static void esp_CancelAllLoadControlEventsCB( zclCCCancelAllLoadControlEvents_t *pCmd,
//  204                                        afAddrType_t *srcAddr, uint8 seqNum );
//  205 static void esp_ReportEventStatusCB( zclCCReportEventStatus_t *pCmd,
//  206                                        afAddrType_t *srcAddr, uint8 seqNum );
//  207 static void esp_GetScheduledEventCB( zclCCGetScheduledEvent_t *pCmd,
//  208                                        afAddrType_t *srcAddr, uint8 seqNum );
//  209 static void esp_SelAvailEmergencyCreditCmdCB( zclCCSelAvailEmergencyCredit_t *pCmd,
//  210                                        afAddrType_t *srcAddr, uint8 seqNum );
//  211 static void esp_ChangeSupplyCmdCB( zclCCChangeSupply_t *pCmd,
//  212                                        afAddrType_t *srcAddr, uint8 seqNum );
//  213 static void esp_SupplyStatusRspCB( zclCCSupplyStatusResponse_t *pCmd,
//  214                                        afAddrType_t *srcAddr, uint8 seqNum );
//  215 
//  216 /************************************************************************/
//  217 /***               Functions to process ZCL Foundation                ***/
//  218 /***               incoming Command/Response messages                 ***/
//  219 /************************************************************************/
//  220 static void esp_ProcessZCLMsg( zclIncomingMsg_t *msg );
//  221 #if defined ( ZCL_READ )
//  222 static uint8 esp_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg );
//  223 #endif // ZCL_READ
//  224 #if defined ( ZCL_WRITE )
//  225 static uint8 esp_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg );
//  226 #endif // ZCL_WRITE
//  227 #if defined ( ZCL_REPORT )
//  228 static uint8 esp_ProcessInConfigReportCmd( zclIncomingMsg_t *pInMsg );
//  229 static uint8 esp_ProcessInConfigReportRspCmd( zclIncomingMsg_t *pInMsg );
//  230 static uint8 esp_ProcessInReadReportCfgCmd( zclIncomingMsg_t *pInMsg );
//  231 static uint8 esp_ProcessInReadReportCfgRspCmd( zclIncomingMsg_t *pInMsg );
//  232 static uint8 esp_ProcessInReportCmd( zclIncomingMsg_t *pInMsg );
//  233 #endif // ZCL_REPORT
//  234 static uint8 esp_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg );
//  235 #if defined ( ZCL_DISCOVER )
//  236 static uint8 esp_ProcessInDiscRspCmd( zclIncomingMsg_t *pInMsg );
//  237 #endif // ZCL_DISCOVER
//  238 
//  239 // Functions to handle ZDO messages
//  240 static void esp_ProcessZDOMsg( zdoIncomingMsg_t *inMsg );
//  241 
//  242 /*********************************************************************
//  243  * ZCL General Clusters Callback table
//  244  */

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  245 static zclGeneral_AppCallbacks_t esp_GenCmdCallbacks =
esp_GenCmdCallbacks:
        DS8 60
        REQUIRE `?<Initializer for esp_GenCmdCallbacks>`
//  246 {
//  247   esp_BasicResetCB,              // Basic Cluster Reset command
//  248   esp_IdentifyCB,                // Identify command
//  249   esp_IdentifyQueryRspCB,        // Identify Query Response command
//  250   NULL,                          // On/Off cluster commands
//  251   NULL,                          // Level Control Move to Level command
//  252   NULL,                          // Level Control Move command
//  253   NULL,                          // Level Control Step command
//  254   NULL,                          // Level Control Stop command
//  255   NULL,                          // Group Response commands
//  256   NULL,                          // Scene Store Request command
//  257   NULL,                          // Scene Recall Request command
//  258   NULL,                          // Scene Response command
//  259   esp_AlarmCB,                   // Alarm (Response) command
//  260   NULL,                          // RSSI Location command
//  261   NULL                           // RSSI Location Response command
//  262 };
//  263 
//  264 /*********************************************************************
//  265  * ZCL SE Clusters Callback table
//  266  */

        RSEG DATA16_I:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_copy
//  267 static zclSE_AppCallbacks_t esp_SECmdCallbacks =			
esp_SECmdCallbacks:
        DS8 104
        REQUIRE `?<Initializer for esp_SECmdCallbacks>`
//  268 {
//  269   esp_GetProfileCmdCB,                     // Get Profile Command
//  270   esp_GetProfileRspCB,                     // Get Profile Response
//  271   esp_ReqMirrorCmdCB,                      // Request Mirror Command
//  272   esp_ReqMirrorRspCB,                      // Request Mirror Response
//  273   esp_MirrorRemCmdCB,                      // Mirror Remove Command
//  274   esp_MirrorRemRspCB,                      // Mirror Remove Response
//  275   esp_GetCurrentPriceCB,                   // Get Current Price
//  276   esp_GetScheduledPriceCB,                 // Get Scheduled Price
//  277   esp_PublishPriceCB,                      // Publish Price
//  278   esp_DisplayMessageCB,                    // Display Message Command
//  279   esp_CancelMessageCB,                     // Cancel Message Command
//  280   esp_GetLastMessageCB,                    // Get Last Message Command
//  281   esp_MessageConfirmationCB,               // Message Confirmation
//  282   esp_LoadControlEventCB,                  // Load Control Event
//  283   esp_CancelLoadControlEventCB,            // Cancel Load Control Event
//  284   esp_CancelAllLoadControlEventsCB,        // Cancel All Load Control Events
//  285   esp_ReportEventStatusCB,                 // Report Event Status
//  286   esp_GetScheduledEventCB,                 // Get Scheduled Event
//  287   esp_ReqFastPollModeCmdCB,                // Request Fast Poll Mode Command
//  288   esp_ReqFastPollModeRspCB,                // Request Fast Poll Mode Response
//  289   esp_PriceAcknowledgementCB,              // Price Acknowledgement
//  290   esp_GetBlockPeriodCB,                    // Get Block Period
//  291   esp_PublishBlockPeriodCB,                // Publish Block Period
//  292   esp_SelAvailEmergencyCreditCmdCB,        // Select Available Emergency Credit Command
//  293   esp_ChangeSupplyCmdCB,                   // Change Supply Command
//  294   esp_SupplyStatusRspCB                    // Supply Status Response
//  295 };
//  296 
//  297 /*********************************************************************
//  298  * @fn          esp_Init
//  299  *
//  300  * @brief       Initialization function for the ZCL App Application.
//  301  *
//  302  * @param       uint8 task_id - esp task id
//  303  *
//  304  * @return      none
//  305  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  306 void esp_Init( uint8 task_id )
esp_Init:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function esp_Init
//  307 {
        FUNCALL esp_Init, zclSE_Init
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, zclGeneral_RegisterCmdCallbacks
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, zclSE_RegisterCmdCallbacks
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, zcl_registerAttrList
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, zcl_registerClusterOptionList
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, zcl_registerValidateAttrData
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, zcl_registerForMsg
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, ZDO_RegisterForZDOMsg
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, ZDO_RegisterForZDOMsg
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, RegisterForKeys
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, StubAPS_RegisterApp
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_Init, osal_start_timerEx
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
//  308   espTaskID = task_id;
        MOV.B   R12, &espTaskID
//  309 
//  310   // Register for an SE endpoint
//  311   zclSE_Init( &espSimpleDesc );
        MOV.W   #espSimpleDesc, R12
        CALLA   #zclSE_Init
//  312 
//  313   // Register the ZCL General Cluster Library callback functions
//  314   zclGeneral_RegisterCmdCallbacks( ESP_ENDPOINT, &esp_GenCmdCallbacks );
        MOV.B   #0x9, R10
        MOV.W   #esp_GenCmdCallbacks, R13
        MOV.B   R10, R12
        CALLA   #zclGeneral_RegisterCmdCallbacks
//  315 
//  316   // Register the ZCL SE Cluster Library callback functions
//  317   zclSE_RegisterCmdCallbacks( ESP_ENDPOINT, &esp_SECmdCallbacks );
        MOV.W   #esp_SECmdCallbacks, R13
        MOV.B   R10, R12
        CALLA   #zclSE_RegisterCmdCallbacks
//  318 
//  319   // Register the application's attribute list
//  320   zcl_registerAttrList( ESP_ENDPOINT, ESP_MAX_ATTRIBUTES, espAttrs );
        MOV.W   #espAttrs, R14
        MOV.B   #0x59, R13
        MOV.B   R10, R12
        CALLA   #zcl_registerAttrList
//  321 
//  322   // Register the application's cluster option list
//  323   zcl_registerClusterOptionList( ESP_ENDPOINT, ESP_MAX_OPTIONS, espOptions );
        MOV.W   #espOptions, R14
        MOV.B   #0x7, R13
        MOV.B   R10, R12
        CALLA   #zcl_registerClusterOptionList
//  324 
//  325   // Register the application's attribute data validation callback function
//  326   zcl_registerValidateAttrData( esp_ValidateAttrDataCB );
        MOV.W   #LWRD(esp_ValidateAttrDataCB), R12
        MOV.W   #HWRD(esp_ValidateAttrDataCB), R13
        CALLA   #zcl_registerValidateAttrData
//  327 
//  328   // Register the Application to receive the unprocessed Foundation command/response messages
//  329   zcl_registerForMsg( espTaskID );
        MOV.W   #espTaskID, R11
        MOV.B   @R11, R12
        CALLA   #zcl_registerForMsg
//  330 
//  331   // register for end device annce and simple descriptor responses
//  332   ZDO_RegisterForZDOMsg( espTaskID, Device_annce );
        MOV.W   #0x13, R13
        MOV.B   @R11, R12
        CALLA   #ZDO_RegisterForZDOMsg
//  333   ZDO_RegisterForZDOMsg( espTaskID, Simple_Desc_rsp );
        MOV.W   #0x8004, R13
        MOV.B   @R11, R12
        CALLA   #ZDO_RegisterForZDOMsg
//  334 
//  335   // Register for all key events - This app will handle all key events
//  336   RegisterForKeys( espTaskID );
        MOV.B   @R11, R12
        CALLA   #RegisterForKeys
//  337 
//  338 #if defined ( INTER_PAN )
//  339   // Register with Stub APS
//  340   StubAPS_RegisterApp( &espEp );
        MOV.W   #espEp, R12
        CALLA   #StubAPS_RegisterApp
//  341 #endif
//  342 
//  343   // Start the timer to sync esp timer with the osal timer
//  344   osal_start_timerEx( espTaskID, ESP_UPDATE_TIME_EVT, ESP_UPDATE_TIME_PERIOD );
        MOV.W   #0x3e8, R14
        MOV.W   #0x2, R13
        MOV.B   @R11, R12
        CALLA   #osal_start_timerEx
//  345 
//  346   // setup address mode and destination endpoint fields for PCT
//  347   pctAddr.addrMode = (afAddrMode_t)Addr16Bit;
        MOV.B   #0x2, &pctAddr + 8
//  348   pctAddr.endPoint = ESP_ENDPOINT;
        MOV.B   R10, &pctAddr + 9
//  349 
//  350   // setup address mode and destination endpoint fields for load control device
//  351   loadControlAddr.addrMode = (afAddrMode_t)Addr16Bit;
        MOV.B   #0x2, &loadControlAddr + 8
//  352   loadControlAddr.endPoint = ESP_ENDPOINT;
        MOV.B   R10, &loadControlAddr + 9
//  353 
//  354   //setup load control command structure
//  355   loadControlCmd.issuerEvent = 0x12345678;            // arbitrary id
        MOV.W   #0x5678, &loadControlCmd
        MOV.W   #0x1234, &loadControlCmd + 2
//  356   loadControlCmd.deviceGroupClass = 0x000000;         // addresses all groups
        MOV.W   #0x0, &loadControlCmd + 4
        MOV.W   #0x0, &loadControlCmd + 6
//  357   loadControlCmd.startTime = 0x00000000;              // start time = NOW
        MOV.W   #0x0, &loadControlCmd + 8
        MOV.W   #0x0, &loadControlCmd + 10
//  358   loadControlCmd.durationInMinutes = 0x0001;          // duration of one minute
        MOV.W   #0x1, &loadControlCmd + 12
//  359   loadControlCmd.criticalityLevel = 0x01;             // green level
        MOV.B   #0x1, &loadControlCmd + 14
//  360   loadControlCmd.coolingTemperatureSetPoint = 0x076C; // 19 degrees C, 66.2 degress fahrenheit
        MOV.W   #0x76c, &loadControlCmd + 18
//  361   loadControlCmd.eventControl = 0x00;                 // no randomized start or end applied
        MOV.B   #0x0, &loadControlCmd + 24
//  362 
//  363   // Initialize variable used to control number of fast poll events
//  364   espFastPollModeDuration = 0;
        MOV.W   #0x0, &espFastPollModeDuration
//  365 }
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock0
//  366 
//  367 /*********************************************************************
//  368  * @fn          esp_event_loop
//  369  *
//  370  * @brief       Event Loop Processor for esp.
//  371  *
//  372  * @param       uint8 task_id - esp task id
//  373  * @param       uint16 events - event bitmask
//  374  *
//  375  * @return      none
//  376  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  377 uint16 esp_event_loop( uint8 task_id, uint16 events )
esp_event_loop:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function esp_event_loop
//  378 {
        FUNCALL esp_event_loop, esp_ProcessIdentifyTimeChange
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_event_loop, esp_ProcessZDOMsg
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_event_loop, osal_msg_deallocate
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_event_loop, osal_msg_receive
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_event_loop, esp_ProcessZCLMsg
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_event_loop, esp_HandleKeys
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_event_loop, osal_getClock
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_event_loop, osal_start_timerEx
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_event_loop, ZDP_SimpleDescReq
        LOCFRAME CSTACK, 8, STACK
        FUNCALL esp_event_loop, osal_start_timerEx
        LOCFRAME CSTACK, 8, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        MOV.W   R13, R10
//  379   afIncomingMSGPacket_t *MSGpkt;
//  380 
//  381   if ( events & SYS_EVENT_MSG )
        CMP.W   #0x0, R13
        JL      ??esp_event_loop_3
//  382   {
//  383     while ( (MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( espTaskID )) )
//  384     {
//  385       switch ( MSGpkt->hdr.event )
//  386       {
//  387         case MT_SYS_APP_MSG:
//  388           // Message received from MT (serial port)
//  389           esp_ProcessAppMsg( ((mtSysAppMsg_t *)MSGpkt)->appData );
//  390           break;
//  391 
//  392         case ZCL_INCOMING_MSG:
//  393           // Incoming ZCL foundation command/response messages
//  394           esp_ProcessZCLMsg( (zclIncomingMsg_t *)MSGpkt );
//  395           break;
//  396 
//  397         case KEY_CHANGE:
//  398           esp_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
//  399           break;
//  400 
//  401         case ZDO_CB_MSG:
//  402           // ZDO sends the message that we registered for
//  403           esp_ProcessZDOMsg( (zdoIncomingMsg_t *)MSGpkt );
//  404           break;
//  405 
//  406         default:
//  407           break;
//  408       }
//  409 
//  410       // Release the memory
//  411       osal_msg_deallocate( (uint8 *)MSGpkt );
//  412 
//  413     }
//  414 
//  415     // return unprocessed events
//  416     return (events ^ SYS_EVENT_MSG);
//  417   }
//  418 
//  419   // handle processing of identify timeout event triggered by an identify command
//  420   if ( events & ESP_IDENTIFY_TIMEOUT_EVT )
        BIT.W   #0x1, R13
        JNC     ??esp_event_loop_4
//  421   {
//  422     if ( espIdentifyTime > 0 )
        CMP.W   #0x0, &espIdentifyTime
        JEQ     ??esp_event_loop_5
//  423     {
//  424       espIdentifyTime--;
        ADD.W   #0xffff, &espIdentifyTime
//  425     }
//  426     esp_ProcessIdentifyTimeChange();
??esp_event_loop_5:
        CALLA   #esp_ProcessIdentifyTimeChange
//  427 
//  428     return ( events ^ ESP_IDENTIFY_TIMEOUT_EVT );
        XOR.W   #0x1, R10
        JMP     ??esp_event_loop_2
//  429   }
??esp_event_loop_0:
        CALLA   #esp_ProcessZDOMsg
??esp_event_loop_1:
        MOV.W   R11, R12
        CALLA   #osal_msg_deallocate
??esp_event_loop_3:
        MOV.B   &espTaskID, R12
        CALLA   #osal_msg_receive
        MOV.W   R12, R11
        CMP.W   #0x0, R12
        JEQ     ??esp_event_loop_6
        MOV.B   @R12, R14
        SUB.B   #0x34, R14
        JEQ     ??esp_event_loop_7
        SUB.B   #0x8c, R14
        JEQ     ??esp_event_loop_8
        SUB.B   #0x13, R14
        JEQ     ??esp_event_loop_0
        JMP     ??esp_event_loop_1
??esp_event_loop_7:
        CALLA   #esp_ProcessZCLMsg
        JMP     ??esp_event_loop_1
??esp_event_loop_8:
        MOV.B   0x3(R12), R13
        MOV.B   0x2(R11), R12
        CALLA   #esp_HandleKeys
        JMP     ??esp_event_loop_1
??esp_event_loop_6:
        XOR.W   #0x8000, R10
        JMP     ??esp_event_loop_2
//  430 
//  431   // event to get current time
//  432   if ( events & ESP_UPDATE_TIME_EVT )
??esp_event_loop_4:
        BIT.W   #0x2, R13
        JNC     ??esp_event_loop_9
//  433   {
//  434     espTime = osal_getClock();
        CALLA   #osal_getClock
        MOV.W   R12, &espTime
        MOV.W   R13, &espTime + 2
//  435     osal_start_timerEx( espTaskID, ESP_UPDATE_TIME_EVT, ESP_UPDATE_TIME_PERIOD );
        MOV.W   #0x3e8, R14
        MOV.W   #0x2, R13
        CALLA   #??Subroutine3_0
//  436 
//  437     return ( events ^ ESP_UPDATE_TIME_EVT );
??CrossCallReturnLabel_12:
        XOR.W   #0x2, R10
        JMP     ??esp_event_loop_2
//  438   }
//  439 
//  440 
//  441   // event to get simple descriptor of the newly joined device
//  442   if ( events & SIMPLE_DESC_QUERY_EVT )
??esp_event_loop_9:
        BIT.W   #0x4, R13
        JNC     ??esp_event_loop_10
//  443   {
//  444       ZDP_SimpleDescReq( &simpleDescReqAddr, simpleDescReqAddr.addr.shortAddr,
//  445                         ESP_ENDPOINT, 0);
        MOV.B   #0x0, R15
        MOV.B   #0x9, R14
        MOV.W   &simpleDescReqAddr, R13
        MOV.W   #simpleDescReqAddr, R12
        CALLA   #ZDP_SimpleDescReq
//  446 
//  447       return ( events ^ SIMPLE_DESC_QUERY_EVT );
        XOR.W   #0x4, R10
        JMP     ??esp_event_loop_2
//  448   }
//  449 
//  450   // handle processing of timeout event triggered by request fast polling command
//  451   if ( events & ESP_FAST_POLL_MODE_EVT )
??esp_event_loop_10:
        BIT.W   #0x8, R13
        JNC     ??esp_event_loop_11
//  452   {
//  453     if (espFastPollModeDuration)
        CMP.W   #0x0, &espFastPollModeDuration
        JEQ     ??esp_event_loop_12
//  454     {
//  455       espFastPollModeDuration--;
        ADD.W   #0xffff, &espFastPollModeDuration
//  456       // Start the timer for the fast poll period
//  457       osal_start_timerEx( espTaskID, ESP_FAST_POLL_MODE_EVT, ESP_FAST_POLL_TIMER_PERIOD );
        CALLA   #?Subroutine3
//  458     }
//  459 
//  460     return ( events ^ ESP_FAST_POLL_MODE_EVT );
??esp_event_loop_12:
        XOR.W   #0x8, R10
??esp_event_loop_2:
        MOV.W   R10, R12
        JMP     ??esp_event_loop_13
//  461   }
//  462 
//  463   // Discard unknown events
//  464   return 0;
??esp_event_loop_11:
        MOV.W   #0x0, R12
??esp_event_loop_13:
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  465 }

        RSEG CODE:CODE:NOROOT(1)
?Subroutine3:
          CFI Block cfiCond2 Using cfiCommon0
          CFI Function esp_ReqFastPollModeCmdCB
          CFI Conditional ??esp_ReqFastPollModeCmdCB_4
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+22
          CFI Block cfiCond3 Using cfiCommon0
          CFI (cfiCond3) Function esp_event_loop
          CFI (cfiCond3) Conditional ??esp_event_loop_12
          CFI (cfiCond3) R10L Frame(CFA, -8)
          CFI (cfiCond3) R11L Frame(CFA, -6)
          CFI (cfiCond3) CFA SP+12
          CFI Block cfiPicker4 Using cfiCommon1
          CFI (cfiPicker4) NoFunction
          CFI (cfiPicker4) Picker
        MOV.W   #0x3e8, R14
        MOV.W   #0x8, R13
          CFI EndBlock cfiCond2
          CFI EndBlock cfiCond3
          CFI EndBlock cfiPicker4
        REQUIRE ??Subroutine3_0
        // Fall through to label ??Subroutine3_0

        RSEG CODE:CODE:REORDER:NOROOT(1)
??Subroutine3_0:
          CFI Block cfiCond5 Using cfiCommon0
          CFI Function esp_ProcessIdentifyTimeChange
          CFI Conditional ??CrossCallReturnLabel_13
          CFI CFA SP+8
          CFI Block cfiCond6 Using cfiCommon0
          CFI (cfiCond6) Function esp_event_loop
          CFI (cfiCond6) Conditional ??CrossCallReturnLabel_12
          CFI (cfiCond6) R10L Frame(CFA, -8)
          CFI (cfiCond6) R11L Frame(CFA, -6)
          CFI (cfiCond6) CFA SP+12
          CFI Block cfiCond7 Using cfiCommon0
          CFI (cfiCond7) Function esp_ReqFastPollModeCmdCB
          CFI (cfiCond7) Conditional ??esp_ReqFastPollModeCmdCB_4
          CFI (cfiCond7) R8L Frame(CFA, -12)
          CFI (cfiCond7) R9L Frame(CFA, -10)
          CFI (cfiCond7) R10L Frame(CFA, -8)
          CFI (cfiCond7) R11L Frame(CFA, -6)
          CFI (cfiCond7) CFA SP+22
          CFI Block cfiCond8 Using cfiCommon0
          CFI (cfiCond8) Function esp_event_loop
          CFI (cfiCond8) Conditional ??esp_event_loop_12
          CFI (cfiCond8) R10L Frame(CFA, -8)
          CFI (cfiCond8) R11L Frame(CFA, -6)
          CFI (cfiCond8) CFA SP+12
          CFI Block cfiPicker9 Using cfiCommon1
          CFI (cfiPicker9) NoFunction
          CFI (cfiPicker9) Picker
        MOV.B   &espTaskID, R12
        BRA     #osal_start_timerEx
          CFI EndBlock cfiCond5
          CFI EndBlock cfiCond6
          CFI EndBlock cfiCond7
          CFI EndBlock cfiCond8
          CFI EndBlock cfiPicker9
//  466 
//  467 /*********************************************************************
//  468  * @fn      esp_ProcessAppMsg
//  469  *
//  470  * @brief   Process MT SYS APP MSG
//  471  *
//  472  * @param   msg - pointer to message
//  473  *
//  474  * @return  none
//  475  */
//  476 static void esp_ProcessAppMsg( uint8 *msg )
//  477 {
//  478   // user should include code to handle MT SYS APP MSG here
//  479 }
//  480 
//  481 /*********************************************************************
//  482  * @fn      esp_ProcessIdentifyTimeChange
//  483  *
//  484  * @brief   Called to blink led for specified IdentifyTime attribute value
//  485  *
//  486  * @param   none
//  487  *
//  488  * @return  none
//  489  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  490 static void esp_ProcessIdentifyTimeChange( void )
esp_ProcessIdentifyTimeChange:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function esp_ProcessIdentifyTimeChange
//  491 {
//  492   if ( espIdentifyTime > 0 )
        FUNCALL esp_ProcessIdentifyTimeChange, osal_start_timerEx
        LOCFRAME CSTACK, 4, STACK
        FUNCALL esp_ProcessIdentifyTimeChange, HalLedBlink
        LOCFRAME CSTACK, 4, STACK
        FUNCALL esp_ProcessIdentifyTimeChange, HalLedSet
        LOCFRAME CSTACK, 4, STACK
        FUNCALL esp_ProcessIdentifyTimeChange, osal_stop_timerEx
        LOCFRAME CSTACK, 4, STACK
        CMP.W   #0x0, &espIdentifyTime
        JEQ     ??esp_ProcessIdentifyTimeChange_0
//  493   {
//  494     osal_start_timerEx( espTaskID, ESP_IDENTIFY_TIMEOUT_EVT, 1000 );
        MOV.W   #0x3e8, R14
        MOV.W   #0x1, R13
        CALLA   #??Subroutine3_0
//  495     HalLedBlink ( HAL_LED_4, 0xFF, HAL_LED_DEFAULT_DUTY_CYCLE, HAL_LED_DEFAULT_FLASH_TIME );
??CrossCallReturnLabel_13:
        MOV.W   #0x3e8, R15
        MOV.B   #0x5, R14
        MOV.B   #0xff, R13
        MOV.B   #0x8, R12
        BRA     #HalLedBlink
//  496   }
//  497   else
//  498   {
//  499     HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
??esp_ProcessIdentifyTimeChange_0:
        MOV.B   #0x0, R13
        MOV.B   #0x8, R12
        CALLA   #HalLedSet
//  500     osal_stop_timerEx( espTaskID, ESP_IDENTIFY_TIMEOUT_EVT );
        MOV.W   #0x1, R13
        MOV.B   &espTaskID, R12
        BRA     #osal_stop_timerEx
          CFI EndBlock cfiBlock10
//  501   }
//  502 }
//  503 
//  504 
//  505 /*********************************************************************
//  506  * @fn      esp_HandleKeys
//  507  *
//  508  * @brief   Handles all key events for this device.
//  509  *
//  510  * @param   shift - true if in shift/alt.
//  511  * @param   keys - bit field for key events. Valid entries:
//  512  *                 HAL_KEY_SW_4
//  513  *                 HAL_KEY_SW_3
//  514  *                 HAL_KEY_SW_2
//  515  *                 HAL_KEY_SW_1
//  516  *
//  517  * @return  none
//  518  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  519 static void esp_HandleKeys( uint8 shift, uint8 keys )
esp_HandleKeys:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function esp_HandleKeys
//  520 {
        FUNCALL esp_HandleKeys, zclSE_LoadControl_Send_LoadControlEvent
        LOCFRAME CSTACK, 44, STACK
        FUNCALL esp_HandleKeys, zclSE_LoadControl_Send_LoadControlEvent
        LOCFRAME CSTACK, 44, STACK
        FUNCALL esp_HandleKeys, zclSE_Message_Send_DisplayMessage
        LOCFRAME CSTACK, 44, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        SUB.W   #0x24, SP
          CFI CFA SP+42
        MOV.B   R13, R10
//  521   // Shift is used to make each button/switch dual purpose.
//  522   if ( shift )
        CMP.B   #0x0, R12
        JNE     ??esp_HandleKeys_0
//  523   {
//  524     if ( keys & HAL_KEY_SW_1 )
//  525     {
//  526     }
//  527     if ( keys & HAL_KEY_SW_2 )
//  528     {
//  529     }
//  530     if ( keys & HAL_KEY_SW_3 )
//  531     {
//  532     }
//  533     if ( keys & HAL_KEY_SW_4 )
//  534     {
//  535     }
//  536   }
//  537   else
//  538   {
//  539     if ( keys & HAL_KEY_SW_1 )
        BIT.B   #0x1, R13
        JNC     ??esp_HandleKeys_1
//  540     {
//  541       // send out cooling event to PCT
//  542       loadControlCmd.deviceGroupClass = HVAC_DEVICE_CLASS; // HVAC compressor or furnace - bit 0 is set
        MOV.W   #0x1, &loadControlCmd + 4
        MOV.W   #0x0, &loadControlCmd + 6
//  543       zclSE_LoadControl_Send_LoadControlEvent( ESP_ENDPOINT, &pctAddr, &loadControlCmd, TRUE, 0 );
        PUSH.B  #0x0
          CFI CFA SP+44
        MOV.B   #0x1, R15
        MOV.W   #loadControlCmd, R14
        MOV.W   #pctAddr, R13
        MOV.B   #0x9, R12
        CALLA   #zclSE_LoadControl_Send_LoadControlEvent
        ADD.W   #0x2, SP
          CFI CFA SP+42
//  544     }
//  545 
//  546     if ( keys & HAL_KEY_SW_2 )
??esp_HandleKeys_1:
        BIT.B   #0x2, R10
        JNC     ??esp_HandleKeys_2
//  547     {
//  548       // send out load control event to load control device
//  549       loadControlCmd.deviceGroupClass = ONOFF_LOAD_DEVICE_CLASS; // simple misc residential on/off loads - bit 7 is set
        MOV.W   #0x80, &loadControlCmd + 4
        MOV.W   #0x0, &loadControlCmd + 6
//  550       zclSE_LoadControl_Send_LoadControlEvent( ESP_ENDPOINT, &loadControlAddr, &loadControlCmd, TRUE, 0 );
        PUSH.B  #0x0
          CFI CFA SP+44
        MOV.B   #0x1, R15
        MOV.W   #loadControlCmd, R14
        MOV.W   #loadControlAddr, R13
        MOV.B   #0x9, R12
        CALLA   #zclSE_LoadControl_Send_LoadControlEvent
        ADD.W   #0x2, SP
          CFI CFA SP+42
//  551     }
//  552 
//  553     if ( keys & HAL_KEY_SW_3 )
??esp_HandleKeys_2:
        BIT.B   #0x10, R10
        JNC     ??esp_HandleKeys_0
//  554     {
//  555       zclCCDisplayMessage_t displayCmd;             // command structure for message being sent to in premise display
//  556 
//  557       // Define to zero to send the TI IPD message, non-zero to send a string of abc's.
//  558 #if   !defined IPD_MSG_SZ
//  559       #define  IPD_MSG_SZ  0
//  560 #endif
//  561 #if   (IPD_MSG_SZ == 0)
//  562       uint8 msgBuf[]="TI IPD Test Msg!";
        MOV.W   SP, R12
        ADD.W   #0x12, R12
        MOV.W   #`?<Constant "TI IPD Test Msg!">`, R14
        MOV.W   #0x11, R13
        CALLA   #?CopyMemoryBytes
//  563       const uint8 msgLen = sizeof(msgBuf);
//  564 #else
//  565       uint8 *msgBuf = osal_mem_alloc(IPD_MSG_SZ);
//  566       const uint8 msgLen = IPD_MSG_SZ;
//  567       uint8 idx;
//  568 
//  569       if (!msgBuf)  return;
//  570 
//  571       for (idx = 0; idx < msgLen; idx ++)
//  572       {
//  573         msgBuf[idx] = 'a' + idx % 26;
//  574       }
//  575 #endif
//  576 
//  577       displayCmd.msgString.strLen = msgLen;
        MOV.B   #0x11, 0xe(SP)
//  578       displayCmd.msgString.pStr = msgBuf;
        MOV.W   SP, R15
        ADD.W   #0x12, R15
        MOV.W   R15, 0x10(SP)
//  579 
//  580       zclSE_Message_Send_DisplayMessage( ESP_ENDPOINT, &ipdAddr, &displayCmd, TRUE, 0 );
        PUSH.B  #0x0
          CFI CFA SP+44
        MOV.B   #0x1, R15
        MOV.W   SP, R14
        ADD.W   #0x2, R14
        MOV.W   #ipdAddr, R13
        MOV.B   #0x9, R12
        CALLA   #zclSE_Message_Send_DisplayMessage
        ADD.W   #0x2, SP
          CFI CFA SP+42
//  581 
//  582 #if   (IPD_MSG_SZ != 0)
//  583       osal_mem_free(msgBuf);
//  584 #endif
//  585     }
//  586 
//  587     if ( keys & HAL_KEY_SW_4 )
//  588     {
//  589 
//  590     }
//  591   }
//  592 }
??esp_HandleKeys_0:
        ADD.W   #0x24, SP
          CFI CFA SP+6
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock11
//  593 
//  594 /*********************************************************************
//  595  * @fn      esp_ValidateAttrDataCB
//  596  *
//  597  * @brief   Check to see if the supplied value for the attribute data
//  598  *          is within the specified range of the attribute.
//  599  *
//  600  *
//  601  * @param   pAttr - pointer to attribute
//  602  * @param   pAttrInfo - pointer to attribute info
//  603  *
//  604  * @return  TRUE if data valid. FALSE otherwise.
//  605  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  606 static uint8 esp_ValidateAttrDataCB( zclAttrRec_t *pAttr, zclWriteRec_t *pAttrInfo )
esp_ValidateAttrDataCB:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function esp_ValidateAttrDataCB
//  607 {
//  608   uint8 valid = TRUE;
        MOV.B   #0x1, R12
//  609 
//  610   switch ( pAttrInfo->dataType )
        CMP.B   #0x10, 0x2(R13)
        JNE     ??esp_ValidateAttrDataCB_0
//  611   {
//  612     case ZCL_DATATYPE_BOOLEAN:
//  613       if ( ( *(pAttrInfo->attrData) != 0 ) && ( *(pAttrInfo->attrData) != 1 ) )
        MOV.W   0x4(R13), R15
        MOV.B   @R15, R14
        CMP.B   #0x0, R14
        JEQ     ??esp_ValidateAttrDataCB_0
        CMP.B   #0x1, R14
        JEQ     ??esp_ValidateAttrDataCB_0
//  614       {
//  615         valid = FALSE;
        MOV.B   #0x0, R12
//  616       }
//  617       break;
//  618 
//  619     default:
//  620       break;
//  621   }
//  622 
//  623   return ( valid );
??esp_ValidateAttrDataCB_0:
        RETA
          CFI EndBlock cfiBlock12
//  624 }
//  625 
//  626 /*********************************************************************
//  627  * @fn      esp_BasicResetCB
//  628  *
//  629  * @brief   Callback from the ZCL General Cluster Library to set all
//  630  *          the attributes of all the clusters to their factory defaults
//  631  *
//  632  * @param   none
//  633  *
//  634  * @return  none
//  635  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  636 static void esp_BasicResetCB( void )
esp_BasicResetCB:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function esp_BasicResetCB
//  637 {
//  638   // user should handle setting attributes to factory defaults here
//  639 }
        RETA
          CFI EndBlock cfiBlock13
//  640 
//  641 /*********************************************************************
//  642  * @fn      esp_IdentifyCB
//  643  *
//  644  * @brief   Callback from the ZCL General Cluster Library when
//  645  *          it received an Identify Command for this application.
//  646  *
//  647  * @param   pCmd - pointer to structure for identify command
//  648  *
//  649  * @return  none
//  650  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  651 static void esp_IdentifyCB( zclIdentify_t *pCmd )
esp_IdentifyCB:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function esp_IdentifyCB
//  652 {
//  653   espIdentifyTime = pCmd->identifyTime;
        FUNCALL esp_IdentifyCB, esp_ProcessIdentifyTimeChange
        LOCFRAME CSTACK, 4, STACK
        MOV.W   0x2(R12), &espIdentifyTime
//  654   esp_ProcessIdentifyTimeChange();
        BRA     #esp_ProcessIdentifyTimeChange
          CFI EndBlock cfiBlock14
//  655 }
//  656 
//  657 /*********************************************************************
//  658  * @fn      esp_IdentifyQueryRspCB
//  659  *
//  660  * @brief   Callback from the ZCL General Cluster Library when
//  661  *          it received an Identity Query Response Command for this application.
//  662  *
//  663  * @param   pRsp - pointer to structure for identify query response
//  664  *
//  665  * @return  none
//  666  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  667 static void esp_IdentifyQueryRspCB( zclIdentifyQueryRsp_t *pRsp )
esp_IdentifyQueryRspCB:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function esp_IdentifyQueryRspCB
//  668 {
//  669   // add user code here
//  670 }
        RETA
          CFI EndBlock cfiBlock15
//  671 
//  672 /*********************************************************************
//  673  * @fn      esp_AlarmCB
//  674  *
//  675  * @brief   Callback from the ZCL General Cluster Library when
//  676  *          it received an Alam request or response command for
//  677  *          this application.
//  678  *
//  679  * @param   pAlarm - pointer to structure for alarm command
//  680  *
//  681  * @return  none
//  682  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  683 static void esp_AlarmCB( zclAlarm_t *pAlarm )
esp_AlarmCB:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function esp_AlarmCB
//  684 {
//  685   // add user code here
//  686 }
        RETA
          CFI EndBlock cfiBlock16
//  687 
//  688 /*********************************************************************
//  689  * @fn      esp_GetProfileCmdCB
//  690  *
//  691  * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
//  692  *          it received a Get Profile Command for
//  693  *          this application.
//  694  *
//  695  * @param   pCmd - pointer to get profile command structure
//  696  * @param   srcAddr - pointer to source address
//  697  * @param   seqNum - sequence number of this command
//  698  *
//  699  * @return  none
//  700  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  701 static void esp_GetProfileCmdCB( zclCCGetProfileCmd_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
esp_GetProfileCmdCB:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function esp_GetProfileCmdCB
//  702 {
        FUNCALL esp_GetProfileCmdCB, zclSE_SimpleMetering_Send_GetProfileRsp
        LOCFRAME CSTACK, 40, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0x14, SP
          CFI CFA SP+28
        MOV.W   R12, R10
        MOV.W   R13, R11
        MOV.B   R14, R15
//  703 #if defined ( ZCL_SIMPLE_METERING )
//  704   // Upon receipt of the Get Profile Command, the metering device shall send
//  705   // Get Profile Response back.
//  706 
//  707   // Variables in the following are initialized to arbitrary value for test purpose
//  708   // In real application, user shall look up the interval data captured during
//  709   // the period specified in the pCmd->endTime and return corresponding data.
//  710 
//  711   uint32 endTime;
//  712   uint8  status = zclSE_SimpleMeter_GetProfileRsp_Status_Success;
//  713   uint8  profileIntervalPeriod = PROFILE_INTERVAL_PERIOD_60MIN;
//  714   uint8  numberOfPeriodDelivered = 5;
//  715   uint24 intervals[] = {0xa00001, 0xa00002, 0xa00003, 0xa00004, 0xa00005};
        MOV.W   SP, R12
        MOV.W   #`?<Constant {10485761L, 10485762L, 10485763L, 1`, R14
        MOV.W   #0xa, R13
        CALLA   #?CopyMemoryWords
//  716 
//  717   // endTime: 32 bit value (in UTC) representing the end time of the most
//  718   // chronologically recent interval being requested.
//  719   // Example: Data collected from 2:00 PM to 3:00 PM would be specified as a
//  720   // 3:00 PM interval (end time).
//  721 
//  722   // The Intervals block returned shall be the most recent block with
//  723   // its EndTime equal or older to the one in the request (pCmd->endTime).
//  724   // Requested End Time with value 0xFFFFFFFF indicats the most recent
//  725   // Intervals block is requested.
//  726 
//  727   // Sample Code - assuming the end time of the requested block is the same as
//  728   // it in the request.
//  729   endTime = pCmd->endTime;
//  730 
//  731   // Send Get Profile Response Command back
//  732 
//  733   zclSE_SimpleMetering_Send_GetProfileRsp( ESP_ENDPOINT, srcAddr, endTime,
//  734                                            status,
//  735                                            profileIntervalPeriod,
//  736                                            numberOfPeriodDelivered, intervals,
//  737                                            FALSE, seqNum );
        PUSH.B  R15
          CFI CFA SP+30
        PUSH.B  #0x0
          CFI CFA SP+32
        MOV.W   SP, R15
        ADD.W   #0x4, R15
        PUSH.W  R15
          CFI CFA SP+34
        PUSH.B  #0x5
          CFI CFA SP+36
        PUSH.B  #0x1
          CFI CFA SP+38
        PUSH.B  #0x0
          CFI CFA SP+40
        MOV.W   0x2(R10), R14
        MOV.W   0x4(R10), R15
        MOV.W   R11, R13
        MOV.B   #0x9, R12
        CALLA   #zclSE_SimpleMetering_Send_GetProfileRsp
//  738 #endif // ZCL_SIMPLE_METERING
//  739 }
        ADD.W   #0x20, SP
          CFI CFA SP+8
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock17
//  740 
//  741 /*********************************************************************
//  742  * @fn      esp_GetProfileRspCB
//  743  *
//  744  * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
//  745  *          it received a Get Profile Response for
//  746  *          this application.
//  747  *
//  748  * @param   pCmd - pointer to get profile response structure
//  749  * @param   srcAddr - pointer to source address
//  750  * @param   seqNum - sequence number of this command
//  751  *
//  752  * @return  none
//  753  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  754 static void esp_GetProfileRspCB( zclCCGetProfileRsp_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
esp_GetProfileRspCB:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function esp_GetProfileRspCB
//  755 {
//  756   // add user code here
//  757 }
        RETA
          CFI EndBlock cfiBlock18
//  758 
//  759 /*********************************************************************
//  760  * @fn      esp_ReqMirrorCmdCB
//  761  *
//  762  * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
//  763  *          it received a Request Mirror Command for
//  764  *          this application.
//  765  *
//  766  * @param   srcAddr - pointer to source address
//  767  * @param   seqNum - sequence number of this command
//  768  *
//  769  * @return  none
//  770  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  771 static void esp_ReqMirrorCmdCB( afAddrType_t *srcAddr, uint8 seqNum )
esp_ReqMirrorCmdCB:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function esp_ReqMirrorCmdCB
//  772 {
//  773   // add user code here
//  774 }
        RETA
          CFI EndBlock cfiBlock19
//  775 /*********************************************************************
//  776  * @fn      esp_ReqMirrorRspCB
//  777  *
//  778  * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
//  779  *          it received a Request Mirror Response for
//  780  *          this application.
//  781  *
//  782  * @param   pRsp - pointer to request mirror response structure
//  783  * @param   srcAddr - pointer to source address
//  784  * @param   seqNum - sequence number of this command
//  785  *
//  786  * @return  none
//  787  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  788 static void esp_ReqMirrorRspCB( zclCCReqMirrorRsp_t *pRsp, afAddrType_t *srcAddr, uint8 seqNum )
esp_ReqMirrorRspCB:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function esp_ReqMirrorRspCB
//  789 {
//  790   // add user code here
//  791 }
        RETA
          CFI EndBlock cfiBlock20
//  792 /*********************************************************************
//  793  * @fn      esp_MirrorRemCmdCB
//  794  *
//  795  * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
//  796  *          it received a Mirror Remove Command for
//  797  *          this application.
//  798  *
//  799  * @param   srcAddr - pointer to source address
//  800  * @param   seqNum - sequence number of this command
//  801  *
//  802  * @return  none
//  803  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  804 static void esp_MirrorRemCmdCB( afAddrType_t *srcAddr, uint8 seqNum )
esp_MirrorRemCmdCB:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function esp_MirrorRemCmdCB
//  805 {
//  806   // add user code here
//  807 }
        RETA
          CFI EndBlock cfiBlock21
//  808 /*********************************************************************
//  809  * @fn      esp_MirrorRemRspCB
//  810  *
//  811  * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
//  812  *          it received a Mirror Remove Response for
//  813  *          this application.
//  814  *
//  815  * @param   pCmd - pointer to mirror remove response structure
//  816  * @param   srcAddr - pointer to source address
//  817  * @param   seqNum - sequence number of this command
//  818  *
//  819  * @return  none
//  820  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  821 static void esp_MirrorRemRspCB( zclCCMirrorRemRsp_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
esp_MirrorRemRspCB:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function esp_MirrorRemRspCB
//  822 {
//  823   // add user code here
//  824 }
        RETA
          CFI EndBlock cfiBlock22
//  825 
//  826 /*********************************************************************
//  827  * @fn      esp_ReqFastPollModeCmdCB
//  828  *
//  829  * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
//  830  *          it received a Request Fast Poll Mode Command for
//  831  *          this application.
//  832  *
//  833  * @param   pCmd - pointer to Request Fast Poll Mode Command structure
//  834  * @param   srcAddr - pointer to source address
//  835  * @param   seqNum - sequence number of this command
//  836  *
//  837  * @return  none
//  838  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  839 static void esp_ReqFastPollModeCmdCB( zclCCReqFastPollModeCmd_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum )
esp_ReqFastPollModeCmdCB:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function esp_ReqFastPollModeCmdCB
//  840 {
        FUNCALL esp_ReqFastPollModeCmdCB, osal_start_timerEx
        LOCFRAME CSTACK, 18, STACK
        FUNCALL esp_ReqFastPollModeCmdCB, osal_getClock
        LOCFRAME CSTACK, 18, STACK
        FUNCALL esp_ReqFastPollModeCmdCB, zclSE_SimpleMetering_Send_ReqFastPollModeRsp
        LOCFRAME CSTACK, 20, STACK
        FUNCALL esp_ReqFastPollModeCmdCB, HalLcdWriteString
        LOCFRAME CSTACK, 20, STACK
        FUNCALL esp_ReqFastPollModeCmdCB, HalLcdWriteStringValue
        LOCFRAME CSTACK, 20, STACK
        FUNCALL esp_ReqFastPollModeCmdCB, HalLcdWriteStringValue
        LOCFRAME CSTACK, 20, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x6, SP
          CFI CFA SP+18
        MOV.W   R13, R8
        MOV.B   R14, R9
//  841 #if defined ( ZCL_SIMPLE_METERING )
//  842   if ( pCmd != NULL )
        CMP.W   #0x0, R12
        JEQ     ??esp_ReqFastPollModeCmdCB_1
//  843   {
//  844     zclCCReqFastPollModeRsp_t fastPollRsp;
//  845     UTCTime utcSecs;
//  846 
//  847     if (pCmd->fastPollUpdatePeriod < espFastPollUpdatePeriod)
        MOV.B   &espFastPollUpdatePeriod, R14
        MOV.B   @R12, R15
        CMP.B   R14, R15
        JC      ??esp_ReqFastPollModeCmdCB_2
//  848     {
//  849       // handles client requests for a fast poll rate that is less than the
//  850       // value of the its FastPollUpdateRate attribute
//  851       fastPollRsp.appliedUpdatePeriod = espFastPollUpdatePeriod;
        MOV.B   R14, 0(SP)
        JMP     ??esp_ReqFastPollModeCmdCB_3
//  852     }
//  853     else
//  854     {
//  855       fastPollRsp.appliedUpdatePeriod = pCmd->fastPollUpdatePeriod;
??esp_ReqFastPollModeCmdCB_2:
        MOV.B   R15, 0(SP)
//  856     }
//  857 
//  858     if ((espFastPollModeDuration == 0) && (pCmd->duration > 0))
??esp_ReqFastPollModeCmdCB_3:
        CMP.W   #0x0, &espFastPollModeDuration
        JNE     ??esp_ReqFastPollModeCmdCB_4
        MOV.B   0x1(R12), R15
        CMP.B   #0x0, R15
        JEQ     ??esp_ReqFastPollModeCmdCB_4
//  859     {
//  860       if (pCmd->duration > MAX_DURATION_IN_MINUTES_FAST_POLL_MODE)
        CMP.B   #0x10, R15
        JNC     ??esp_ReqFastPollModeCmdCB_0
//  861       {
//  862         // handles client requests for duration that is greater than the
//  863         // maximum allowable 15 minutes.
//  864         espFastPollModeDuration = MAX_DURATION_IN_MINUTES_FAST_POLL_MODE;
        MOV.W   #0xf, R15
//  865       }
//  866       else
//  867       {
//  868         espFastPollModeDuration = pCmd->duration;
//  869       }
//  870 
//  871       // This controls the counter for ZCLTESTAPP_FAST_POLL_MODE_EVT based on a 1 second timer
//  872       espFastPollModeDuration *= 60;  // Duration in seconds
??esp_ReqFastPollModeCmdCB_0:
        RLAM.W  #0x2, R15
        MOV.W   R15, R11
        RLA.W   R15
        ADD.W   R15, R11
        RLA.W   R15
        ADD.W   R15, R11
        RLA.W   R15
        ADD.W   R11, R15
        MOV.W   R15, &espFastPollModeDuration
//  873 
//  874       // Start the timer for the fast poll period
//  875       osal_start_timerEx( espTaskID, ESP_FAST_POLL_MODE_EVT, ESP_FAST_POLL_TIMER_PERIOD );
        CALLA   #?Subroutine3
//  876     }
//  877 
//  878     // get UTC time and update with requested duration in seconds
//  879     utcSecs = osal_getClock();
??esp_ReqFastPollModeCmdCB_4:
        CALLA   #osal_getClock
        MOV.W   R12, R10
//  880     fastPollRsp.fastPollModeEndTime = utcSecs + espFastPollModeDuration;
        MOV.W   &espFastPollModeDuration, R14
        ADD.W   R14, R12
        ADDC.W  #0x0, R13
        MOV.W   R12, 0x2(SP)
        MOV.W   R13, 0x4(SP)
//  881 
//  882     zclSE_SimpleMetering_Send_ReqFastPollModeRsp( ESP_ENDPOINT, srcAddr,
//  883                                                   &fastPollRsp,
//  884                                                   TRUE, seqNum );
        PUSH.B  R9
          CFI CFA SP+20
        MOV.B   #0x1, R15
        MOV.W   SP, R14
        ADD.W   #0x2, R14
        MOV.W   R8, R13
        MOV.B   #0x9, R12
        CALLA   #zclSE_SimpleMetering_Send_ReqFastPollModeRsp
//  885 
//  886 #if defined ( LCD_SUPPORTED )
//  887     HalLcdWriteString("Fast Polling", HAL_LCD_LINE_1);
        MOV.B   #0x1, R13
        MOV.W   #`?<Constant "Fast Polling">`, R12
        CALLA   #HalLcdWriteString
//  888     HalLcdWriteStringValue("Cur 0x", utcSecs, 16, HAL_LCD_LINE_2 );
        MOV.B   #0x2, R15
        MOV.B   #0x10, R14
        MOV.W   R10, R13
        MOV.W   #`?<Constant "Cur 0x">`, R12
        CALLA   #HalLcdWriteStringValue
//  889     HalLcdWriteStringValue("End 0x", fastPollRsp.fastPollModeEndTime, 16, HAL_LCD_LINE_3 );
        MOV.B   #0x3, R15
        MOV.B   #0x10, R14
        MOV.W   0x4(SP), R13
        MOV.W   #`?<Constant "End 0x">`, R12
        CALLA   #HalLcdWriteStringValue
        ADD.W   #0x2, SP
          CFI CFA SP+18
//  890 #endif
//  891   }
//  892 #endif // ZCL_SIMPLE_METERING
//  893 }
??esp_ReqFastPollModeCmdCB_1:
        ADD.W   #0x6, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock23
//  894 
//  895 /*********************************************************************
//  896  * @fn      esp_ReqFastPollModeRspCB
//  897  *
//  898  * @brief   Callback from the ZCL SE Profile Simple Metering Cluster Library when
//  899  *          it received a Request Fast Poll Mode Response for
//  900  *          this application.
//  901  *
//  902  * @param   pCmd - pointer to Request Fast Poll Mode response structure
//  903  * @param   srcAddr - pointer to source address
//  904  * @param   seqNum - sequence number of this command
//  905  *
//  906  * @return  none
//  907  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  908 static void esp_ReqFastPollModeRspCB( zclCCReqFastPollModeRsp_t *pRsp, afAddrType_t *srcAddr, uint8 seqNum )
esp_ReqFastPollModeRspCB:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function esp_ReqFastPollModeRspCB
//  909 {
//  910   // add user code here
//  911 }
        RETA
          CFI EndBlock cfiBlock24
//  912 
//  913 /*********************************************************************
//  914  * @fn      esp_GetCurrentPriceCB
//  915  *
//  916  * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
//  917  *          it received a Get Current Price for
//  918  *          this application.
//  919  *
//  920  * @param   pCmd - pointer to structure for Get Current Price command
//  921  * @param   srcAddr - source address
//  922  * @param   seqNum - sequence number for this command
//  923  *
//  924  * @return  none
//  925  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  926 static void esp_GetCurrentPriceCB( zclCCGetCurrentPrice_t *pCmd,
esp_GetCurrentPriceCB:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function esp_GetCurrentPriceCB
//  927                                          afAddrType_t *srcAddr, uint8 seqNum )
//  928 {
        FUNCALL esp_GetCurrentPriceCB, osal_memset
        LOCFRAME CSTACK, 56, STACK
        FUNCALL esp_GetCurrentPriceCB, osal_mem_alloc
        LOCFRAME CSTACK, 56, STACK
        FUNCALL esp_GetCurrentPriceCB, osal_memcpy
        LOCFRAME CSTACK, 56, STACK
        FUNCALL esp_GetCurrentPriceCB, osal_getClock
        LOCFRAME CSTACK, 56, STACK
        FUNCALL esp_GetCurrentPriceCB, osal_memcpy
        LOCFRAME CSTACK, 56, STACK
        FUNCALL esp_GetCurrentPriceCB, zclSE_Pricing_Send_PublishPrice
        LOCFRAME CSTACK, 58, STACK
        FUNCALL esp_GetCurrentPriceCB, osal_mem_free
        LOCFRAME CSTACK, 56, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0x30, SP
          CFI CFA SP+56
        MOV.W   R13, R11
        MOV.B   R14, R10
//  929 #if defined ( ZCL_PRICING )
//  930   // On receipt of Get Current Price command, the device shall send a
//  931   // Publish Price command with the information for the current time.
//  932   zclCCPublishPrice_t cmd;
//  933   uint8 rateLabelLen = 4; // adjust this value if different label is set, test label "BASE"
//  934 
//  935   osal_memset( &cmd, 0, sizeof( zclCCPublishPrice_t ) );
        MOV.W   #0x30, R14
        MOV.B   #0x0, R13
        MOV.W   SP, R12
        CALLA   #?Subroutine5
//  936 
//  937   // Set Pricing information
//  938   cmd.providerId = 0xbabeface;
//  939   cmd.rateLabel.pStr = (uint8 *)osal_mem_alloc(rateLabelLen);
??CrossCallReturnLabel_8:
        MOV.W   #0x4, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, 0x6(SP)
//  940   if (cmd.rateLabel.pStr != NULL)
        CMP.W   #0x0, R12
        JEQ     ??esp_GetCurrentPriceCB_1
//  941   {
//  942     cmd.rateLabel.strLen = rateLabelLen;
        MOV.B   #0x4, 0x4(SP)
//  943     osal_memcpy(cmd.rateLabel.pStr, "BASE", rateLabelLen);
        MOV.W   #0x4, R14
        MOV.W   #`?<Constant "BASE">`, R13
        MOV.W   0x6(SP), R12
        CALLA   #osal_memcpy
//  944   }
//  945   cmd.issuerEventId = 0x00000000;
??esp_GetCurrentPriceCB_1:
        MOV.W   #0x0, 0x8(SP)
        MOV.W   #0x0, 0xa(SP)
//  946   cmd.currentTime = osal_getClock();
        CALLA   #osal_getClock
        MOV.W   R12, 0xc(SP)
        MOV.W   R13, 0xe(SP)
//  947   cmd.unitOfMeasure = 0x00;
        MOV.B   #0x0, 0x10(SP)
//  948   cmd.currency = 0x0348;
        MOV.W   #0x348, 0x12(SP)
//  949   cmd.priceTrailingDigit = 0x11;
        MOV.B   #0x11, 0x14(SP)
//  950   cmd.numberOfPriceTiers = 0x21;
        MOV.B   #0x21, 0x15(SP)
//  951   cmd.startTime = 0x00000000;
        MOV.W   #0x0, 0x16(SP)
        MOV.W   #0x0, 0x18(SP)
//  952   cmd.durationInMinutes = 0x003C;
        MOV.W   #0x3c, 0x1a(SP)
//  953   cmd.price = 0x00000018;
        MOV.W   #0x18, 0x1c(SP)
        MOV.W   #0x0, 0x1e(SP)
//  954   cmd.priceRatio = SE_OPTIONAL_FIELD_UINT8;
        MOV.B   #0xff, 0x20(SP)
//  955   cmd.generationPrice = SE_OPTIONAL_FIELD_UINT32;
        MOV.W   #0xffff, 0x22(SP)
        MOV.W   #0xffff, 0x24(SP)
//  956   cmd.generationPriceRatio = SE_OPTIONAL_FIELD_UINT8;
        MOV.B   #0xff, 0x26(SP)
//  957   cmd.alternateCostDelivered = SE_OPTIONAL_FIELD_UINT32;
        MOV.W   #0xffff, 0x28(SP)
        MOV.W   #0xffff, 0x2a(SP)
//  958   cmd.alternateCostUnit = SE_OPTIONAL_FIELD_UINT8;
        MOV.B   #0xff, 0x2c(SP)
//  959   cmd.alternateCostTrailingDigit = SE_OPTIONAL_FIELD_UINT8;
        MOV.B   #0xff, 0x2d(SP)
//  960   cmd.numberOfBlockThresholds = SE_OPTIONAL_FIELD_UINT8;
        MOV.B   #0xff, 0x2e(SP)
//  961   cmd.priceControl = SE_PROFILE_PRICEACK_REQUIRED_MASK;
        MOV.B   #0x1, 0x2f(SP)
//  962 
//  963   // copy source address of display device that requested current pricing info so
//  964   // that esp can send messages to it using destination address of IPDAddr
//  965   osal_memcpy( &ipdAddr, srcAddr, sizeof ( afAddrType_t ) );
        MOV.W   #0xc, R14
        MOV.W   R11, R13
        MOV.W   #ipdAddr, R12
        CALLA   #osal_memcpy
//  966 
//  967   zclSE_Pricing_Send_PublishPrice( ESP_ENDPOINT, srcAddr, &cmd, FALSE, seqNum );
        PUSH.B  R10
          CFI CFA SP+58
        CALLA   #?Subroutine4
//  968 
//  969   if (cmd.rateLabel.pStr != NULL)
??CrossCallReturnLabel_5:
        MOV.W   0x8(SP), R12
        ADD.W   #0x2, SP
          CFI CFA SP+56
        CALLA   #?Subroutine2
//  970   {
//  971     osal_mem_free(cmd.rateLabel.pStr);
//  972   }
//  973 #endif // ZCL_PRICING
//  974 }
??CrossCallReturnLabel_4:
        ADD.W   #0x30, SP
          CFI CFA SP+8
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock25

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine5:
          CFI Block cfiCond26 Using cfiCommon0
          CFI Function esp_GetScheduledPriceCB
          CFI Conditional ??CrossCallReturnLabel_7
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+60
          CFI Block cfiCond27 Using cfiCommon0
          CFI (cfiCond27) Function esp_GetCurrentPriceCB
          CFI (cfiCond27) Conditional ??CrossCallReturnLabel_8
          CFI (cfiCond27) R10L Frame(CFA, -8)
          CFI (cfiCond27) R11L Frame(CFA, -6)
          CFI (cfiCond27) CFA SP+60
          CFI Block cfiPicker28 Using cfiCommon1
          CFI (cfiPicker28) NoFunction
          CFI (cfiPicker28) Picker
        CALLA   #osal_memset
        MOV.W   #0xface, 0x4(SP)
        MOV.W   #0xbabe, 0x6(SP)
        RETA
          CFI EndBlock cfiCond26
          CFI EndBlock cfiCond27
          CFI EndBlock cfiPicker28

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine4:
          CFI Block cfiCond29 Using cfiCommon0
          CFI Function esp_GetScheduledPriceCB
          CFI Conditional ??CrossCallReturnLabel_6
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+62
          CFI Block cfiCond30 Using cfiCommon0
          CFI (cfiCond30) Function esp_GetCurrentPriceCB
          CFI (cfiCond30) Conditional ??CrossCallReturnLabel_5
          CFI (cfiCond30) R10L Frame(CFA, -8)
          CFI (cfiCond30) R11L Frame(CFA, -6)
          CFI (cfiCond30) CFA SP+62
          CFI Block cfiPicker31 Using cfiCommon1
          CFI (cfiPicker31) NoFunction
          CFI (cfiPicker31) Picker
        MOV.B   #0x0, R15
        MOV.W   SP, R14
        ADD.W   #0x6, R14
        MOV.W   R11, R13
        MOV.B   #0x9, R12
        BRA     #zclSE_Pricing_Send_PublishPrice
          CFI EndBlock cfiCond29
          CFI EndBlock cfiCond30
          CFI EndBlock cfiPicker31

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine2:
          CFI Block cfiCond32 Using cfiCommon0
          CFI Function esp_ProcessZDOMsg
          CFI Conditional ??CrossCallReturnLabel_2
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+24
          CFI Block cfiCond33 Using cfiCommon0
          CFI (cfiCond33) Function esp_ProcessZDOMsg
          CFI (cfiCond33) Conditional ??CrossCallReturnLabel_3
          CFI (cfiCond33) R10L Frame(CFA, -8)
          CFI (cfiCond33) R11L Frame(CFA, -6)
          CFI (cfiCond33) CFA SP+24
          CFI Block cfiCond34 Using cfiCommon0
          CFI (cfiCond34) Function esp_GetCurrentPriceCB
          CFI (cfiCond34) Conditional ??CrossCallReturnLabel_4
          CFI (cfiCond34) R10L Frame(CFA, -8)
          CFI (cfiCond34) R11L Frame(CFA, -6)
          CFI (cfiCond34) CFA SP+60
          CFI Block cfiPicker35 Using cfiCommon1
          CFI (cfiPicker35) NoFunction
          CFI (cfiPicker35) Picker
        CMP.W   #0x0, R12
        JEQ     ??esp_ProcessZDOMsg_0
        CALLA   #osal_mem_free
??esp_ProcessZDOMsg_0:
        RETA
          CFI EndBlock cfiCond32
          CFI EndBlock cfiCond33
          CFI EndBlock cfiCond34
          CFI EndBlock cfiPicker35
//  975 
//  976 /*********************************************************************
//  977  * @fn      esp_GetScheduledPriceCB
//  978  *
//  979  * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
//  980  *          it received a Get Scheduled Price for
//  981  *          this application.
//  982  *
//  983  * @param   pCmd - pointer to structure for Get Scheduled Price command
//  984  * @param   srcAddr - source address
//  985  * @param   seqNum - sequence number for this command
//  986  *
//  987  * @return  none
//  988  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
//  989 static void esp_GetScheduledPriceCB( zclCCGetScheduledPrice_t *pCmd, afAddrType_t *srcAddr, uint8 seqNum  )
esp_GetScheduledPriceCB:
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function esp_GetScheduledPriceCB
//  990 {
        FUNCALL esp_GetScheduledPriceCB, osal_memset
        LOCFRAME CSTACK, 56, STACK
        FUNCALL esp_GetScheduledPriceCB, zclSE_Pricing_Send_PublishPrice
        LOCFRAME CSTACK, 58, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0x30, SP
          CFI CFA SP+56
        MOV.W   R13, R11
        MOV.B   R14, R10
//  991   // On receipt of Get Scheduled Price command, the device shall send a
//  992   // Publish Price command for all currently scheduled price events.
//  993   // The sample code as follows only sends one.
//  994 
//  995 #if defined ( ZCL_PRICING )
//  996   zclCCPublishPrice_t cmd;
//  997 
//  998   osal_memset( &cmd, 0, sizeof( zclCCPublishPrice_t ) );
        MOV.W   #0x30, R14
        MOV.B   #0x0, R13
        MOV.W   SP, R12
        CALLA   #?Subroutine5
//  999 
// 1000   cmd.providerId = 0xbabeface;
// 1001   cmd.numberOfPriceTiers = 0xfe;
??CrossCallReturnLabel_7:
        MOV.B   #0xfe, 0x15(SP)
// 1002 
// 1003   zclSE_Pricing_Send_PublishPrice( ESP_ENDPOINT, srcAddr, &cmd, FALSE, seqNum );
        PUSH.B  R10
          CFI CFA SP+58
        CALLA   #?Subroutine4
// 1004 
// 1005 #endif // ZCL_PRICING
// 1006 }
??CrossCallReturnLabel_6:
        ADD.W   #0x32, SP
          CFI CFA SP+8
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock36
// 1007 
// 1008 /*********************************************************************
// 1009  * @fn      esp_PriceAcknowledgementCB
// 1010  *
// 1011  * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
// 1012  *          it received a Price Acknowledgement for this application.
// 1013  *
// 1014  * @param   pCmd - pointer to structure for Publish Price command
// 1015  * @param   srcAddr - source address
// 1016  * @param   seqNum - sequence number for this command
// 1017  *
// 1018  * @return  none
// 1019  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1020 static void esp_PriceAcknowledgementCB( zclCCPriceAcknowledgement_t *pCmd,
esp_PriceAcknowledgementCB:
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function esp_PriceAcknowledgementCB
// 1021                                       afAddrType_t *srcAddr, uint8 seqNum )
// 1022 {
// 1023   // add user code here
// 1024 }
        RETA
          CFI EndBlock cfiBlock37
// 1025 
// 1026 /*********************************************************************
// 1027  * @fn      esp_GetBlockPeriodCB
// 1028  *
// 1029  * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
// 1030  *          it received a Get Block Period for this application.
// 1031  *
// 1032  * @param   pCmd - pointer to structure for Get Block Period command
// 1033  * @param   srcAddr - source address
// 1034  * @param   seqNum - sequence number for this command
// 1035  *
// 1036  * @return  none
// 1037  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1038 static void esp_GetBlockPeriodCB( zclCCGetBlockPeriod_t *pCmd,
esp_GetBlockPeriodCB:
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function esp_GetBlockPeriodCB
// 1039                                   afAddrType_t *srcAddr, uint8 seqNum )
// 1040 {
// 1041   // add user code here
// 1042 }
        RETA
          CFI EndBlock cfiBlock38
// 1043 
// 1044 /*********************************************************************
// 1045  * @fn      esp_PublishPriceCB
// 1046  *
// 1047  * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
// 1048  *          it received a Publish Price for this application.
// 1049  *
// 1050  * @param   pCmd - pointer to structure for Publish Price command
// 1051  * @param   srcAddr - source address
// 1052  * @param   seqNum - sequence number for this command
// 1053  *
// 1054  * @return  none
// 1055  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1056 static void esp_PublishPriceCB( zclCCPublishPrice_t *pCmd,
esp_PublishPriceCB:
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function esp_PublishPriceCB
// 1057                                       afAddrType_t *srcAddr, uint8 seqNum )
// 1058 {
// 1059   // add user code here
// 1060 }
        RETA
          CFI EndBlock cfiBlock39
// 1061 
// 1062 /*********************************************************************
// 1063  * @fn      esp_PublishBlockPeriodCB
// 1064  *
// 1065  * @brief   Callback from the ZCL SE Profile Pricing Cluster Library when
// 1066  *          it received a Publish Block Period for this application.
// 1067  *
// 1068  * @param   pCmd - pointer to structure for Get Block Period command
// 1069  * @param   srcAddr - source address
// 1070  * @param   seqNum - sequence number for this command
// 1071  *
// 1072  * @return  none
// 1073  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1074 static void esp_PublishBlockPeriodCB( zclCCPublishBlockPeriod_t *pCmd,
esp_PublishBlockPeriodCB:
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function esp_PublishBlockPeriodCB
// 1075                                       afAddrType_t *srcAddr, uint8 seqNum )
// 1076 {
// 1077   // add user code here
// 1078 }
        RETA
          CFI EndBlock cfiBlock40
// 1079 
// 1080 /*********************************************************************
// 1081  * @fn      esp_DisplayMessageCB
// 1082  *
// 1083  * @brief   Callback from the ZCL SE Profile Message Cluster Library when
// 1084  *          it received a Display Message Command for
// 1085  *          this application.
// 1086  *
// 1087  * @param   pCmd - pointer to structure for Display Message command
// 1088  * @param   srcAddr - source address
// 1089  * @param   seqNum - sequence number for this command
// 1090  *
// 1091  * @return  none
// 1092  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1093 static void esp_DisplayMessageCB( zclCCDisplayMessage_t *pCmd,
esp_DisplayMessageCB:
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function esp_DisplayMessageCB
// 1094                                         afAddrType_t *srcAddr, uint8 seqNum )
// 1095 {
// 1096   // Upon receipt of the Display Message Command, the device shall
// 1097   // display the message. If the Message Confirmation bit indicates
// 1098   // the message originator require a confirmation of receipt from
// 1099   // a Utility Customer, the device should display the message or
// 1100   // alert the user until it is either confirmed via a button or by
// 1101   // selecting a confirmation option on the device.  Confirmation is
// 1102   // typically used when the Utility is sending down information
// 1103   // such as a disconnection notice, or prepaid billing information.
// 1104   // Message duration is ignored when confirmation is requested and
// 1105   // the message is displayed until confirmed.
// 1106 
// 1107 #if defined ( LCD_SUPPORTED )
// 1108     HalLcdWriteString( (char*)pCmd->msgString.pStr, HAL_LCD_LINE_1 );
        FUNCALL esp_DisplayMessageCB, HalLcdWriteString
        LOCFRAME CSTACK, 4, STACK
        MOV.B   #0x1, R13
        MOV.W   0x10(R12), R12
        BRA     #HalLcdWriteString
          CFI EndBlock cfiBlock41
// 1109 #endif // LCD_SUPPORTED
// 1110 }
// 1111 
// 1112 /*********************************************************************
// 1113  * @fn      esp_CancelMessageCB
// 1114  *
// 1115  * @brief   Callback from the ZCL SE Profile Message Cluster Library when
// 1116  *          it received a Cancel Message Command for
// 1117  *          this application.
// 1118  *
// 1119  * @param   pCmd - pointer to structure for Cancel Message command
// 1120  * @param   srcAddr - source address
// 1121  * @param   seqNum - sequence number for this command
// 1122  *
// 1123  * @return  none
// 1124  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1125 static void esp_CancelMessageCB( zclCCCancelMessage_t *pCmd,
esp_CancelMessageCB:
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function esp_CancelMessageCB
// 1126                                         afAddrType_t *srcAddr, uint8 seqNum )
// 1127 {
// 1128   // add user code here
// 1129 }
        RETA
          CFI EndBlock cfiBlock42
// 1130 
// 1131 /*********************************************************************
// 1132  * @fn      esp_GetLastMessageCB
// 1133  *
// 1134  * @brief   Callback from the ZCL SE Profile Message Cluster Library when
// 1135  *          it received a Get Last Message Command for
// 1136  *          this application.
// 1137  *
// 1138  * @param   pCmd - pointer to structure for Get Last Message command
// 1139  * @param   srcAddr - source address
// 1140  * @param   seqNum - sequence number for this command
// 1141  *
// 1142  * @return  none
// 1143  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1144 static void esp_GetLastMessageCB( afAddrType_t *srcAddr, uint8 seqNum )
esp_GetLastMessageCB:
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function esp_GetLastMessageCB
// 1145 {
        FUNCALL esp_GetLastMessageCB, zclSE_Message_Send_DisplayMessage
        LOCFRAME CSTACK, 36, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        SUB.W   #0x1c, SP
          CFI CFA SP+34
        MOV.W   R12, R10
        MOV.B   R13, R15
// 1146   // On receipt of Get Last Message command, the device shall send a
// 1147   // Display Message command back to the sender
// 1148 
// 1149 #if defined ( ZCL_MESSAGE )
// 1150   zclCCDisplayMessage_t cmd;
// 1151   uint8 msg[10] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29 };
        MOV.W   SP, R12
        ADD.W   #0x12, R12
        MOV.W   #`?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40`, R14
        MOV.W   #0xa, R13
        CALLA   #?CopyMemoryBytes
// 1152 
// 1153   // Fill in the command with information for the last message
// 1154   cmd.messageId = 0xaabbccdd;
        MOV.W   #0xccdd, 0(SP)
        MOV.W   #0xaabb, 0x2(SP)
// 1155   cmd.messageCtrl.transmissionMode = 0;
        MOV.B   #0x0, 0x4(SP)
// 1156   cmd.messageCtrl.importance = 1;
        MOV.B   #0x1, 0x5(SP)
// 1157   cmd.messageCtrl.confirmationRequired = 1;
        MOV.B   #0x1, 0x6(SP)
// 1158   cmd.durationInMinutes = 60;
        MOV.W   #0x3c, 0xc(SP)
// 1159 
// 1160   cmd.msgString.strLen = 10;
        MOV.B   #0xa, 0xe(SP)
// 1161   cmd.msgString.pStr = msg;
        MOV.W   SP, R14
        ADD.W   #0x12, R14
        MOV.W   R14, 0x10(SP)
// 1162 
// 1163   zclSE_Message_Send_DisplayMessage( ESP_ENDPOINT, srcAddr, &cmd,
// 1164                                      FALSE, seqNum );
        PUSH.B  R15
          CFI CFA SP+36
        MOV.B   #0x0, R15
        ADD.W   #0xffee, R14
        MOV.W   R10, R13
        MOV.B   #0x9, R12
        CALLA   #zclSE_Message_Send_DisplayMessage
// 1165 #endif // ZCL_MESSAGe
// 1166 }
        ADD.W   #0x1e, SP
          CFI CFA SP+6
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock43
// 1167 
// 1168 /*********************************************************************
// 1169  * @fn      esp_MessageConfirmationCB
// 1170  *
// 1171  * @brief   Callback from the ZCL SE Profile Message Cluster Library when
// 1172  *          it received a Message Confirmation Command for
// 1173  *          this application.
// 1174  *
// 1175  * @param   pCmd - pointer to structure for Message Confirmation command
// 1176  * @param   srcAddr - source address
// 1177  * @param   seqNum - sequence number for this command
// 1178  *
// 1179  * @return  none
// 1180  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1181 static void esp_MessageConfirmationCB( zclCCMessageConfirmation_t *pCmd,
esp_MessageConfirmationCB:
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function esp_MessageConfirmationCB
// 1182                                              afAddrType_t *srcAddr, uint8 seqNum)
// 1183 {
// 1184   // add user code here
// 1185 }
        RETA
          CFI EndBlock cfiBlock44
// 1186 
// 1187 #if defined (ZCL_LOAD_CONTROL)
// 1188 /*********************************************************************
// 1189  * @fn      esp_SendReportEventStatus
// 1190  *
// 1191  * @brief   Callback from the ZCL SE Profile Message Cluster Library when
// 1192  *          it received a Load Control Event Command for
// 1193  *          this application.
// 1194  *
// 1195  * @param   afAddrType_t *srcAddr - pointer to source address
// 1196  * @param   uint8 seqNum - sequence number for this event
// 1197  * @param   uint32 eventID - event ID for this event
// 1198  * @param   uint32 startTime - start time for this event
// 1199  * @param   uint8 eventStatus - status for this event
// 1200  * @param   uint8 criticalityLevel - criticality level for this event
// 1201  * @param   uint8 eventControl - event control for this event
// 1202  *
// 1203  * @return  none
// 1204  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1205 static void esp_SendReportEventStatus( afAddrType_t *srcAddr, uint8 seqNum,
esp_SendReportEventStatus:
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function esp_SendReportEventStatus
// 1206                                               uint32 eventID, uint32 startTime,
// 1207                                               uint8 eventStatus, uint8 criticalityLevel,
// 1208                                               uint8 eventControl )
// 1209 {
        FUNCALL esp_SendReportEventStatus, osal_mem_alloc
        LOCFRAME CSTACK, 16, STACK
        FUNCALL esp_SendReportEventStatus, osal_memcpy
        LOCFRAME CSTACK, 16, STACK
        FUNCALL esp_SendReportEventStatus, zclSE_LoadControl_Send_ReportEventStatus
        LOCFRAME CSTACK, 18, STACK
        FUNCALL esp_SendReportEventStatus, osal_mem_free
        LOCFRAME CSTACK, 18, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        MOV.W   R12, R9
        MOV.B   R13, R8
        MOV.W   R14, R10
        MOV.W   R15, R11
// 1210   zclCCReportEventStatus_t *pRsp;
// 1211 
// 1212   pRsp = (zclCCReportEventStatus_t *)osal_mem_alloc( sizeof( zclCCReportEventStatus_t ) );
        MOV.W   #0x3c, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, R6
// 1213 
// 1214   if ( pRsp != NULL)
        CMP.W   #0x0, R12
        JEQ     ??esp_SendReportEventStatus_0
// 1215   {
// 1216     // Mandatory fields - use the incoming data
// 1217     pRsp->issuerEventID = eventID;
        MOV.W   R10, 0(R12)
        MOV.W   R11, 0x2(R12)
// 1218     pRsp->eventStartTime = startTime;
        MOV.W   0x10(SP), 0x4(R12)
        MOV.W   0x12(SP), 0x6(R12)
// 1219     pRsp->criticalityLevelApplied = criticalityLevel;
        MOV.B   0x16(SP), 0x9(R12)
// 1220     pRsp->eventControl = eventControl;
        MOV.B   0x18(SP), 0x10(R12)
// 1221     pRsp->eventStatus = eventStatus;
        MOV.B   0x14(SP), 0x8(R12)
// 1222     pRsp->signatureType = SE_PROFILE_SIGNATURE_TYPE_ECDSA;
        MOV.B   #0x1, 0x11(R12)
// 1223 
// 1224     // esp_Signature is a static array.
// 1225     // value can be changed in esp_data.c
// 1226     osal_memcpy( pRsp->signature, espSignature, 16 );
        MOV.W   #0x10, R14
        MOV.W   #espSignature, R13
        ADD.W   #0x12, R12
        CALLA   #osal_memcpy
// 1227 
// 1228     // Optional fields - fill in with non-used value by default
// 1229     pRsp->coolingTemperatureSetPointApplied = SE_OPTIONAL_FIELD_TEMPERATURE_SET_POINT;
        MOV.W   #0x8000, 0xa(R6)
// 1230     pRsp->heatingTemperatureSetPointApplied = SE_OPTIONAL_FIELD_TEMPERATURE_SET_POINT;
        MOV.W   #0x8000, 0xc(R6)
// 1231     pRsp->averageLoadAdjustment = SE_OPTIONAL_FIELD_INT8;
        MOV.B   #0x80, 0xe(R6)
// 1232     pRsp->dutyCycleApplied = SE_OPTIONAL_FIELD_UINT8;
        MOV.B   #0xff, 0xf(R6)
// 1233 
// 1234     // Send response back
// 1235     // DisableDefaultResponse is set to FALSE - it is recommended to turn on
// 1236     // default response since Report Event Status Command does not have
// 1237     // a response.
// 1238     zclSE_LoadControl_Send_ReportEventStatus( ESP_ENDPOINT, srcAddr,
// 1239                                             pRsp, FALSE, seqNum );
        PUSH.B  R8
          CFI CFA SP+18
        MOV.B   #0x0, R15
        MOV.W   R6, R14
        MOV.W   R9, R13
        MOV.B   #0x9, R12
        CALLA   #zclSE_LoadControl_Send_ReportEventStatus
// 1240     osal_mem_free( pRsp );
        MOV.W   R6, R12
        CALLA   #osal_mem_free
        ADD.W   #0x2, SP
          CFI CFA SP+16
// 1241   }
// 1242 }
??esp_SendReportEventStatus_0:
        POPM.W  #0x6, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock45
// 1243 #endif // ZCL_LOAD_CONTROL
// 1244 
// 1245 /*********************************************************************
// 1246  * @fn      esp_LoadControlEventCB
// 1247  *
// 1248  * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
// 1249  *          it received a Load Control Event Command for
// 1250  *          this application.
// 1251  *
// 1252  * @param   pCmd - pointer to load control event command
// 1253  * @param   srcAddr - source address
// 1254  * @param   status - event status
// 1255  * @param   seqNum - sequence number of this command
// 1256  *
// 1257  * @return  none
// 1258  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1259 static void esp_LoadControlEventCB( zclCCLoadControlEvent_t *pCmd,
esp_LoadControlEventCB:
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function esp_LoadControlEventCB
// 1260                                                afAddrType_t *srcAddr, uint8 status,
// 1261                                                uint8 seqNum)
// 1262 {
        FUNCALL esp_LoadControlEventCB, esp_SendReportEventStatus
        LOCFRAME CSTACK, 16, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R12, R10
        MOV.W   R13, R12
        MOV.B   R15, R13
// 1263 #if defined ( ZCL_LOAD_CONTROL )
// 1264   // According to the Smart Metering Specification, upon receipt
// 1265   // of the Load Control Event command, the receiving device shall
// 1266   // send Report Event Status command back.
// 1267   uint8 eventStatus;
// 1268 
// 1269   if ( status == ZCL_STATUS_INVALID_FIELD )
        CMP.B   #0x85, R14
        JEQ     ??esp_LoadControlEventCB_0
        MOV.B   #0x1, R14
        JMP     ??esp_LoadControlEventCB_1
??esp_LoadControlEventCB_0:
        MOV.B   #0xfe, R14
// 1270   {
// 1271     // If the incoming message has invalid fields in it
// 1272     // Send response back with status: rejected
// 1273     eventStatus = EVENT_STATUS_LOAD_CONTROL_EVENT_REJECTED;
// 1274   }
// 1275   else
// 1276   { // Send response back with status: received
// 1277     eventStatus = EVENT_STATUS_LOAD_CONTROL_EVENT_RECEIVED;
// 1278   }
// 1279 
// 1280   // Send response back
// 1281   esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEvent,
// 1282                                    pCmd->startTime, eventStatus,
// 1283                                    pCmd->criticalityLevel, pCmd->eventControl);
??esp_LoadControlEventCB_1:
        PUSH.B  0x18(R10)
          CFI CFA SP+8
        PUSH.B  0xe(R10)
          CFI CFA SP+10
        PUSH.B  R14
          CFI CFA SP+12
        PUSH.W  0xa(R10)
          CFI CFA SP+14
        PUSH.W  0x8(R10)
          CFI CFA SP+16
        MOV.W   @R10+, R14
        MOV.W   @R10+, R15
        CALLA   #esp_SendReportEventStatus
// 1284 
// 1285   if ( status != ZCL_STATUS_INVALID_FIELD )
// 1286   {
// 1287     // add user load control event handler here
// 1288   }
// 1289 #endif // ZCL_LOAD_CONTROL
// 1290 }
        ADD.W   #0xa, SP
          CFI CFA SP+6
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock46
// 1291 
// 1292 /*********************************************************************
// 1293  * @fn      esp_CancelLoadControlEventCB
// 1294  *
// 1295  * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
// 1296  *          it received a Cancel Load Control Event Command for
// 1297  *          this application.
// 1298  *
// 1299  * @param   pCmd - pointer to structure for Cancel Load Control Event command
// 1300  * @param   scrAddr - source address
// 1301  * @param   seqNum - sequence number for this command
// 1302  *
// 1303  * @return  none
// 1304  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1305 static void esp_CancelLoadControlEventCB( zclCCCancelLoadControlEvent_t *pCmd,
esp_CancelLoadControlEventCB:
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function esp_CancelLoadControlEventCB
// 1306                                                 afAddrType_t *srcAddr, uint8 seqNum )
// 1307 {
        FUNCALL esp_CancelLoadControlEventCB, esp_SendReportEventStatus
        LOCFRAME CSTACK, 14, STACK
        MOV.W   R12, R15
        MOV.W   R13, R12
        MOV.B   R14, R13
// 1308 #if defined ( ZCL_LOAD_CONTROL )
// 1309   if ( 0 )  // User shall replace the if condition with "if the event exist"
// 1310   {
// 1311     // If the event exist, stop the event, and respond with status: cancelled
// 1312 
// 1313     // Cancel the event here
// 1314 
// 1315     // Use the following sample code to send response back.
// 1316     /*
// 1317     esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEventID,
// 1318                                      // startTime
// 1319                                      EVENT_STATUS_LOAD_CONTROL_EVENT_CANCELLED, // eventStatus
// 1320                                      // Criticality level
// 1321                                      // eventControl };
// 1322     */
// 1323 
// 1324   }
// 1325   else
// 1326   {
// 1327     // If the event does not exist, respond with status: rejected
// 1328     // The rest of the mandatory fields are not available, therefore,
// 1329     // set to optional value
// 1330     esp_SendReportEventStatus( srcAddr, seqNum, pCmd->issuerEventID,
// 1331                                      SE_OPTIONAL_FIELD_UINT32,                  // startTime
// 1332                                      EVENT_STATUS_LOAD_CONTROL_EVENT_RECEIVED,  // eventStatus
// 1333                                      SE_OPTIONAL_FIELD_UINT8,                   // Criticality level
// 1334                                      SE_OPTIONAL_FIELD_UINT8 );                 // eventControl
        PUSH.B  #0xff
          CFI CFA SP+6
        PUSH.B  #0xff
          CFI CFA SP+8
        PUSH.B  #0x1
          CFI CFA SP+10
        PUSH.W  #0xffff
          CFI CFA SP+12
        PUSH.W  #0xffff
          CFI CFA SP+14
        MOV.W   @R15+, R14
        MOV.W   @R15+, R15
        CALLA   #esp_SendReportEventStatus
// 1335   }
// 1336 
// 1337 #endif // ZCL_LOAD_CONTROL
// 1338 }
        ADD.W   #0xa, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock47
// 1339 
// 1340 /*********************************************************************
// 1341  * @fn      esp_CancelAllLoadControlEventsCB
// 1342  *
// 1343  * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
// 1344  *          it received a Cancel All Load Control Event Command for
// 1345  *          this application.
// 1346  *
// 1347  * @param   pCmd - pointer to structure for Cancel All Load Control Event command
// 1348  * @param   scrAddr - source address
// 1349  * @param   seqNum - sequence number for this command
// 1350  *
// 1351  * @return  none
// 1352  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1353 static void esp_CancelAllLoadControlEventsCB( zclCCCancelAllLoadControlEvents_t *pCmd,
esp_CancelAllLoadControlEventsCB:
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function esp_CancelAllLoadControlEventsCB
// 1354                                                     afAddrType_t *srcAddr, uint8 seqNum )
// 1355 {
// 1356   // Upon receipt of Cancel All Load Control Event Command,
// 1357   // the receiving device shall look up the table for all events
// 1358   // and send a seperate response for each event
// 1359 
// 1360 }
        RETA
          CFI EndBlock cfiBlock48
// 1361 
// 1362 /*********************************************************************
// 1363  * @fn      esp_ReportEventStatusCB
// 1364  *
// 1365  * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
// 1366  *          it received a Report Event Status Command for
// 1367  *          this application.
// 1368  *
// 1369  * @param   pCmd - pointer to structure for Report Event Status command
// 1370  * @param   scrAddr - source address
// 1371  * @param   seqNum - sequence number for this command
// 1372  *
// 1373  * @return  none
// 1374  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1375 static void esp_ReportEventStatusCB( zclCCReportEventStatus_t *pCmd,
esp_ReportEventStatusCB:
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function esp_ReportEventStatusCB
// 1376                                            afAddrType_t *srcAddr, uint8 seqNum)
// 1377 {
// 1378   // add user code here
// 1379 }
        RETA
          CFI EndBlock cfiBlock49
// 1380 /*********************************************************************
// 1381  * @fn      esp_GetScheduledEventCB
// 1382  *
// 1383  * @brief   Callback from the ZCL SE Profile Load Control Cluster Library when
// 1384  *          it received a Get Scheduled Event Command for
// 1385  *          this application.
// 1386  *
// 1387  * @param   pCmd - pointer to structure for Get Scheduled Event command
// 1388  * @param   scrAddr - source address
// 1389  * @param   seqNum - sequence number for this command
// 1390  *
// 1391  * @return  none
// 1392  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1393 static void esp_GetScheduledEventCB( zclCCGetScheduledEvent_t *pCmd,
esp_GetScheduledEventCB:
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function esp_GetScheduledEventCB
// 1394                                            afAddrType_t *srcAddr, uint8 seqNum )
// 1395 {
// 1396   // add user code here
// 1397 }
        RETA
          CFI EndBlock cfiBlock50
// 1398 
// 1399 /*********************************************************************
// 1400  * @fn      esp_SelAvailEmergencyCreditCmdCB
// 1401  *
// 1402  * @brief   Callback from the ZCL SE Prepayment Cluster Library when it recieved
// 1403  *          Select Available Emergency Credit command in the application
// 1404  *
// 1405  * @param   pCmd - Pointer to zclCCSelAvailEmergencyCredit_t
// 1406  * @param   srcAddr - where the command is generated
// 1407  * @param   seqNum - Sequence no of the message
// 1408  *
// 1409  * @return  none
// 1410  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1411 static void esp_SelAvailEmergencyCreditCmdCB( zclCCSelAvailEmergencyCredit_t *pCmd,
esp_SelAvailEmergencyCreditCmdCB:
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function esp_SelAvailEmergencyCreditCmdCB
// 1412                                               afAddrType_t *srcAddr, uint8 seqNum )
// 1413 {
// 1414 #if defined ( ZCL_PREPAYMENT )
// 1415 #if defined ( LCD_SUPPORTED )
// 1416   HalLcdWriteString("Emergency Credit", HAL_LCD_LINE_1);
// 1417 
// 1418   if ((pCmd->siteId.strLen > 0) &&
// 1419       (pCmd->siteId.strLen <= HAL_LCD_MAX_CHARS) &&
// 1420       (pCmd->siteId.pStr != NULL))
// 1421   {
// 1422     HalLcdWriteString((char*)pCmd->siteId.pStr, HAL_LCD_LINE_2);
// 1423   }
// 1424 
// 1425   if ((pCmd->meterSerialNumber.strLen > 0) &&
// 1426       (pCmd->meterSerialNumber.strLen <= HAL_LCD_MAX_CHARS) &&
// 1427       (pCmd->meterSerialNumber.pStr != NULL))
// 1428   {
// 1429     HalLcdWriteString((char*)pCmd->meterSerialNumber.pStr, HAL_LCD_LINE_3);
// 1430   }
// 1431 #endif
// 1432 #endif  // ZCL_PREPAYMENT
// 1433 }
        RETA
          CFI EndBlock cfiBlock51
// 1434 
// 1435 /*********************************************************************
// 1436  * @fn      esp_ChangeSupplyCmdCB
// 1437  *
// 1438  * @brief   Callback from the ZCL SE Prepayment Cluster Library when it recieved
// 1439  *          Change Supply command in the application
// 1440  *
// 1441  * @param   pCmd - Pointer to zclCCChangeSupply_t
// 1442  * @param   srcAddr - where the command is generated
// 1443  * @param   seqNum - Sequence no of the message
// 1444  *
// 1445  * @return  none
// 1446  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1447 static void esp_ChangeSupplyCmdCB( zclCCChangeSupply_t *pCmd,
esp_ChangeSupplyCmdCB:
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function esp_ChangeSupplyCmdCB
// 1448                                        afAddrType_t *srcAddr, uint8 seqNum )
// 1449 {
// 1450 #if defined ( ZCL_PREPAYMENT )
// 1451   zclCCSupplyStatusResponse_t SupplyStatus_cmd;
// 1452 
// 1453   osal_memset( &SupplyStatus_cmd, 0, sizeof( zclCCSupplyStatusResponse_t ) );
// 1454 
// 1455   SupplyStatus_cmd.providerId = pCmd->providerId;
// 1456   SupplyStatus_cmd.implementationDateTime = osal_getClock();
// 1457   SupplyStatus_cmd.supplyStatus = pCmd->proposedSupplyStatus;
// 1458 
// 1459   zclSE_Prepayment_Send_SupplyStatusResponse( ESP_ENDPOINT, srcAddr, &SupplyStatus_cmd,
// 1460                                               FALSE, seqNum );
// 1461 #endif  // ZCL_PREPAYMENT
// 1462 }
        RETA
          CFI EndBlock cfiBlock52
// 1463 
// 1464 /*********************************************************************
// 1465  * @fn      esp_SupplyStatusRspCB
// 1466  *
// 1467  * @brief    Callback from the ZCL SE Prepayment Cluster Library when it recieved
// 1468  *           Supply Status Response command in the application
// 1469  *
// 1470  * @param   pCmd - Pointer to zclCCSupplyStatusResponse_t
// 1471  * @param   srcAddr - where the command is generated
// 1472  * @param   seqNum - Sequence no of the message
// 1473  *
// 1474  * @return  none
// 1475  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1476 static void esp_SupplyStatusRspCB( zclCCSupplyStatusResponse_t *pCmd,
esp_SupplyStatusRspCB:
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function esp_SupplyStatusRspCB
// 1477                                        afAddrType_t *srcAddr, uint8 seqNum )
// 1478 {
// 1479   // add user code here
// 1480 }
        RETA
          CFI EndBlock cfiBlock53
// 1481 
// 1482 /******************************************************************************
// 1483  *
// 1484  *  Functions for processing ZDO incoming messages
// 1485  *
// 1486  *****************************************************************************/
// 1487 
// 1488 /*********************************************************************
// 1489  * @fn      esp_ProcessZDOMsg
// 1490  *
// 1491  * @brief   Process the incoming ZDO messages.
// 1492  *
// 1493  * @param   inMsg - message to process
// 1494  *
// 1495  * @return  none
// 1496  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1497 static void esp_ProcessZDOMsg( zdoIncomingMsg_t *inMsg )
esp_ProcessZDOMsg:
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function esp_ProcessZDOMsg
// 1498 {
        FUNCALL esp_ProcessZDOMsg, ZDO_ParseDeviceAnnce
        LOCFRAME CSTACK, 20, STACK
        FUNCALL esp_ProcessZDOMsg, osal_set_event
        LOCFRAME CSTACK, 20, STACK
        FUNCALL esp_ProcessZDOMsg, osal_mem_alloc
        LOCFRAME CSTACK, 20, STACK
        FUNCALL esp_ProcessZDOMsg, ZDO_ParseSimpleDescRsp
        LOCFRAME CSTACK, 20, STACK
        FUNCALL esp_ProcessZDOMsg, osal_mem_free
        LOCFRAME CSTACK, 20, STACK
        FUNCALL esp_ProcessZDOMsg, osal_mem_free
        LOCFRAME CSTACK, 20, STACK
        FUNCALL esp_ProcessZDOMsg, osal_mem_free
        LOCFRAME CSTACK, 20, STACK
        PUSHM.W #0x2, R11
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+8
        SUB.W   #0xc, SP
          CFI CFA SP+20
        MOV.W   R12, R10
// 1499   ZDO_DeviceAnnce_t devAnnce;
// 1500 
// 1501   switch ( inMsg->clusterID )
        MOV.W   0xe(R12), R15
        SUB.W   #0x13, R15
        JEQ     ??esp_ProcessZDOMsg_2
        SUB.W   #0x7ff1, R15
        JEQ     ??esp_ProcessZDOMsg_3
        JMP     ??esp_ProcessZDOMsg_4
// 1502   {
// 1503     case Device_annce:
// 1504       {
// 1505         ZDO_ParseDeviceAnnce( inMsg, &devAnnce );
??esp_ProcessZDOMsg_2:
        MOV.W   SP, R13
        CALLA   #ZDO_ParseDeviceAnnce
// 1506         simpleDescReqAddr.addrMode = (afAddrMode_t)Addr16Bit;
        MOV.B   #0x2, &simpleDescReqAddr + 8
// 1507         simpleDescReqAddr.addr.shortAddr = devAnnce.nwkAddr;
        MOV.W   @SP, &simpleDescReqAddr
// 1508 
// 1509         // set simple descriptor query event
// 1510         osal_set_event( espTaskID, SIMPLE_DESC_QUERY_EVT );
        MOV.W   #0x4, R13
        MOV.B   &espTaskID, R12
        CALLA   #osal_set_event
// 1511       }
// 1512       break;
        JMP     ??esp_ProcessZDOMsg_4
// 1513 
// 1514     case Simple_Desc_rsp:
// 1515       {
// 1516         ZDO_SimpleDescRsp_t *pSimpleDescRsp;   // pointer to received simple desc response
// 1517         pSimpleDescRsp = (ZDO_SimpleDescRsp_t *)osal_mem_alloc( sizeof( ZDO_SimpleDescRsp_t ) );
??esp_ProcessZDOMsg_3:
        MOV.W   #0x12, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, R11
// 1518 
// 1519         if(pSimpleDescRsp)
        CMP.W   #0x0, R12
        JEQ     ??esp_ProcessZDOMsg_4
// 1520         {
// 1521           pSimpleDescRsp->simpleDesc.pAppInClusterList = NULL;
        MOV.W   #0x0, 0xc(R12)
// 1522           pSimpleDescRsp->simpleDesc.pAppOutClusterList = NULL;
        MOV.W   #0x0, 0x10(R12)
// 1523 
// 1524           ZDO_ParseSimpleDescRsp( inMsg, pSimpleDescRsp );
        MOV.W   R12, R13
        MOV.W   R10, R12
        CALLA   #ZDO_ParseSimpleDescRsp
// 1525           if( pSimpleDescRsp->simpleDesc.AppDeviceId == ZCL_SE_DEVICEID_PCT ) // this is a PCT
        MOV.W   0x8(R11), R15
        CMP.W   #0x503, R15
        JNE     ??esp_ProcessZDOMsg_5
// 1526           {
// 1527             pctAddr.addr.shortAddr = pSimpleDescRsp->nwkAddr;
        MOV.W   0x2(R11), &pctAddr
        JMP     ??esp_ProcessZDOMsg_6
// 1528           }
// 1529           else if ( pSimpleDescRsp->simpleDesc.AppDeviceId == ZCL_SE_DEVICEID_LOAD_CTRL_EXTENSION ) // this is a load control device
??esp_ProcessZDOMsg_5:
        CMP.W   #0x504, R15
        JNE     ??esp_ProcessZDOMsg_6
// 1530           {
// 1531             loadControlAddr.addr.shortAddr = pSimpleDescRsp->nwkAddr;
        MOV.W   0x2(R11), &loadControlAddr
// 1532           }
// 1533 
// 1534           // free memory for InClusterList
// 1535           if (pSimpleDescRsp->simpleDesc.pAppInClusterList)
??esp_ProcessZDOMsg_6:
        MOV.W   0xc(R11), R12
        CALLA   #?Subroutine2
// 1536           {
// 1537             osal_mem_free(pSimpleDescRsp->simpleDesc.pAppInClusterList);
// 1538           }
// 1539 
// 1540           // free memory for OutClusterList
// 1541           if (pSimpleDescRsp->simpleDesc.pAppOutClusterList)
??CrossCallReturnLabel_2:
        MOV.W   0x10(R11), R12
        CALLA   #?Subroutine2
// 1542           {
// 1543             osal_mem_free(pSimpleDescRsp->simpleDesc.pAppOutClusterList);
// 1544           }
// 1545 
// 1546           osal_mem_free( pSimpleDescRsp );
??CrossCallReturnLabel_3:
        MOV.W   R11, R12
        CALLA   #osal_mem_free
// 1547         }
// 1548       }
// 1549       break;
// 1550   }
// 1551 }
??esp_ProcessZDOMsg_4:
        ADD.W   #0xc, SP
          CFI CFA SP+8
        POPM.W  #0x2, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock54
// 1552 
// 1553 
// 1554 /******************************************************************************
// 1555  *
// 1556  *  Functions for processing ZCL Foundation incoming Command/Response messages
// 1557  *
// 1558  *****************************************************************************/
// 1559 
// 1560 /*********************************************************************
// 1561  * @fn      esp_ProcessZCLMsg
// 1562  *
// 1563  * @brief   Process ZCL Foundation incoming message
// 1564  *
// 1565  * @param   pInMsg - message to process
// 1566  *
// 1567  * @return  none
// 1568  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1569 static void esp_ProcessZCLMsg( zclIncomingMsg_t *pInMsg )
esp_ProcessZCLMsg:
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function esp_ProcessZCLMsg
// 1570 {
        FUNCALL esp_ProcessZCLMsg, esp_ProcessInConfigReportCmd
        LOCFRAME CSTACK, 6, STACK
        FUNCALL esp_ProcessZCLMsg, esp_ProcessInConfigReportRspCmd
        LOCFRAME CSTACK, 6, STACK
        FUNCALL esp_ProcessZCLMsg, esp_ProcessInReadReportCfgCmd
        LOCFRAME CSTACK, 6, STACK
        FUNCALL esp_ProcessZCLMsg, esp_ProcessInReportCmd
        LOCFRAME CSTACK, 6, STACK
        FUNCALL esp_ProcessZCLMsg, osal_mem_free
        LOCFRAME CSTACK, 6, STACK
        PUSH.W  R10
          CFI R10L Frame(CFA, -6)
          CFI CFA SP+6
        MOV.W   R12, R10
        MOV.B   0x7(R12), R14
        SUB.B   #0x1, R14
        JEQ     ??esp_ProcessZCLMsg_3
        SUB.B   #0x3, R14
        JEQ     ??esp_ProcessZCLMsg_4
        SUB.B   #0x2, R14
        JEQ     ??esp_ProcessZCLMsg_5
        SUB.B   #0x1, R14
        JEQ     ??esp_ProcessZCLMsg_6
        SUB.B   #0x1, R14
        JEQ     ??esp_ProcessZCLMsg_7
        SUB.B   #0x1, R14
        JEQ     ??esp_ProcessZCLMsg_8
        SUB.B   #0x1, R14
        JEQ     ??esp_ProcessZCLMsg_9
        JMP     ??esp_ProcessZCLMsg_10
// 1571   switch ( pInMsg->zclHdr.commandID )
// 1572   {
// 1573 #if defined ( ZCL_READ )
// 1574     case ZCL_CMD_READ_RSP:
// 1575       esp_ProcessInReadRspCmd( pInMsg );
??esp_ProcessZCLMsg_3:
        MOV.W   0x18(R12), R15
        MOV.B   #0x0, R14
??esp_ProcessZCLMsg_0:
        CMP.B   @R15, R14
        JC      ??esp_ProcessZCLMsg_10
        ADD.B   #0x1, R14
        JMP     ??esp_ProcessZCLMsg_0
// 1576       break;
// 1577 #endif // ZCL_READ
// 1578 #if defined ( ZCL_WRITE )
// 1579     case ZCL_CMD_WRITE_RSP:
// 1580       esp_ProcessInWriteRspCmd( pInMsg );
??esp_ProcessZCLMsg_4:
        MOV.W   0x18(R12), R15
        MOV.B   #0x0, R14
??esp_ProcessZCLMsg_1:
        CMP.B   @R15, R14
        JC      ??esp_ProcessZCLMsg_10
        ADD.B   #0x1, R14
        JMP     ??esp_ProcessZCLMsg_1
// 1581       break;
// 1582 #endif // ZCL_WRITE
// 1583 #if defined ( ZCL_REPORT )
// 1584     case ZCL_CMD_CONFIG_REPORT:
// 1585       esp_ProcessInConfigReportCmd( pInMsg );
??esp_ProcessZCLMsg_5:
        CALLA   #esp_ProcessInConfigReportCmd
// 1586       break;
        JMP     ??esp_ProcessZCLMsg_10
// 1587 
// 1588     case ZCL_CMD_CONFIG_REPORT_RSP:
// 1589       esp_ProcessInConfigReportRspCmd( pInMsg );
??esp_ProcessZCLMsg_6:
        CALLA   #esp_ProcessInConfigReportRspCmd
// 1590       break;
        JMP     ??esp_ProcessZCLMsg_10
// 1591 
// 1592     case ZCL_CMD_READ_REPORT_CFG:
// 1593       esp_ProcessInReadReportCfgCmd( pInMsg );
??esp_ProcessZCLMsg_7:
        CALLA   #esp_ProcessInReadReportCfgCmd
// 1594       break;
        JMP     ??esp_ProcessZCLMsg_10
// 1595 
// 1596     case ZCL_CMD_READ_REPORT_CFG_RSP:
// 1597       esp_ProcessInReadReportCfgRspCmd( pInMsg );
??esp_ProcessZCLMsg_8:
        MOV.W   0x18(R12), R15
        MOV.B   #0x0, R14
??esp_ProcessZCLMsg_2:
        CMP.B   @R15, R14
        JC      ??esp_ProcessZCLMsg_10
        ADD.B   #0x1, R14
        JMP     ??esp_ProcessZCLMsg_2
// 1598       break;
// 1599 
// 1600     case ZCL_CMD_REPORT:
// 1601       esp_ProcessInReportCmd( pInMsg );
??esp_ProcessZCLMsg_9:
        CALLA   #esp_ProcessInReportCmd
// 1602       break;
// 1603 #endif // ZCL_REPORT
// 1604     case ZCL_CMD_DEFAULT_RSP:
// 1605       esp_ProcessInDefaultRspCmd( pInMsg );
// 1606       break;
// 1607 #if defined ( ZCL_DISCOVER )
// 1608     case ZCL_CMD_DISCOVER_RSP:
// 1609       esp_ProcessInDiscRspCmd( pInMsg );
// 1610       break;
// 1611 #endif // ZCL_DISCOVER
// 1612     default:
// 1613       break;
// 1614   }
// 1615 
// 1616   if ( pInMsg->attrCmd != NULL )
??esp_ProcessZCLMsg_10:
        MOV.W   0x18(R10), R12
        CMP.W   #0x0, R12
        JEQ     ??esp_ProcessZCLMsg_11
// 1617   {
// 1618     // free the parsed command
// 1619     osal_mem_free( pInMsg->attrCmd );
        CALLA   #osal_mem_free
// 1620     pInMsg->attrCmd = NULL;
        MOV.W   #0x0, 0x18(R10)
// 1621   }
// 1622 }
??esp_ProcessZCLMsg_11:
        POP.W   R10
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock55

        RSEG CODE:CODE:NOROOT(1)
esp_ProcessInReadReportCfgCmd:
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function esp_ProcessInReadReportCfgCmd
        FUNCALL esp_ProcessInReadReportCfgCmd, zclFindAttrRec
        LOCFRAME CSTACK, 24, STACK
        FUNCALL esp_ProcessInReadReportCfgCmd, zclAnalogDataType
        LOCFRAME CSTACK, 24, STACK
        FUNCALL esp_ProcessInReadReportCfgCmd, zclGetDataTypeLength
        LOCFRAME CSTACK, 24, STACK
        FUNCALL esp_ProcessInReadReportCfgCmd, osal_mem_alloc
        LOCFRAME CSTACK, 24, STACK
        FUNCALL esp_ProcessInReadReportCfgCmd, zclFindAttrRec
        LOCFRAME CSTACK, 24, STACK
        FUNCALL esp_ProcessInReadReportCfgCmd, zcl_SendReadReportCfgRspCmd
        LOCFRAME CSTACK, 30, STACK
        FUNCALL esp_ProcessInReadReportCfgCmd, osal_mem_free
        LOCFRAME CSTACK, 30, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        SUB.W   #0x8, SP
          CFI CFA SP+24
        MOV.W   R12, R8
        MOV.B   #0x0, R11
        MOV.W   0x18(R12), R9
        MOV.B   #0x0, R10
        JMP     ??esp_ProcessInReadReportCfgCmd_2
??esp_ProcessInReadReportCfgCmd_0:
        MOV.W   SP, R15
        MOV.B   R10, R7
        RLAM.W  #0x2, R7
        MOV.W   R9, R14
        ADD.W   R7, R14
        MOV.W   0x4(R14), R14
        CALLA   #?Subroutine1
??CrossCallReturnLabel_0:
        JEQ     ??esp_ProcessInReadReportCfgCmd_3
        MOV.B   0x4(SP), R12
        CALLA   #zclAnalogDataType
        CMP.B   #0x0, R12
        JEQ     ??esp_ProcessInReadReportCfgCmd_3
        MOV.B   0x4(SP), R12
        CALLA   #zclGetDataTypeLength
        BIT.B   #0x1, R12
        JNC     ??esp_ProcessInReadReportCfgCmd_4
        ADD.B   #0x1, R12
??esp_ProcessInReadReportCfgCmd_4:
        ADD.B   R12, R11
??esp_ProcessInReadReportCfgCmd_3:
        ADD.B   #0x1, R10
??esp_ProcessInReadReportCfgCmd_2:
        MOV.B   @R9, R14
        CMP.B   R14, R10
        JNC     ??esp_ProcessInReadReportCfgCmd_0
        MOV.B   #0x2, R12
        RPT     #0xe
        ADDX.B  R14, R12
        MOV.B   R12, R12
        ADD.W   R11, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, R11
        CMP.W   #0x0, R12
        JNE     ??esp_ProcessInReadReportCfgCmd_5
        MOV.B   #0x0, R12
        JMP     ??esp_ProcessInReadReportCfgCmd_6
??esp_ProcessInReadReportCfgCmd_5:
        MOV.B   @R9, 0(R12)
        MOV.B   #0x0, R10
        JMP     ??esp_ProcessInReadReportCfgCmd_7
??esp_ProcessInReadReportCfgCmd_1:
        MOV.B   R10, R15
        MOV.W   R15, R7
        RPT     #0xd
        ADDX.W  R15, R7
        MOV.W   R11, R6
        ADD.W   R7, R6
        ADD.W   #0x2, R6
        RLAM.W  #0x2, R15
        MOV.W   R9, R7
        ADD.W   R15, R7
        ADD.W   #0x4, R7
        MOV.W   SP, R15
        MOV.W   @R7, R14
        CALLA   #?Subroutine6
??CrossCallReturnLabel_11:
        CMP.B   #0x0, R12
        JNE     ??esp_ProcessInReadReportCfgCmd_8
        MOV.B   #0x86, R14
        JMP     ??esp_ProcessInReadReportCfgCmd_9
??esp_ProcessInReadReportCfgCmd_8:
        MOV.B   #0x8c, R14
??esp_ProcessInReadReportCfgCmd_9:
        MOV.B   R14, 0(R6)
        MOV.W   @R7, 0x2(R6)
        ADD.B   #0x1, R10
??esp_ProcessInReadReportCfgCmd_7:
        MOV.W   0x8(R8), R13
        CMP.B   @R9, R10
        JNC     ??esp_ProcessInReadReportCfgCmd_1
        PUSH.B  0x6(R8)
          CFI CFA SP+26
        PUSH.B  #0x1
          CFI CFA SP+28
        PUSH.B  #0x1
          CFI CFA SP+30
        MOV.W   R11, R15
        MOV.W   R13, R14
        ADD.W   #0xa, R8
        MOV.W   R8, R13
        MOV.B   #0x9, R12
        CALLA   #zcl_SendReadReportCfgRspCmd
        MOV.W   R11, R12
        CALLA   #osal_mem_free
        MOV.B   #0x1, R12
        ADD.W   #0x6, SP
          CFI CFA SP+24
          CFI EndBlock cfiBlock56
??esp_ProcessInReadReportCfgCmd_6:
        REQUIRE ?Subroutine0
        // Fall through to label ?Subroutine0
// 1623 
// 1624 #if defined ( ZCL_READ )
// 1625 /*********************************************************************
// 1626  * @fn      esp_ProcessInReadRspCmd
// 1627  *
// 1628  * @brief   Process the "Profile" Read Response Command
// 1629  *
// 1630  * @param   pInMsg - incoming message to process
// 1631  *
// 1632  * @return  none
// 1633  */
// 1634 static uint8 esp_ProcessInReadRspCmd( zclIncomingMsg_t *pInMsg )
// 1635 {
// 1636   zclReadRspCmd_t *readRspCmd;
// 1637   uint8 i;
// 1638 
// 1639   readRspCmd = (zclReadRspCmd_t *)pInMsg->attrCmd;
// 1640   for (i = 0; i < readRspCmd->numAttr; i++)
// 1641   {
// 1642     // Notify the originator of the results of the original read attributes
// 1643     // attempt and, for each successfull request, the value of the requested
// 1644     // attribute
// 1645   }
// 1646 
// 1647   return TRUE;
// 1648 }
// 1649 #endif // ZCL_READ
// 1650 
// 1651 #if defined ( ZCL_WRITE )
// 1652 /*********************************************************************
// 1653  * @fn      esp_ProcessInWriteRspCmd
// 1654  *
// 1655  * @brief   Process the "Profile" Write Response Command
// 1656  *
// 1657  * @param   pInMsg - incoming message to process
// 1658  *
// 1659  * @return  none
// 1660  */
// 1661 static uint8 esp_ProcessInWriteRspCmd( zclIncomingMsg_t *pInMsg )
// 1662 {
// 1663   zclWriteRspCmd_t *writeRspCmd;
// 1664   uint8 i;
// 1665 
// 1666   writeRspCmd = (zclWriteRspCmd_t *)pInMsg->attrCmd;
// 1667   for (i = 0; i < writeRspCmd->numAttr; i++)
// 1668   {
// 1669     // Notify the device of the results of the its original write attributes
// 1670     // command.
// 1671   }
// 1672 
// 1673   return TRUE;
// 1674 }
// 1675 #endif // ZCL_WRITE
// 1676 
// 1677 #if defined ( ZCL_REPORT )
// 1678 /*********************************************************************
// 1679  * @fn      esp_ProcessInConfigReportCmd
// 1680  *
// 1681  * @brief   Process the "Profile" Configure Reporting Command
// 1682  *
// 1683  * @param   pInMsg - incoming message to process
// 1684  *
// 1685  * @return  TRUE if attribute was found in the Attribute list,
// 1686  *          FALSE if not
// 1687  */

        RSEG CODE:CODE:NOROOT(1)
?Subroutine0:
          CFI Block cfiBlock57 Using cfiCommon0
          CFI NoFunction
          CFI CFA SP+24
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
// 1688 static uint8 esp_ProcessInConfigReportCmd( zclIncomingMsg_t *pInMsg )
// 1689 {
// 1690   zclCfgReportCmd_t *cfgReportCmd;
// 1691   zclCfgReportRec_t *reportRec;
// 1692   zclCfgReportRspCmd_t *cfgReportRspCmd;
// 1693   zclAttrRec_t attrRec;
// 1694   uint8 status;
// 1695   uint8 i, j = 0;
// 1696 
// 1697   cfgReportCmd = (zclCfgReportCmd_t *)pInMsg->attrCmd;
// 1698 
// 1699   // Allocate space for the response command
// 1700   cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof ( zclCfgReportRspCmd_t ) +
// 1701                                         sizeof ( zclCfgReportStatus_t) * cfgReportCmd->numAttr );
// 1702   if ( cfgReportRspCmd == NULL )
// 1703   {
// 1704     return FALSE; // EMBEDDED RETURN
// 1705   }
// 1706 
// 1707   // Process each Attribute Reporting Configuration record
// 1708   for ( i = 0; i < cfgReportCmd->numAttr; i++ )
// 1709   {
// 1710     reportRec = &(cfgReportCmd->attrList[i]);
// 1711 
// 1712     status = ZCL_STATUS_SUCCESS;
// 1713 
// 1714     if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId, reportRec->attrID, &attrRec ) )
// 1715     {
// 1716       if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
// 1717       {
// 1718         if ( reportRec->dataType == attrRec.attr.dataType )
// 1719         {
// 1720           // This the attribute that is to be reported
// 1721           if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
// 1722           {
// 1723             if ( reportRec->minReportInt < ESP_MIN_REPORTING_INTERVAL ||
// 1724                  ( reportRec->maxReportInt != 0 &&
// 1725                    reportRec->maxReportInt < reportRec->minReportInt ) )
// 1726             {
// 1727               // Invalid fields
// 1728               status = ZCL_STATUS_INVALID_VALUE;
// 1729             }
// 1730             else
// 1731             {
// 1732               // Set the Min and Max Reporting Intervals and Reportable Change
// 1733               //status = zclSetAttrReportInterval( pAttr, cfgReportCmd );
// 1734               status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE; // for now
// 1735             }
// 1736           }
// 1737           else
// 1738           {
// 1739             // Attribute cannot be reported
// 1740             status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE;
// 1741           }
// 1742         }
// 1743         else
// 1744         {
// 1745           // Attribute data type is incorrect
// 1746           status = ZCL_STATUS_INVALID_DATA_TYPE;
// 1747         }
// 1748       }
// 1749       else
// 1750       {
// 1751         // We shall expect reports of values of this attribute
// 1752         if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
// 1753         {
// 1754           // Set the Timeout Period
// 1755           //status = zclSetAttrTimeoutPeriod( pAttr, cfgReportCmd );
// 1756           status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE; // for now
// 1757         }
// 1758         else
// 1759         {
// 1760           // Reports of attribute cannot be received
// 1761           status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
// 1762         }
// 1763       }
// 1764     }
// 1765     else
// 1766     {
// 1767       // Attribute is not supported
// 1768       status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
// 1769     }
// 1770 
// 1771     // If not successful then record the status
// 1772     if ( status != ZCL_STATUS_SUCCESS )
// 1773     {
// 1774       cfgReportRspCmd->attrList[j].status = status;
// 1775       cfgReportRspCmd->attrList[j++].attrID = reportRec->attrID;
// 1776     }
// 1777   } // for loop
// 1778 
// 1779   if ( j == 0 )
// 1780   {
// 1781     // Since all attributes were configured successfully, include a single
// 1782     // attribute status record in the response command with the status field
// 1783     // set to SUCCESS and the attribute ID field omitted.
// 1784     cfgReportRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
// 1785     cfgReportRspCmd->numAttr = 1;
// 1786   }
// 1787   else
// 1788   {
// 1789     cfgReportRspCmd->numAttr = j;
// 1790   }
// 1791 
// 1792   // Send the response back
// 1793   zcl_SendConfigReportRspCmd( ESP_ENDPOINT, &(pInMsg->srcAddr),
// 1794                               pInMsg->clusterId, cfgReportRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1795                               TRUE, pInMsg->zclHdr.transSeqNum );
// 1796   osal_mem_free( cfgReportRspCmd );
// 1797 
// 1798   return TRUE ;
        ADD.W   #0x8, SP
          CFI CFA SP+16
        POPM.W  #0x6, R11
          CFI CFA SP+4
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI R10L SameValue
          CFI R11L SameValue
        RETA
          CFI EndBlock cfiBlock57

        RSEG CODE:CODE:NOROOT(1)
esp_ProcessInConfigReportRspCmd:
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function esp_ProcessInConfigReportRspCmd
        FUNCALL esp_ProcessInConfigReportRspCmd, zclFindAttrRec
        LOCFRAME CSTACK, 20, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0x8, SP
          CFI CFA SP+20
        MOV.W   R12, R11
        MOV.W   0x18(R12), R8
        MOV.B   #0x0, R10
        JMP     ??esp_ProcessInConfigReportRspCmd_1
??esp_ProcessInConfigReportRspCmd_0:
        MOV.W   SP, R15
        MOV.B   R10, R14
        RLAM.W  #0x2, R14
        MOV.W   R8, R13
        ADD.W   R14, R13
        MOV.W   0x4(R13), R14
        MOV.W   0x8(R11), R13
        CALLA   #?Subroutine6
??CrossCallReturnLabel_10:
        ADD.B   #0x1, R10
??esp_ProcessInConfigReportRspCmd_1:
        CMP.B   @R8, R10
        JNC     ??esp_ProcessInConfigReportRspCmd_0
        MOV.B   #0x1, R12
        ADD.W   #0x8, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock58

        RSEG CODE:CODE:NOROOT(1)
?Subroutine6:
          CFI Block cfiCond59 Using cfiCommon0
          CFI Function esp_ProcessInReadReportCfgCmd
          CFI Conditional ??CrossCallReturnLabel_11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+28
          CFI Block cfiCond60 Using cfiCommon0
          CFI (cfiCond60) Function esp_ProcessInConfigReportRspCmd
          CFI (cfiCond60) Conditional ??CrossCallReturnLabel_10
          CFI (cfiCond60) R8L Frame(CFA, -12)
          CFI (cfiCond60) R9L Frame(CFA, -10)
          CFI (cfiCond60) R10L Frame(CFA, -8)
          CFI (cfiCond60) R11L Frame(CFA, -6)
          CFI (cfiCond60) CFA SP+24
          CFI Block cfiCond61 Using cfiCommon0
          CFI (cfiCond61) Function esp_ProcessInReadReportCfgCmd
          CFI (cfiCond61) Conditional ??CrossCallReturnLabel_9, ??CrossCallReturnLabel_0
          CFI (cfiCond61) R6L Frame(CFA, -16)
          CFI (cfiCond61) R7L Frame(CFA, -14)
          CFI (cfiCond61) R8L Frame(CFA, -12)
          CFI (cfiCond61) R9L Frame(CFA, -10)
          CFI (cfiCond61) R10L Frame(CFA, -8)
          CFI (cfiCond61) R11L Frame(CFA, -6)
          CFI (cfiCond61) CFA SP+32
          CFI Block cfiCond62 Using cfiCommon0
          CFI (cfiCond62) Function esp_ProcessInConfigReportCmd
          CFI (cfiCond62) Conditional ??CrossCallReturnLabel_9, ??CrossCallReturnLabel_1
          CFI (cfiCond62) R6L Frame(CFA, -16)
          CFI (cfiCond62) R7L Frame(CFA, -14)
          CFI (cfiCond62) R8L Frame(CFA, -12)
          CFI (cfiCond62) R9L Frame(CFA, -10)
          CFI (cfiCond62) R10L Frame(CFA, -8)
          CFI (cfiCond62) R11L Frame(CFA, -6)
          CFI (cfiCond62) CFA SP+32
          CFI Block cfiPicker63 Using cfiCommon1
          CFI (cfiPicker63) NoFunction
          CFI (cfiPicker63) Picker
        MOV.B   #0x9, R12
        BRA     #zclFindAttrRec
          CFI EndBlock cfiCond59
          CFI EndBlock cfiCond60
          CFI EndBlock cfiCond61
          CFI EndBlock cfiCond62
          CFI EndBlock cfiPicker63

        RSEG CODE:CODE:REORDER:NOROOT(1)
esp_ProcessInConfigReportCmd:
          CFI Block cfiBlock64 Using cfiCommon0
          CFI Function esp_ProcessInConfigReportCmd
        FUNCALL esp_ProcessInConfigReportCmd, osal_mem_alloc
        LOCFRAME CSTACK, 24, STACK
        FUNCALL esp_ProcessInConfigReportCmd, zclFindAttrRec
        LOCFRAME CSTACK, 24, STACK
        FUNCALL esp_ProcessInConfigReportCmd, zcl_SendConfigReportRspCmd
        LOCFRAME CSTACK, 30, STACK
        FUNCALL esp_ProcessInConfigReportCmd, osal_mem_free
        LOCFRAME CSTACK, 30, STACK
        PUSHM.W #0x6, R11
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+16
        SUB.W   #0x8, SP
          CFI CFA SP+24
        MOV.W   R12, R8
        MOV.B   #0x0, R10
        MOV.W   0x18(R12), R9
        MOV.B   @R9, R12
        RLAM.W  #0x2, R12
        ADD.W   #0x2, R12
        CALLA   #osal_mem_alloc
        MOV.W   R12, R6
        CMP.W   #0x0, R12
        JNE     ??esp_ProcessInConfigReportCmd_3
        MOV.B   #0x0, R12
        JMP     ??esp_ProcessInConfigReportCmd_4
??esp_ProcessInConfigReportCmd_3:
        MOV.B   #0x0, R11
        JMP     ??esp_ProcessInConfigReportCmd_5
??esp_ProcessInConfigReportCmd_0:
        MOV.B   #0x86, R14
??esp_ProcessInConfigReportCmd_1:
        MOV.B   R10, R13
        RLAM.W  #0x2, R13
        MOV.W   R6, R15
        ADD.W   R13, R15
        MOV.B   R14, 0x2(R15)
        MOV.W   0x2(R7), 0x4(R15)
        ADD.B   #0x1, R10
        ADD.B   #0x1, R11
??esp_ProcessInConfigReportCmd_5:
        CMP.B   @R9, R11
        JC      ??esp_ProcessInConfigReportCmd_6
        MOV.W   R11, R15
        RPT     #0xd
        ADDX.W  R11, R15
        MOV.W   R9, R7
        ADD.W   R15, R7
        ADD.W   #0x2, R7
        MOV.W   SP, R15
        MOV.W   0x2(R7), R14
        CALLA   #?Subroutine1
??CrossCallReturnLabel_1:
        JEQ     ??esp_ProcessInConfigReportCmd_0
        CMP.B   #0x0, 0(R7)
        JNE     ??esp_ProcessInConfigReportCmd_0
        CMP.B   0x4(SP), 0x4(R7)
        JEQ     ??esp_ProcessInConfigReportCmd_7
        MOV.B   #0x8d, R14
        JMP     ??esp_ProcessInConfigReportCmd_1
??esp_ProcessInConfigReportCmd_7:
        MOV.B   #0x8c, R14
        JMP     ??esp_ProcessInConfigReportCmd_1
??esp_ProcessInConfigReportCmd_6:
        CMP.B   #0x0, R10
        JNE     ??esp_ProcessInConfigReportCmd_8
        MOV.B   #0x0, 0x2(R6)
        MOV.B   #0x1, 0(R6)
        JMP     ??esp_ProcessInConfigReportCmd_9
??esp_ProcessInConfigReportCmd_8:
        MOV.B   R10, 0(R6)
??esp_ProcessInConfigReportCmd_9:
        PUSH.B  0x6(R8)
          CFI CFA SP+26
        PUSH.B  #0x1
          CFI CFA SP+28
        PUSH.B  #0x1
          CFI CFA SP+30
        MOV.W   R6, R15
        MOV.W   0x8(R8), R14
        ADD.W   #0xa, R8
        MOV.W   R8, R13
        MOV.B   #0x9, R12
        CALLA   #zcl_SendConfigReportRspCmd
        MOV.W   R6, R12
        CALLA   #osal_mem_free
        MOV.B   #0x1, R12
        ADD.W   #0x6, SP
          CFI CFA SP+24
??esp_ProcessInConfigReportCmd_4:
        JMP     ?Subroutine0
        NOP
          CFI EndBlock cfiBlock64
// 1799 }

        RSEG CODE:CODE:REORDER:NOROOT(1)
?Subroutine1:
          CFI Block cfiCond65 Using cfiCommon0
          CFI Function esp_ProcessInReadReportCfgCmd
          CFI Conditional ??CrossCallReturnLabel_0
          CFI R6L Frame(CFA, -16)
          CFI R7L Frame(CFA, -14)
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+28
          CFI Block cfiCond66 Using cfiCommon0
          CFI (cfiCond66) Function esp_ProcessInConfigReportCmd
          CFI (cfiCond66) Conditional ??CrossCallReturnLabel_1
          CFI (cfiCond66) R6L Frame(CFA, -16)
          CFI (cfiCond66) R7L Frame(CFA, -14)
          CFI (cfiCond66) R8L Frame(CFA, -12)
          CFI (cfiCond66) R9L Frame(CFA, -10)
          CFI (cfiCond66) R10L Frame(CFA, -8)
          CFI (cfiCond66) R11L Frame(CFA, -6)
          CFI (cfiCond66) CFA SP+28
          CFI Block cfiPicker67 Using cfiCommon1
          CFI (cfiPicker67) NoFunction
          CFI (cfiPicker67) Picker
// 1800 
// 1801 /*********************************************************************
// 1802  * @fn      esp_ProcessInConfigReportRspCmd
// 1803  *
// 1804  * @brief   Process the "Profile" Configure Reporting Response Command
// 1805  *
// 1806  * @param   pInMsg - incoming message to process
// 1807  *
// 1808  * @return  none
// 1809  */
// 1810 static uint8 esp_ProcessInConfigReportRspCmd( zclIncomingMsg_t *pInMsg )
// 1811 {
// 1812   zclCfgReportRspCmd_t *cfgReportRspCmd;
// 1813   zclAttrRec_t attrRec;
// 1814   uint8 i;
// 1815 
// 1816   cfgReportRspCmd = (zclCfgReportRspCmd_t *)pInMsg->attrCmd;
// 1817   for (i = 0; i < cfgReportRspCmd->numAttr; i++)
// 1818   {
// 1819     if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
// 1820                          cfgReportRspCmd->attrList[i].attrID, &attrRec ) )
// 1821     {
// 1822       // Notify the device of success (or otherwise) of the its original configure
// 1823       // reporting command, for each attribute.
// 1824     }
// 1825   }
// 1826 
// 1827   return TRUE;
// 1828 }
// 1829 
// 1830 /*********************************************************************
// 1831  * @fn      esp_ProcessInReadReportCfgCmd
// 1832  *
// 1833  * @brief   Process the "Profile" Read Reporting Configuration Command
// 1834  *
// 1835  * @param   pInMsg - incoming message to process
// 1836  *
// 1837  * @return  none
// 1838  */
// 1839 static uint8 esp_ProcessInReadReportCfgCmd( zclIncomingMsg_t *pInMsg )
// 1840 {
// 1841   zclReadReportCfgCmd_t *readReportCfgCmd;
// 1842   zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
// 1843   zclReportCfgRspRec_t *reportRspRec;
// 1844   zclAttrRec_t attrRec;
// 1845   uint8 reportChangeLen;
// 1846   uint8 *dataPtr;
// 1847   uint8 hdrLen;
// 1848   uint8 dataLen = 0;
// 1849   uint8 status;
// 1850   uint8 i;
// 1851 
// 1852   readReportCfgCmd = (zclReadReportCfgCmd_t *)pInMsg->attrCmd;
// 1853 
// 1854   // Find out the response length (Reportable Change field is of variable length)
// 1855   for ( i = 0; i < readReportCfgCmd->numAttr; i++ )
// 1856   {
// 1857     // For supported attributes with 'analog' data type, find out the length of
// 1858     // the Reportable Change field
// 1859     if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
// 1860                          readReportCfgCmd->attrList[i].attrID, &attrRec ) )
        MOV.W   0x8(R8), R13
        CALLA   #?Subroutine6
??CrossCallReturnLabel_9:
        CMP.B   #0x0, R12
        RETA
          CFI EndBlock cfiCond65
          CFI EndBlock cfiCond66
          CFI EndBlock cfiPicker67
// 1861     {
// 1862       if ( zclAnalogDataType( attrRec.attr.dataType ) )
// 1863       {
// 1864          reportChangeLen = zclGetDataTypeLength( attrRec.attr.dataType );
// 1865 
// 1866          // add padding if neede
// 1867          if ( PADDING_NEEDED( reportChangeLen ) )
// 1868          {
// 1869            reportChangeLen++;
// 1870          }
// 1871          dataLen += reportChangeLen;
// 1872       }
// 1873     }
// 1874   }
// 1875 
// 1876   hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( readReportCfgCmd->numAttr * sizeof( zclReportCfgRspRec_t ) );
// 1877 
// 1878   // Allocate space for the response command
// 1879   readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
// 1880   if ( readReportCfgRspCmd == NULL )
// 1881   {
// 1882     return FALSE; // EMBEDDED RETURN
// 1883   }
// 1884 
// 1885   dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
// 1886   readReportCfgRspCmd->numAttr = readReportCfgCmd->numAttr;
// 1887   for (i = 0; i < readReportCfgCmd->numAttr; i++)
// 1888   {
// 1889     reportRspRec = &(readReportCfgRspCmd->attrList[i]);
// 1890 
// 1891     if ( zclFindAttrRec( ESP_ENDPOINT, pInMsg->clusterId,
// 1892                          readReportCfgCmd->attrList[i].attrID, &attrRec ) )
// 1893     {
// 1894       if ( zcl_MandatoryReportableAttribute( &attrRec ) == TRUE )
// 1895       {
// 1896         // Get the Reporting Configuration
// 1897         // status = zclReadReportCfg( readReportCfgCmd->attrID[i], reportRspRec );
// 1898         status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE; // for now
// 1899         if ( status == ZCL_STATUS_SUCCESS && zclAnalogDataType( attrRec.attr.dataType ) )
// 1900         {
// 1901           reportChangeLen = zclGetDataTypeLength( attrRec.attr.dataType );
// 1902           //osal_memcpy( dataPtr, pBuf, reportChangeLen );
// 1903           reportRspRec->reportableChange = dataPtr;
// 1904 
// 1905           // add padding if needed
// 1906           if ( PADDING_NEEDED( reportChangeLen ) )
// 1907           {
// 1908             reportChangeLen++;
// 1909           }
// 1910           dataPtr += reportChangeLen;
// 1911         }
// 1912       }
// 1913       else
// 1914       {
// 1915         // Attribute not in the Mandatory Reportable Attribute list
// 1916         status = ZCL_STATUS_UNREPORTABLE_ATTRIBUTE;
// 1917       }
// 1918     }
// 1919     else
// 1920     {
// 1921       // Attribute not found
// 1922       status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
// 1923     }
// 1924 
// 1925     reportRspRec->status = status;
// 1926     reportRspRec->attrID = readReportCfgCmd->attrList[i].attrID;
// 1927   }
// 1928 
// 1929   // Send the response back
// 1930   zcl_SendReadReportCfgRspCmd( ESP_ENDPOINT, &(pInMsg->srcAddr),
// 1931                                pInMsg->clusterId, readReportCfgRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
// 1932                                TRUE, pInMsg->zclHdr.transSeqNum );
// 1933   osal_mem_free( readReportCfgRspCmd );
// 1934 
// 1935   return TRUE;
// 1936 }
// 1937 
// 1938 /*********************************************************************
// 1939  * @fn      esp_ProcessInReadReportCfgRspCmd
// 1940  *
// 1941  * @brief   Process the "Profile" Read Reporting Configuration Response Command
// 1942  *
// 1943  * @param   pInMsg - incoming message to process
// 1944  *
// 1945  * @return  none
// 1946  */
// 1947 static uint8 esp_ProcessInReadReportCfgRspCmd( zclIncomingMsg_t *pInMsg )
// 1948 {
// 1949   zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
// 1950   zclReportCfgRspRec_t *reportRspRec;
// 1951   uint8 i;
// 1952 
// 1953   readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)pInMsg->attrCmd;
// 1954   for ( i = 0; i < readReportCfgRspCmd->numAttr; i++ )
// 1955   {
// 1956     reportRspRec = &(readReportCfgRspCmd->attrList[i]);
// 1957 
// 1958     // Notify the device of the results of the its original read reporting
// 1959     // configuration command.
// 1960 
// 1961     if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
// 1962     {
// 1963       if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
// 1964       {
// 1965         // add user code here
// 1966       }
// 1967       else
// 1968       {
// 1969         // expecting attribute reports
// 1970       }
// 1971     }
// 1972   }
// 1973 
// 1974   return TRUE;
// 1975 }
// 1976 
// 1977 /*********************************************************************
// 1978  * @fn      esp_ProcessInReportCmd
// 1979  *
// 1980  * @brief   Process the "Profile" Report Command
// 1981  *
// 1982  * @param   pInMsg - incoming message to process
// 1983  *
// 1984  * @return  none
// 1985  */

        RSEG CODE:CODE:REORDER:NOROOT(1)
// 1986 static uint8 esp_ProcessInReportCmd( zclIncomingMsg_t *pInMsg )
esp_ProcessInReportCmd:
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function esp_ProcessInReportCmd
// 1987 {
        FUNCALL esp_ProcessInReportCmd, _ltoa
        LOCFRAME CSTACK, 26, STACK
        FUNCALL esp_ProcessInReportCmd, HalLcdWriteString
        LOCFRAME CSTACK, 26, STACK
        FUNCALL esp_ProcessInReportCmd, HalLcdWriteString
        LOCFRAME CSTACK, 26, STACK
        FUNCALL esp_ProcessInReportCmd, HalLcdWriteString
        LOCFRAME CSTACK, 26, STACK
        FUNCALL esp_ProcessInReportCmd, HalLcdWriteString
        LOCFRAME CSTACK, 26, STACK
        FUNCALL esp_ProcessInReportCmd, HalLcdWriteString
        LOCFRAME CSTACK, 26, STACK
        FUNCALL esp_ProcessInReportCmd, _ltoa
        LOCFRAME CSTACK, 26, STACK
        PUSHM.W #0x4, R11
          CFI R8L Frame(CFA, -12)
          CFI R9L Frame(CFA, -10)
          CFI R10L Frame(CFA, -8)
          CFI R11L Frame(CFA, -6)
          CFI CFA SP+12
        SUB.W   #0xe, SP
          CFI CFA SP+26
// 1988   zclReportCmd_t *reportCmd;
// 1989   zclReport_t *reportRec;
// 1990   uint8 i,j;
// 1991   uint8 * meterData;
// 1992   uint8 * meterData1;
// 1993   uint8 * meterData2;
// 1994  
// 1995   char lcdBuf[13];
// 1996 
// 1997   reportCmd = (zclReportCmd_t *)pInMsg->attrCmd;
        MOV.W   0x18(R12), R8
// 1998   
// 1999   for (j = 0; j < reportCmd->numAttr; j++)
        MOV.B   #0x0, R9
        JMP     ??esp_ProcessInReportCmd_3
// 2000   {
// 2001     // Device is notified of the latest values of the attribute of another device.
// 2002       reportRec = &(reportCmd->attrList[j]);
// 2003     
// 2004     if ( reportRec->attrID == ATTRID_SE_POWER_FACTOR ) 
// 2005    {
// 2006      meterData1 = reportRec->attrData;
// 2007      //  uint8 buf[25];
// 2008 
// 2009    // _itoa( meterData, &buf[0], 10 );
// 2010      HalLcdWriteString((char*)meterData1, HAL_LCD_LINE_4);
// 2011    }
// 2012    
// 2013        if ( reportRec->attrID == ATTRID_SE_CURRENT_SUMMATION_RECEIVED ) 
// 2014    {
// 2015      meterData2 = reportRec->attrData;
// 2016      //  uint8 buf[25];
// 2017 
// 2018    // _itoa( meterData, &buf[0], 10 );
// 2019      HalLcdWriteString((char*)meterData2, HAL_LCD_LINE_5);
// 2020    }
// 2021 
// 2022     if ( reportRec->attrID == ATTRID_SE_CURRENT_SUMMATION_DELIVERED )
// 2023     {
// 2024       // process simple metering current summation delivered attribute
// 2025       meterData = reportRec->attrData;
// 2026 
// 2027       // process to convert hex to ascii
// 2028       for(i=0; i<6; i++)
// 2029       {
// 2030         if(meterData[5-i] == 0)
// 2031         {
// 2032           lcdBuf[i*2] = '0';
// 2033           lcdBuf[i*2+1] = '0';
// 2034         }
// 2035         else if(meterData[5-i] <= 0x0A)
// 2036         {
// 2037           lcdBuf[i*2] = '0';
// 2038           _ltoa(meterData[5-i],(uint8*)&lcdBuf[i*2+1],16);
// 2039         }
// 2040         else
// 2041         {
// 2042           _ltoa(meterData[5-i],(uint8*)&lcdBuf[i*2],16);
??esp_ProcessInReportCmd_2:
        MOV.B   #0x10, R15
??esp_ProcessInReportCmd_9:
        MOV.W   #0x0, R13
        CALLA   #_ltoa
// 2043         }
??esp_ProcessInReportCmd_1:
        ADD.B   #0x1, R11
        CMP.B   #0x6, R11
        JNC     ??esp_ProcessInReportCmd_4
// 2044       }
// 2045 
// 2046       // print out value of current summation delivered in hex
// 2047       HalLcdWriteString("Zigbee Coord esp", HAL_LCD_LINE_1);
        MOV.B   #0x1, R13
        MOV.W   #`?<Constant "Zigbee Coord esp">`, R12
        CALLA   #HalLcdWriteString
// 2048       HalLcdWriteString("Curr Summ Dlvd", HAL_LCD_LINE_2);
        MOV.B   #0x2, R13
        MOV.W   #`?<Constant "Curr Summ Dlvd">`, R12
        CALLA   #HalLcdWriteString
// 2049       HalLcdWriteString(lcdBuf, HAL_LCD_LINE_3);
        MOV.B   #0x3, R13
        MOV.W   SP, R12
        CALLA   #HalLcdWriteString
??esp_ProcessInReportCmd_0:
        ADD.B   #0x1, R9
??esp_ProcessInReportCmd_3:
        CMP.B   @R8, R9
        JC      ??esp_ProcessInReportCmd_5
        MOV.W   R9, R15
        RPT     #0x5
        ADDX.W  R9, R15
        MOV.W   R8, R11
        ADD.W   R15, R11
        ADD.W   #0x2, R11
        CMP.W   #0x6, 0(R11)
        JNE     ??esp_ProcessInReportCmd_6
        MOV.B   #0x4, R13
        MOV.W   0x4(R11), R12
        CALLA   #HalLcdWriteString
??esp_ProcessInReportCmd_6:
        CMP.W   #0x1, 0(R11)
        JNE     ??esp_ProcessInReportCmd_7
        MOV.B   #0x5, R13
        MOV.W   0x4(R11), R12
        CALLA   #HalLcdWriteString
??esp_ProcessInReportCmd_7:
        CMP.W   #0x0, 0(R11)
        JNE     ??esp_ProcessInReportCmd_0
        MOV.W   0x4(R11), R10
        MOV.B   #0x0, R11
??esp_ProcessInReportCmd_4:
        MOV.B   R11, R15
        MOV.W   R10, R13
        SUB.W   R15, R13
        MOV.B   0x5(R13), R12
        MOV.W   SP, R14
        RLA.W   R15
        ADD.W   R15, R14
        CMP.B   #0x0, R12
        JNE     ??esp_ProcessInReportCmd_8
        MOV.B   #0x30, 0(R14)
        MOV.B   #0x30, 0x1(R14)
        JMP     ??esp_ProcessInReportCmd_1
??esp_ProcessInReportCmd_8:
        CMP.B   #0xb, R12
        JC      ??esp_ProcessInReportCmd_2
        MOV.B   #0x30, 0(R14)
        MOV.B   #0x10, R15
        ADD.W   #0x1, R14
        MOV.B   0x5(R13), R12
        JMP     ??esp_ProcessInReportCmd_9
// 2050     }
// 2051    
// 2052   
// 2053   }
// 2054   return TRUE;
??esp_ProcessInReportCmd_5:
        MOV.B   #0x1, R12
        ADD.W   #0xe, SP
          CFI CFA SP+12
        POPM.W  #0x4, R11
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock68
// 2055 }

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for espEp>`:
        DC8 9, 0
        DC16 espTaskID, espSimpleDesc
        DC8 0, 0

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for esp_GenCmdCallbacks>`:
        DC32 esp_BasicResetCB, esp_IdentifyCB, esp_IdentifyQueryRspCB, 0H, 0H
        DC32 0H, 0H, 0H, 0H, 0H, 0H, 0H, esp_AlarmCB, 0H, 0H

        RSEG DATA16_ID:CONST:SORT:NOROOT(1)
`?<Initializer for esp_SECmdCallbacks>`:
        DC32 esp_GetProfileCmdCB, esp_GetProfileRspCB, esp_ReqMirrorCmdCB
        DC32 esp_ReqMirrorRspCB, esp_MirrorRemCmdCB, esp_MirrorRemRspCB
        DC32 esp_GetCurrentPriceCB, esp_GetScheduledPriceCB, esp_PublishPriceCB
        DC32 esp_DisplayMessageCB, esp_CancelMessageCB, esp_GetLastMessageCB
        DC32 esp_MessageConfirmationCB, esp_LoadControlEventCB
        DC32 esp_CancelLoadControlEventCB, esp_CancelAllLoadControlEventsCB
        DC32 esp_ReportEventStatusCB, esp_GetScheduledEventCB
        DC32 esp_ReqFastPollModeCmdCB, esp_ReqFastPollModeRspCB
        DC32 esp_PriceAcknowledgementCB, esp_GetBlockPeriodCB
        DC32 esp_PublishBlockPeriodCB, esp_SelAvailEmergencyCreditCmdCB
        DC32 esp_ChangeSupplyCmdCB, esp_SupplyStatusRspCB

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG CODE:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "TI IPD Test Msg!">`:
        DC8 "TI IPD Test Msg!"

        RSEG DATA16_C:CONST:SORT:NOROOT(1)
`?<Constant {10485761L, 10485762L, 10485763L, 1`:
        DC32 10485761, 10485762, 10485763, 10485764, 10485765

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "Fast Polling">`:
        DC8 "Fast Polling"

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "Cur 0x">`:
        DC8 "Cur 0x"

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "End 0x">`:
        DC8 "End 0x"

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "BASE">`:
        DC8 "BASE"

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant {32, 33, 34, 35, 36, 37, 38, 39, 40`:
        DC8 32, 33, 34, 35, 36, 37, 38, 39, 40, 41

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "Zigbee Coord esp">`:
        DC8 "Zigbee Coord esp"

        RSEG DATA16_C:CONST:SORT:NOROOT(0)
`?<Constant "Curr Summ Dlvd">`:
        DC8 "Curr Summ Dlvd"

        END
// 2056 #endif // ZCL_REPORT
// 2057 
// 2058 /*********************************************************************
// 2059  * @fn      esp_ProcessInDefaultRspCmd
// 2060  *
// 2061  * @brief   Process the "Profile" Default Response Command
// 2062  *
// 2063  * @param   pInMsg - incoming message to process
// 2064  *
// 2065  * @return  none
// 2066  */
// 2067 static uint8 esp_ProcessInDefaultRspCmd( zclIncomingMsg_t *pInMsg )
// 2068 {
// 2069   // zclDefaultRspCmd_t *defaultRspCmd = (zclDefaultRspCmd_t *)pInMsg->attrCmd;
// 2070 
// 2071   // Device is notified of the Default Response command.
// 2072 
// 2073   return TRUE;
// 2074 }
// 2075 
// 2076 #if defined ( ZCL_DISCOVER )
// 2077 /*********************************************************************
// 2078  * @fn      esp_ProcessInDiscRspCmd
// 2079  *
// 2080  * @brief   Process the "Profile" Discover Response Command
// 2081  *
// 2082  * @param   pInMsg - incoming message to process
// 2083  *
// 2084  * @return  none
// 2085  */
// 2086 static uint8 esp_ProcessInDiscRspCmd( zclIncomingMsg_t *pInMsg )
// 2087 {
// 2088   zclDiscoverRspCmd_t *discoverRspCmd;
// 2089   uint8 i;
// 2090 
// 2091   discoverRspCmd = (zclDiscoverRspCmd_t *)pInMsg->attrCmd;
// 2092   for ( i = 0; i < discoverRspCmd->numAttr; i++ )
// 2093   {
// 2094     // Device is notified of the result of its attribute discovery command.
// 2095   }
// 2096 
// 2097   return TRUE;
// 2098 }
// 2099 #endif // ZCL_DISCOVER
// 2100 
// 2101 /****************************************************************************
// 2102 ****************************************************************************/
// 
// 2 470 bytes in segment CODE
//   111 bytes in segment DATA16_C
//   172 bytes in segment DATA16_I
//   172 bytes in segment DATA16_ID
//    75 bytes in segment DATA16_Z
// 
// 2 470 bytes of CODE  memory
//   283 bytes of CONST memory
//   247 bytes of DATA  memory
//
//Errors: none
//Warnings: none
