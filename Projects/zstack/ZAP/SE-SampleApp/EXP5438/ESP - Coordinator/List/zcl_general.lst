###############################################################################
#                                                                             #
#                                                       29/Jan/2012  16:16:23 #
# IAR C/C++ Compiler V5.40.2.20380/W32, Evaluation edition for MSP430         #
# Copyright 1996-2011 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Components\stack\ #
#                     zcl\zcl_general.c                                       #
#    Command line  =  -f "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\Source\zap.cfg"       #
#                     (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=!ZAP_PHY_SPI            #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f   #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\..\..\..\Tools\MSP5438\f8wZCL. #
#                     cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC                #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE) "C:\Texas Instruments\ZAP-MSP430-2.5.0\C #
#                     omponents\stack\zcl\zcl_general.c" -D                   #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D             #
#                     TC_LINKKEY_JOIN -D ZCL_REPORT -D INTER_PAN -lC          #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\List\" -lA   #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\List\"       #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\Obj\"        #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\" -I "C:\Texas                 #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\Source\" -I "C:\Texas                 #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\Source\" -I "C:\Texas              #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\hal\target\MSP #
#                     5438ZAP\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pro #
#                     jects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Co #
#                     mponents\hal\include\" -I "C:\Texas                     #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\mac\include\"  #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\m #
#                     t\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\ #
#                     zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Componen #
#                     ts\osal\include\" -I "C:\Texas                          #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\osal\mcu\msp43 #
#                     0\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\ #
#                     zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Componen #
#                     ts\services\saddr\" -I "C:\Texas                        #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\services\sdata #
#                     \" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\z #
#                     stack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\ #
#                     Projects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\.. #
#                     \Components\stack\nwk\" -I "C:\Texas                    #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\stack\sapi\"   #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\s #
#                     tack\sec\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pr #
#                     ojects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\C #
#                     omponents\stack\sys\" -I "C:\Texas                      #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\stack\zcl\"    #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\s #
#                     tack\zdo\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pr #
#                     ojects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\C #
#                     omponents\zmac\" -I "C:\Texas                           #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\zmac\f8w\"     #
#                     --core=430X --data_model=small -Ohz --multiplier=32     #
#                     --multiplier_location=4C0 --require_prototypes          #
#                     --hw_workaround=CPU40                                   #
#    List file     =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\SE-SampleApp\EXP5438\ESP -                           #
#                     Coordinator\List\zcl_general.lst                        #
#    Object file   =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\SE-SampleApp\EXP5438\ESP -                           #
#                     Coordinator\Obj\zcl_general.r43                         #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZAP-MSP430-2.5.0\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2011-06-06 11:11:40 -0700 (Mon, 06 Jun 2011) $
      4            Revision:       $Revision: 26217 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "OSAL.h"
     46          #include "OSAL_Nv.h"
     47          #include "zcl.h"
     48          #include "zcl_general.h"
     49          #include "ZDApp.h"
     50          
     51          #if defined ( INTER_PAN )
     52            #include "stub_aps.h"
     53          #endif
     54          
     55          /*********************************************************************
     56           * MACROS
     57           */
     58          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     59          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     60          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     61          
     62          #ifdef ZCL_SCENES
     63          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     64          #endif // ZCL_SCENES
     65          
     66          /*********************************************************************
     67           * CONSTANTS
     68           */
     69          
     70          /*********************************************************************
     71           * TYPEDEFS
     72           */
     73          typedef struct zclGenCBRec
     74          {
     75            struct zclGenCBRec        *next;
     76            uint8                     endpoint; // Used to link it into the endpoint descriptor
     77            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     78          } zclGenCBRec_t;
     79          
     80          typedef struct zclGenSceneItem
     81          {
     82            struct zclGenSceneItem    *next;
     83            uint8                     endpoint; // Used to link it into the endpoint descriptor
     84            zclGeneral_Scene_t        scene;    // Scene info
     85          } zclGenSceneItem_t;
     86          
     87          typedef struct zclGenAlarmItem
     88          {
     89            struct zclGenAlarmItem    *next;
     90            uint8                     endpoint; // Used to link it into the endpoint descriptor
     91            zclGeneral_Alarm_t        alarm;    // Alarm info
     92          } zclGenAlarmItem_t;
     93          
     94          // Scene NV types
     95          typedef struct
     96          {
     97            uint16                    numRecs;
     98          } nvGenScenesHdr_t;
     99          
    100          typedef struct zclGenSceneNVItem
    101          {
    102            uint8                     endpoint;
    103            zclGeneral_Scene_t        scene;
    104          } zclGenSceneNVItem_t;
    105          
    106          /*********************************************************************
    107           * GLOBAL VARIABLES
    108           */
    109          
    110          /*********************************************************************
    111           * GLOBAL FUNCTIONS
    112           */
    113          
    114          /*********************************************************************
    115           * LOCAL VARIABLES
    116           */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    117          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
   \                     zclGenCBs:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    118          static uint8 zclGenPluginRegisted = FALSE;
   \                     zclGenPluginRegisted:
   \   000000                DS8 1
    119          #ifdef ZCL_SCENES
    120          static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    121          #endif // ZCL_SCENES
    122          #ifdef ZCL_ALARMS
    123          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
    124          #endif // ZCL_ALARMS
    125          
    126          /*********************************************************************
    127           * LOCAL FUNCTIONS
    128           */
    129          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    130          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    131          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    132          
    133          // Device Configuration and Installation clusters
    134          #ifdef ZCL_BASIC
    135          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    136          #endif // ZCL_BASIC
    137          
    138          #ifdef ZCL_IDENTIFY
    139          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    140          #endif // ZCL_IDENTIFY
    141          
    142          // Groups and Scenes clusters
    143          #ifdef ZCL_GROUPS
    144          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    145          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    146          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    147          #endif // ZCL_GROUPS
    148          
    149          #ifdef ZCL_SCENES
    150          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    151          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    152          #endif // ZCL_SCENES
    153          
    154          // On/Off and Level Control Configuration clusters
    155          #ifdef ZCL_ON_OFF
    156          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    157          #endif // ZCL_ONOFF
    158          
    159          #ifdef ZCL_LEVEL_CTRL
    160          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    161          #endif // ZCL_LEVEL_CTRL
    162          
    163          // Alarms cluster
    164          #ifdef ZCL_ALARMS
    165          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    166          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    167          #endif // ZCL_ALARMS
    168          
    169          // Location cluster
    170          #ifdef ZCL_LOCATION
    171          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    172          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    173          #endif // ZCL_LOCATION
    174          
    175          #ifdef ZCL_SCENES
    176          static uint8 zclGeneral_ScenesInitNV( void );
    177          static void zclGeneral_ScenesSetDefaultNV( void );
    178          static void zclGeneral_ScenesWriteNV( void );
    179          static uint16 zclGeneral_ScenesRestoreFromNV( void );
    180          #endif // ZCL_SCENES
    181          
    182          /*********************************************************************
    183           * @fn      zclGeneral_RegisterCmdCallbacks
    184           *
    185           * @brief   Register an applications command callbacks
    186           *
    187           * @param   endpoint - application's endpoint
    188           * @param   callbacks - pointer to the callback record.
    189           *
    190           * @return  ZMemError if not able to allocate
    191           */

   \                                 In  segment CODE, align 2
    192          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
   \                     zclGeneral_RegisterCmdCallbacks:
    193          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
    194            zclGenCBRec_t *pNewItem;
    195            zclGenCBRec_t *pLoop;
    196          
    197            // Register as a ZCL Plugin
    198            if ( zclGenPluginRegisted == FALSE )
   \   000006   C293....     CMP.B   #0x0, &zclGenPluginRegisted
   \   00000A   0B20         JNE     ??zclGeneral_RegisterCmdCallbacks_3
    199            {
    200              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    201                                  ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    202                                  zclGeneral_HdlIncoming );
   \   00000C   3E40....     MOV.W   #LWRD(zclGeneral_HdlIncoming), R14
   \   000010   3F40....     MOV.W   #HWRD(zclGeneral_HdlIncoming), R15
   \   000014   3D401400     MOV.W   #0x14, R13
   \   000018   0C43         MOV.W   #0x0, R12
   \   00001A   ........     CALLA   #zcl_registerPlugin
    203          
    204          #ifdef ZCL_SCENES
    205              // Initialize NV items
    206              zclGeneral_ScenesInitNV();
    207          
    208              // Restore the Scene table
    209              zclGeneral_ScenesRestoreFromNV();
    210          #endif // ZCL_SCENES
    211          
    212              zclGenPluginRegisted = TRUE;
   \   00001E   D243....     MOV.B   #0x1, &zclGenPluginRegisted
    213            }
    214          
    215            // Fill in the new profile list
    216            pNewItem = osal_mem_alloc( sizeof( zclGenCBRec_t ) );
   \                     ??zclGeneral_RegisterCmdCallbacks_3:
   \   000022   3C400600     MOV.W   #0x6, R12
   \   000026   ........     CALLA   #osal_mem_alloc
    217            if ( pNewItem == NULL )
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   0320         JNE     ??zclGeneral_RegisterCmdCallbacks_4
    218              return (ZMemError);
   \   00002E   7C401000     MOV.B   #0x10, R12
   \   000032   143C         JMP     ??zclGeneral_RegisterCmdCallbacks_5
    219          
    220            pNewItem->next = (zclGenCBRec_t *)NULL;
   \                     ??zclGeneral_RegisterCmdCallbacks_4:
   \   000034   8C430000     MOV.W   #0x0, 0(R12)
    221            pNewItem->endpoint = endpoint;
   \   000038   CC4A0200     MOV.B   R10, 0x2(R12)
    222            pNewItem->CBs = callbacks;
   \   00003C   8C4B0400     MOV.W   R11, 0x4(R12)
    223          
    224            // Find spot in list
    225            if (  zclGenCBs == NULL )
   \   000040   1F42....     MOV.W   &zclGenCBs, R15
   \   000044   0F93         CMP.W   #0x0, R15
   \   000046   0420         JNE     ??zclGeneral_RegisterCmdCallbacks_2
    226            {
    227              zclGenCBs = pNewItem;
   \   000048   824C....     MOV.W   R12, &zclGenCBs
   \   00004C   063C         JMP     ??zclGeneral_RegisterCmdCallbacks_6
    228            }
    229            else
    230            {
    231              // Look for end of list
    232              pLoop = zclGenCBs;
    233              while ( pLoop->next != NULL )
    234                pLoop = pLoop->next;
   \                     ??zclGeneral_RegisterCmdCallbacks_0:
   \   00004E   0F4B         MOV.W   R11, R15
   \                     ??zclGeneral_RegisterCmdCallbacks_2:
   \   000050   2B4F         MOV.W   @R15, R11
   \   000052   0B93         CMP.W   #0x0, R11
   \   000054   FC23         JNE     ??zclGeneral_RegisterCmdCallbacks_0
    235          
    236              // Put new item at end of list
    237              pLoop->next = pNewItem;
   \   000056   8F4C0000     MOV.W   R12, 0(R15)
    238            }
    239          
    240            return ( ZSuccess );
   \                     ??zclGeneral_RegisterCmdCallbacks_6:
   \   00005A   4C43         MOV.B   #0x0, R12
   \                     ??zclGeneral_RegisterCmdCallbacks_5:
   \   00005C   1A17         POPM.W  #0x2, R11
   \   00005E   1001         RETA
    241          }
    242          
    243          #ifdef ZCL_IDENTIFY
    244          /*********************************************************************
    245           * @fn      zclGeneral_SendIdentify
    246           *
    247           * @brief   Call to send out an Identify Command
    248           *
    249           * @param   srcEP - Sending application's endpoint
    250           * @param   dstAddr - where you want the message to go
    251           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    252           * @param   seqNum - identification number for the transaction
    253           *
    254           * @return  ZStatus_t
    255           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   5312         PUSH.B  #0x1
   \   000002   4F43         MOV.B   #0x0, R15
   \   000004   3E400300     MOV.W   #0x3, R14
   \   000008   ........     CALLA   #zcl_SendCommand
   \   00000C   31501000     ADD.W   #0x10, SP
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2
    256          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentify:
    257                                uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    258          {
   \   000000   2183         SUB.W   #0x2, SP
    259            uint8 buf[2];
    260          
    261            buf[0] = LO_UINT16( identifyTime );
   \   000002   ........     CALLA   #?Subroutine1
    262            buf[1] = HI_UINT16( identifyTime );
    263          
    264            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    265                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    266                                    disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_1:
   \   000006   0E41         MOV.W   SP, R14
   \   000008   0E12         PUSH.W  R14
   \   00000A   2312         PUSH.W  #0x2
   \   00000C   51120C00     PUSH.B  0xc(SP)
   \   000010   0312         PUSH.W  #0x0
   \   000012   4F12         PUSH.B  R15
   \   000014   4312         PUSH.B  #0x0
   \   000016   ....         JMP     ?Subroutine0
   \   000018   0343         NOP
    267          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   C14E0400     MOV.B   R14, 0x4(SP)
   \   000004                RPT     #0x8
   \   000004   47190E10     RRUX.W  R14
   \   000008   C14E0500     MOV.B   R14, 0x5(SP)
   \   00000C   1001         RETA
    268          
    269          /*********************************************************************
    270           * @fn      zclGeneral_SendIdentifyQueryResponse
    271           *
    272           * @brief   Call to send out an Identify Query Response Command
    273           *
    274           * @param   srcEP - Sending application's endpoint
    275           * @param   dstAddr - where you want the message to go
    276           * @param   timeout - how long the device will continue to identify itself (in seconds)
    277           * @param   seqNum - identification number for the transaction
    278           *
    279           * @return  ZStatus_t
    280           */

   \                                 In  segment CODE, align 2, keep-with-next
    281          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zclGeneral_SendIdentifyQueryResponse:
    282                                      uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    283          {
   \   000000   2183         SUB.W   #0x2, SP
    284            uint8 buf[2];
    285          
    286            buf[0] = LO_UINT16( timeout );
   \   000002   ........     CALLA   #?Subroutine1
    287            buf[1] = HI_UINT16( timeout );
    288          
    289            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    290                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    291                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
   \                     ??CrossCallReturnLabel_0:
   \   000006   0E41         MOV.W   SP, R14
   \   000008   0E12         PUSH.W  R14
   \   00000A   2312         PUSH.W  #0x2
   \   00000C   51120C00     PUSH.B  0xc(SP)
   \   000010   0312         PUSH.W  #0x0
   \   000012   4F12         PUSH.B  R15
   \   000014   5312         PUSH.B  #0x1
   \   000016                REQUIRE ?Subroutine0
   \   000016                // Fall through to label ?Subroutine0
    292          }
    293          #endif // ZCL_IDENTIFY
    294          
    295          #ifdef ZCL_GROUPS
    296          /*********************************************************************
    297           * @fn      zclGeneral_SendGroupRequest
    298           *
    299           * @brief   Send a Group Request to a device.  You can also use the
    300           *          appropriate macro.
    301           *
    302           * @param   srcEP - Sending Apps endpoint
    303           * @param   dstAddr - where to send the request
    304           * @param   cmd - one of the following:
    305           *              COMMAND_GROUP_VIEW
    306           *              COMMAND_GROUP_REMOVE
    307           * @param   groupID -
    308           *
    309           * @return  ZStatus_t
    310           */
    311          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    312                               uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    313          {
    314            uint8 buf[2];
    315          
    316            buf[0] = LO_UINT16( groupID );
    317            buf[1] = HI_UINT16( groupID );
    318          
    319            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    320                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    321                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
    322          }
    323          
    324          /*********************************************************************
    325           * @fn      zclGeneral_SendAddGroupRequest
    326           *
    327           * @brief   Send the Add Group Request to a device
    328           *
    329           * @param   srcEP - Sending Apps endpoint
    330           * @param   dstAddr - where to send the request
    331           * @param   cmd - one of the following:
    332           *                COMMAND_GROUP_ADD
    333           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    334           * @param   groupID - pointer to the group structure
    335           * @param   groupName - pointer to Group Name.  This is a Zigbee
    336           *          string data type, so the first byte is the length of the
    337           *          name (in bytes), then the name.
    338           *
    339           * @return  ZStatus_t
    340           */
    341          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    342                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    343                                                    uint8 disableDefaultRsp, uint8 seqNum )
    344          {
    345            uint8 *buf;
    346            uint8 *pBuf;
    347            uint8 len;
    348            ZStatus_t status;
    349          
    350            len = 2;    // Group ID
    351            len += groupName[0] + 1;  // String + 1 for length
    352          
    353            buf = osal_mem_alloc( len );
    354            if ( buf )
    355            {
    356              pBuf = buf;
    357              *pBuf++ = LO_UINT16( groupID );
    358              *pBuf++ = HI_UINT16( groupID );
    359              *pBuf++ = groupName[0]; // string length
    360              osal_memcpy( pBuf, &(groupName[1]), groupName[0] );
    361          
    362              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    363                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    364                                        disableDefaultRsp, 0, seqNum, len, buf );
    365              osal_mem_free( buf );
    366            }
    367            else
    368              status = ZMemError;
    369          
    370            return ( status );
    371          }
    372          
    373          /*********************************************************************
    374           * @fn      zclGeneral_SendGroupGetMembershipRequest
    375           *
    376           * @brief   Send a Get Group Membership (Resposne) Command to a device
    377           *
    378           * @param   srcEP - Sending Apps endpoint
    379           * @param   dstAddr - where to send the request
    380           * @param   cmd - one of the following:
    381           *                COMMAND_GROUP_GET_MEMBERSHIP
    382           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    383           * @param   groupID - pointer to the group structure
    384           * @param   groupName - pointer to Group Name.  This is a Zigbee
    385           *          string data type, so the first byte is the length of the
    386           *          name (in bytes), then the name.
    387           *
    388           * @return  ZStatus_t
    389           */
    390          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
    391                                        uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    392                                        uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    393          {
    394            uint8 *buf;
    395            uint8 *pBuf;
    396            uint8 len = 0;
    397            uint8 i;
    398            ZStatus_t status;
    399          
    400            if ( rspCmd )
    401              len++;  // Capacity
    402          
    403            len++;  // Group Count
    404            len += sizeof ( uint16 ) * grpCnt;  // Group List
    405          
    406            buf = osal_mem_alloc( len );
    407            if ( buf )
    408            {
    409              pBuf = buf;
    410              if ( rspCmd )
    411                *pBuf++ = capacity;
    412          
    413              *pBuf++ = grpCnt;
    414              for ( i = 0; i < grpCnt; i++ )
    415              {
    416                *pBuf++ = LO_UINT16( grpList[i] );
    417                *pBuf++ = HI_UINT16( grpList[i] );
    418              }
    419          
    420              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    421                                        cmd, TRUE, direction,
    422                                        disableDefaultRsp, 0, seqNum, len, buf );
    423              osal_mem_free( buf );
    424            }
    425            else
    426              status = ZMemError;
    427          
    428            return ( status );
    429          }
    430          
    431          /*********************************************************************
    432           * @fn      zclGeneral_SendGroupResponse
    433           *
    434           * @brief   Send Group Response (not Group View Response)
    435           *
    436           * @param   srcEP - Sending application's endpoint
    437           * @param   dstAddr - where you want the message to go
    438           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    439           * @param   status - group command status
    440           * @param   groupID - what group
    441           *
    442           * @return  ZStatus_t
    443           */
    444          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
    445                                                  uint8 cmd, uint8 status, uint16 groupID,
    446                                                  uint8 disableDefaultRsp, uint8 seqNum )
    447          {
    448            uint8 buf[3];
    449          
    450            buf[0] = status;
    451            buf[1] = LO_UINT16( groupID );
    452            buf[2] = HI_UINT16( groupID );
    453          
    454            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    455                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    456                                    disableDefaultRsp, 0, seqNum, 3, buf );
    457          }
    458          
    459          /*********************************************************************
    460           * @fn      zclGeneral_SendGroupViewResponse
    461           *
    462           * @brief   Call to send Group Response Command
    463           *
    464           * @param   srcEP - Sending application's endpoint
    465           * @param   dstAddr - where you want the message to go
    466           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    467           * @param   status - group command status
    468           * @param   grp - group info
    469           *
    470           * @return  ZStatus_t
    471           */
    472          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    473                           uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    474          {
    475            uint8 *buf;
    476            uint8 len;
    477            ZStatus_t stat;
    478          
    479            len = 1 + 2; // Status + Group ID
    480          
    481            if ( status == ZCL_STATUS_SUCCESS )
    482              len += grp->name[0] + 1;  // String + 1 for length
    483          
    484            buf = osal_mem_alloc( len );
    485            if ( buf )
    486            {
    487              buf[0] = status;
    488              buf[1] = LO_UINT16( grp->ID );
    489              buf[2] = HI_UINT16( grp->ID );
    490          
    491              if ( status == ZCL_STATUS_SUCCESS )
    492              {
    493                buf[3] = grp->name[0]; // string length
    494                osal_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
    495              }
    496          
    497              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    498                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    499                                      disableDefaultRsp, 0, seqNum, len, buf );
    500              osal_mem_free( buf );
    501            }
    502            else
    503              stat = ZMemError;
    504          
    505            return ( stat );
    506          }
    507          #endif // ZCL_GROUPS
    508          
    509          #ifdef ZCL_SCENES
    510          /*********************************************************************
    511           * @fn      zclGeneral_SendAddScene
    512           *
    513           * @brief   Send the Add Scene Request to a device
    514           *
    515           * @param   srcEP - Sending Apps endpoint
    516           * @param   dstAddr - where to send the request
    517           * @param   scene - pointer to the scene structure
    518           *
    519           * @return  ZStatus_t
    520           */
    521          ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
    522                                zclGeneral_Scene_t *scene, uint8 disableDefaultRsp, uint8 seqNum )
    523          {
    524            uint8 *buf;
    525            uint8 *pBuf;
    526            uint8 len;
    527            ZStatus_t status;
    528          
    529            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    530            len += scene->name[0] + 1; // String + 1 for length
    531          
    532            // Add something for the extension field length
    533            len += scene->extLen;
    534          
    535            buf = osal_mem_alloc( len );
    536            if ( buf )
    537            {
    538              pBuf = buf;
    539              *pBuf++ = LO_UINT16( scene->groupID );
    540              *pBuf++ = HI_UINT16( scene->groupID );
    541              *pBuf++ = scene->ID;
    542              *pBuf++ = LO_UINT16( scene->transTime );
    543              *pBuf++ = HI_UINT16( scene->transTime );
    544              *pBuf++ = scene->name[0]; // string length
    545              osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    546              pBuf += scene->name[0]; // move pass name
    547          
    548              // Add the extension fields
    549              if ( scene->extLen > 0 )
    550                osal_memcpy( pBuf, scene->extField, scene->extLen );
    551          
    552              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    553                                        COMMAND_SCENE_ADD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    554                                        disableDefaultRsp, 0, seqNum, len, buf );
    555              osal_mem_free( buf );
    556            }
    557            else
    558              status = ZMemError;
    559          
    560            return ( status );
    561          }
    562          
    563          /*********************************************************************
    564           * @fn      zclGeneral_SendSceneRequest
    565           *
    566           * @brief   Send a Scene Request to a device.  You can also use the
    567           *          appropriate macro.
    568           *
    569           * @param   srcEP - Sending Apps endpoint
    570           * @param   dstAddr - where to send the request
    571           * @param   cmd - one of the following:
    572           *              COMMAND_SCENE_VIEW
    573           *              COMMAND_SCENE_REMOVE
    574           *              COMMAND_SCENE_REMOVE_ALL
    575           *              COMMAND_SCENE_STORE
    576           *              COMMAND_SCENE_RECALL
    577           *              COMMAND_SCENE_GET_MEMBERSHIP
    578           * @param   groupID - group ID
    579           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    580           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    581           * @return  ZStatus_t
    582           */
    583          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    584                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    585                                                 uint8 disableDefaultRsp, uint8 seqNum )
    586          {
    587            uint8 buf[3];
    588            uint8 len = 2;
    589          
    590            buf[0] = LO_UINT16( groupID );
    591            buf[1] = HI_UINT16( groupID );
    592          
    593            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    594            {
    595              buf[2] = sceneID;
    596              len++;
    597            }
    598          
    599            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    600                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    601                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    602          }
    603          
    604          /*********************************************************************
    605           * @fn      zclGeneral_SendSceneResponse
    606           *
    607           * @brief   Send Group Response (not Group View Response)
    608           *
    609           * @param   srcEP - Sending application's endpoint
    610           * @param   dstAddr - where you want the message to go
    611           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    612           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    613           * @param   status - scene command status
    614           * @param   groupID - what group
    615           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    616           *
    617           * @return  ZStatus_t
    618           */
    619          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    620                                            uint8 cmd, uint8 status, uint16 groupID,
    621                                            uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    622          {
    623            uint8 buf[4];
    624            uint8 len = 1 + 2; // Status + Group ID
    625          
    626            buf[0] = status;
    627            buf[1] = LO_UINT16( groupID );
    628            buf[2] = HI_UINT16( groupID );
    629          
    630            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    631            {
    632              buf[3] = sceneID;
    633              len++;
    634            }
    635          
    636            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    637                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    638                                    disableDefaultRsp, 0, seqNum, len, buf );
    639          }
    640          
    641          /*********************************************************************
    642           * @fn      zclGeneral_SendSceneViewResponse
    643           *
    644           * @brief   Call to send Scene Response Command
    645           *
    646           * @param   srcEP - Sending application's endpoint
    647           * @param   dstAddr - where you want the message to go
    648           * @param   status - scene command status
    649           * @param   scene - scene info
    650           *
    651           * @return  ZStatus_t
    652           */
    653          ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    654                                                 uint8 status, zclGeneral_Scene_t *scene,
    655                                                 uint8 disableDefaultRsp, uint8 seqNum )
    656          {
    657            uint8 *buf;
    658            uint8 *pBuf;
    659            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    660            ZStatus_t stat;
    661          
    662            if ( status == ZCL_STATUS_SUCCESS )
    663            {
    664              len += 2; // Transition Time
    665              len += scene->name[0] + 1; // string + 1 for length
    666          
    667              // Add something for the extension field length
    668              len += scene->extLen;
    669            }
    670          
    671            buf = osal_mem_alloc( len );
    672            if ( buf )
    673            {
    674              pBuf = buf;
    675              *pBuf++ = status;
    676              *pBuf++ = LO_UINT16( scene->groupID );
    677              *pBuf++ = HI_UINT16( scene->groupID );
    678              *pBuf++ = scene->ID;
    679              if ( status == ZCL_STATUS_SUCCESS )
    680              {
    681                *pBuf++ = LO_UINT16( scene->transTime );
    682                *pBuf++ = HI_UINT16( scene->transTime );
    683                *pBuf++ = scene->name[0]; // string length
    684                if ( scene->name[0] != 0 )
    685                {
    686                  osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    687                  pBuf += scene->name[0]; // move pass name
    688                }
    689          
    690                // Add the extension fields
    691                if ( scene->extLen > 0 )
    692                  osal_memcpy( pBuf, scene->extField, scene->extLen );
    693              }
    694          
    695              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    696                                      COMMAND_SCENE_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    697                                      disableDefaultRsp, 0, seqNum, len, buf );
    698              osal_mem_free( buf );
    699            }
    700            else
    701              stat = ZMemError;
    702          
    703            return ( stat );
    704          }
    705          
    706          /*********************************************************************
    707           * @fn      zclGeneral_SendSceneGetMembershipResponse
    708           *
    709           * @brief   Call to send Scene Get Membership Response Command
    710           *
    711           * @param   srcEP - Sending application's endpoint
    712           * @param   dstAddr - where you want the message to go
    713           * @param   status - scene command status
    714           * @param   capacity - remaining capacity of the scene table
    715           * @param   sceneCnt - number of scenes in the scene list
    716           * @param   sceneList - list of scene IDs
    717           * @param   groupID - group ID that scene belongs to
    718           * @param   seqNum - sequence number
    719           *
    720           * @return  ZStatus_t
    721           */
    722          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    723                                 uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    724                                 uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    725          {
    726            uint8 *buf;
    727            uint8 *pBuf;
    728            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    729            uint8 i;
    730            ZStatus_t stat;
    731          
    732            if ( status == ZCL_STATUS_SUCCESS )
    733            {
    734              len++; // Scene Count
    735              len += sceneCnt; // Scene List (Scene ID is a single octet)
    736            }
    737          
    738            buf = osal_mem_alloc( len );
    739            if ( buf )
    740            {
    741              pBuf = buf;
    742              *pBuf++ = status;
    743              *pBuf++ = capacity;
    744              *pBuf++ = LO_UINT16( groupID );
    745              *pBuf++ = HI_UINT16( groupID );
    746              if ( status == ZCL_STATUS_SUCCESS )
    747              {
    748                *pBuf++ = sceneCnt;
    749                for ( i = 0; i < sceneCnt; i++ )
    750                  *pBuf++ = sceneList[i];
    751              }
    752          
    753              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    754                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    755                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    756              osal_mem_free( buf );
    757            }
    758            else
    759              stat = ZMemError;
    760          
    761            return ( stat );
    762          }
    763          #endif // ZCL_SCENES
    764          
    765          #ifdef ZCL_LEVEL_CTRL
    766          /*********************************************************************
    767           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
    768           *
    769           * @brief   Call to send out a Level Control Request. You can also use
    770           *          the appropriate macro.
    771           *
    772           * @param   srcEP - Sending application's endpoint
    773           * @param   dstAddr - where you want the message to go
    774           * @param   cmd - one of the following:
    775           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
    776           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
    777           * @param   level - what level to move to
    778           * @param   transitionTime - how long to take to get to the level (in seconds)
    779           *
    780           * @return  ZStatus_t
    781           */
    782          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
    783                                                                   uint8 cmd, uint8 level, uint16 transTime,
    784                                                                   uint8 disableDefaultRsp, uint8 seqNum )
    785          {
    786            uint8 buf[3];
    787          
    788            buf[0] = level;
    789            buf[1] = LO_UINT16( transTime );
    790            buf[2] = HI_UINT16( transTime );
    791          
    792            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    793                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    794                                    disableDefaultRsp, 0, seqNum, 3, buf );
    795          }
    796          
    797          /*********************************************************************
    798           * @fn      zclGeneral_SendLevelControlMoveRequest
    799           *
    800           * @brief   Call to send out a Level Control Request. You can also use
    801           *          the appropriate macro.
    802           *
    803           * @param   srcEP - Sending application's endpoint
    804           * @param   dstAddr - where you want the message to go
    805           * @param   cmd - one of the following:
    806           *              COMMAND_LEVEL_MOVE or
    807           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
    808           * @param   moveMode - LEVEL_MOVE_UP or
    809           *                     LEVEL_MOVE_DOWN
    810           * @param   rate - number of steps to take per second
    811           *
    812           * @return  ZStatus_t
    813           */
    814          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
    815                                                            uint8 cmd, uint8 moveMode, uint8 rate,
    816                                                            uint8 disableDefaultRsp, uint8 seqNum )
    817          {
    818            uint8 buf[2];
    819          
    820            buf[0] = moveMode;
    821            buf[1] = rate;
    822          
    823            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    824                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    825                                    disableDefaultRsp, 0, seqNum, 2, buf );
    826          }
    827          
    828          /*********************************************************************
    829           * @fn      zclGeneral_SendLevelControlStepRequest
    830           *
    831           * @brief   Call to send out a Level Control Request. You can also use
    832           *          the appropriate macro.
    833           *
    834           * @param   srcEP - Sending application's endpoint
    835           * @param   dstAddr - where you want the message to go
    836           * @param   cmd - one of the following:
    837           *              COMMAND_LEVEL_STEP
    838           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
    839           * @param   stepMode - LEVEL_STEP_UP or
    840           *                     LEVEL_STEP_DOWN
    841           * @param   amount - number of levels to step
    842           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
    843           *
    844           * @return  ZStatus_t
    845           */
    846          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
    847                                   uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
    848                                   uint8 disableDefaultRsp, uint8 seqNum )
    849          {
    850            uint8 buf[4];
    851          
    852            buf[0] = stepMode;
    853            buf[1] = stepSize;
    854            buf[2] = LO_UINT16( transTime );
    855            buf[3] = HI_UINT16( transTime );
    856          
    857            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    858                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    859                                    disableDefaultRsp, 0, seqNum, 4, buf );
    860          }
    861          #endif // ZCL_LEVEL_CTRL
    862          
    863          #ifdef ZCL_ALARMS
    864          /*********************************************************************
    865           * @fn      zclGeneral_SendAlarmRequest
    866           *
    867           * @brief   Call to send out an Alarm Request Command
    868           *
    869           * @param   srcEP - Sending application's endpoint
    870           * @param   dstAddr - where you want the message to go
    871           * @param   cmd - either COMMAND_ALARMS_RESET or COMMAND_ALARMS_ALARM
    872           * @param   alarmCode - code for the cause of the alarm
    873           * @param   clusterID - cluster whose attribute generate the alarm
    874           *
    875           * @return  ZStatus_t
    876           */
    877          ZStatus_t zclGeneral_SendAlarmRequest( uint8 srcEP, afAddrType_t *dstAddr,
    878                                                 uint8 cmd, uint8 alarmCode, uint16 clusterID,
    879                                                 uint8 disableDefaultRsp, uint8 seqNum )
    880          {
    881            uint8 buf[3];
    882          
    883            buf[0] = alarmCode;
    884            buf[1] = LO_UINT16( clusterID );
    885            buf[2] = HI_UINT16( clusterID );
    886          
    887            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    888                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    889                                    disableDefaultRsp, 0, seqNum, 3, buf );
    890          }
    891          
    892          /*********************************************************************
    893           * @fn      zclGeneral_SendAlarmGetRespnose
    894           *
    895           * @brief   Call to send out an Alarm Get Response Command
    896           *
    897           * @param   srcEP - Sending application's endpoint
    898           * @param   dstAddr - where you want the message to go
    899           * @param   status - SUCCESS or NOT_FOUND
    900           * @param   alarmCode - code for the cause of the alarm
    901           * @param   clusterID - cluster whose attribute generate the alarm
    902           * @param   timeStamp - time at which the alarm occured
    903           *
    904           * @return  ZStatus_t
    905           */
    906          ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
    907                                        uint8 status, uint8 alarmCode, uint16 clusterID,
    908                                        uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
    909          {
    910            uint8 buf[8];
    911            uint8 len = 1; // Status
    912          
    913            buf[0] = status;
    914            if ( status == ZCL_STATUS_SUCCESS )
    915            {
    916              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
    917              buf[1] = alarmCode;
    918              buf[2] = LO_UINT16( clusterID );
    919              buf[3] = HI_UINT16( clusterID );
    920              osal_buffer_uint32( &buf[4], timeStamp );
    921            }
    922          
    923            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    924                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    925                                    disableDefaultRsp, 0, seqNum, len, buf );
    926          }
    927          #endif // ZCL_ALARMS
    928          
    929          #ifdef ZCL_LOCATION
    930          /*********************************************************************
    931           * @fn      zclGeneral_SendLocationSetAbsolute
    932           *
    933           * @brief   Call to send out a Set Absolute Location Command
    934           *
    935           * @param   srcEP - Sending application's endpoint
    936           * @param   dstAddr - where you want the message to go
    937           * @param   absLoc - absolute location info
    938           *
    939           * @return  ZStatus_t
    940           */
    941          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
    942                                                        zclLocationAbsolute_t *absLoc,
    943                                                        uint8 disableDefaultRsp, uint8 seqNum )
    944          {
    945             uint8 buf[10]; // 5 fields (2 octects each)
    946          
    947             buf[0] = LO_UINT16( absLoc->coordinate1 );
    948             buf[1] = HI_UINT16( absLoc->coordinate1 );
    949             buf[2] = LO_UINT16( absLoc->coordinate2 );
    950             buf[3] = HI_UINT16( absLoc->coordinate2 );
    951             buf[4] = LO_UINT16( absLoc->coordinate3 );
    952             buf[5] = HI_UINT16( absLoc->coordinate3 );
    953             buf[6] = LO_UINT16( absLoc->power );
    954             buf[7] = HI_UINT16( absLoc->power );
    955             buf[8] = LO_UINT16( absLoc->pathLossExponent );
    956             buf[9] = HI_UINT16( absLoc->pathLossExponent );
    957          
    958             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    959                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
    960                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
    961          }
    962          
    963          /*********************************************************************
    964           * @fn      zclGeneral_SendLocationSetDevCfg
    965           *
    966           * @brief   Call to send out a Set Device Configuration Command
    967           *
    968           * @param   srcEP - Sending application's endpoint
    969           * @param   dstAddr - where you want the message to go
    970           * @param   devCfg - device configuration info
    971           *
    972           * @return  ZStatus_t
    973           */
    974          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
    975                                                      zclLocationDevCfg_t *devCfg,
    976                                                      uint8 disableDefaultRsp, uint8 seqNum )
    977          {
    978             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
    979          
    980             buf[0] = LO_UINT16( devCfg->power );
    981             buf[1] = HI_UINT16( devCfg->power );
    982             buf[2] = LO_UINT16( devCfg->pathLossExponent );
    983             buf[3] = HI_UINT16( devCfg->pathLossExponent );
    984             buf[4] = LO_UINT16( devCfg->calcPeriod );
    985             buf[5] = HI_UINT16( devCfg->calcPeriod );
    986             buf[6] = devCfg->numMeasurements;
    987             buf[7] = LO_UINT16( devCfg->reportPeriod );
    988             buf[8] = HI_UINT16( devCfg->reportPeriod );
    989          
    990             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    991                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
    992                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
    993          }
    994          
    995          /*********************************************************************
    996           * @fn      zclGeneral_SendLocationGetDevCfg
    997           *
    998           * @brief   Call to send out a Get Device Configuration Command
    999           *
   1000           * @param   srcEP - Sending application's endpoint
   1001           * @param   dstAddr - where you want the message to go
   1002           * @param   targetAddr - device for which location parameters are being requested
   1003           *
   1004           * @return  ZStatus_t
   1005           */
   1006          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1007                                 uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
   1008          {
   1009            uint8 buf[8];
   1010          
   1011            osal_cpyExtAddr( buf, targetAddr );
   1012          
   1013            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1014                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
   1015                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
   1016          }
   1017          
   1018          /*********************************************************************
   1019           * @fn      zclGeneral_SendLocationGetData
   1020           *
   1021           * @brief   Call to send out a Get Location Data Command
   1022           *
   1023           * @param   srcEP - Sending application's endpoint
   1024           * @param   dstAddr - where you want the message to go
   1025           * @param   locaData - location information and channel parameters that are requested.
   1026           *
   1027           * @return  ZStatus_t
   1028           */
   1029          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1030                                                    zclLocationGetData_t *locData,
   1031                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1032          {
   1033            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1034            uint8 *pBuf = buf;
   1035            uint8 len = 2; // bitmap + number responses
   1036          
   1037            *pBuf  = locData->absoluteOnly;
   1038            *pBuf |= locData->recalculate << 1;
   1039            *pBuf |= locData->brdcastIndicator << 2;
   1040            *pBuf |= locData->brdcastResponse << 3;
   1041            *pBuf |= locData->compactResponse << 4;
   1042            pBuf++;  // move past the bitmap field
   1043          
   1044            *pBuf++ = locData->numResponses;
   1045          
   1046            if ( locData->brdcastIndicator == 0 )
   1047            {
   1048              osal_cpyExtAddr( pBuf, locData->targetAddr );
   1049              len += 8; // ieee addr
   1050            }
   1051          
   1052            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1053                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1054                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1055          }
   1056          
   1057          /*********************************************************************
   1058           * @fn      zclGeneral_SendLocationDevCfgResponse
   1059           *
   1060           * @brief   Call to send out a Device Configuration Response Command
   1061           *
   1062           * @param   srcEP - Sending application's endpoint
   1063           * @param   dstAddr - where you want the message to go
   1064           * @param   devCfg - device's location parameters that are requested
   1065           *
   1066           * @return  ZStatus_t
   1067           */
   1068          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1069                                                           zclLocationDevCfgRsp_t *devCfg,
   1070                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1071          {
   1072            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1073            uint8 len = 1; // Status
   1074          
   1075            buf[0] = devCfg->status;
   1076            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1077            {
   1078              buf[1] = LO_UINT16( devCfg->data.power );
   1079              buf[2] = HI_UINT16( devCfg->data.power );
   1080              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1081              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1082              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1083              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1084              buf[7] = devCfg->data.numMeasurements;
   1085              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1086              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1087              len += 9;
   1088            }
   1089          
   1090            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1091                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1092                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1093          }
   1094          
   1095          /*********************************************************************
   1096           * @fn      zclGeneral_SendLocationData
   1097           *
   1098           * @brief   Call to send out location data
   1099           *
   1100           * @param   srcEP - Sending application's endpoint
   1101           * @param   dstAddr - where you want the message to go
   1102           * @param   status - indicates whether response to request was successful or not
   1103           * @param   locData - location information and channel parameters being sent
   1104           *
   1105           * @return  ZStatus_t
   1106           */
   1107          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1108                                                 uint8 status, zclLocationData_t *locData,
   1109                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1110          {
   1111            uint8 buf[16];
   1112            uint8 *pBuf = buf;
   1113            uint8 len = 0;
   1114          
   1115            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1116            {
   1117              // Only response command includes a status field
   1118              *pBuf++ = status;
   1119              len++;
   1120            }
   1121          
   1122            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1123            {
   1124              // Notification or Response with successful status
   1125              *pBuf++ = locData->type;
   1126              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1127              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1128              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1129              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1130              len += 5;
   1131          
   1132              if ( locationType2D(locData->type) == 0 )
   1133              {
   1134                // 2D location doesn't have coordinate 3
   1135                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1136                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1137                len += 2;
   1138              }
   1139          
   1140              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1141              {
   1142                // Compact notification doesn't include these fields
   1143                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1144                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1145                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1146                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1147                len += 4;
   1148              }
   1149          
   1150              if ( locationTypeAbsolute(locData->type) == 0 )
   1151              {
   1152                // Absolute location doesn't include these fields
   1153                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1154                {
   1155                  // Compact notification doesn't include this field
   1156                  *pBuf++ = locData->calcLoc.locationMethod;
   1157                  len++;
   1158                }
   1159          
   1160                *pBuf++ = locData->calcLoc.qualityMeasure;
   1161                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1162                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1163                len += 3;
   1164              }
   1165            }
   1166          
   1167            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1168                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1169                                    disableDefaultRsp, 0, seqNum, len, buf );
   1170          }
   1171          #endif // ZCL_LOCATION
   1172          
   1173          /*********************************************************************
   1174           * @fn      zclGeneral_FindCallbacks
   1175           *
   1176           * @brief   Find the callbacks for an endpoint
   1177           *
   1178           * @param   endpoint - endpoint to find the application callbacks for
   1179           *
   1180           * @return  pointer to the callbacks
   1181           */
   1182          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1183          {
   1184            zclGenCBRec_t *pCBs;
   1185          
   1186            pCBs = zclGenCBs;
   1187            while ( pCBs )
   1188            {
   1189              if ( pCBs->endpoint == endpoint )
   1190                return ( pCBs->CBs );
   1191              pCBs = pCBs->next;
   1192            }
   1193            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1194          }
   1195          
   1196          /*********************************************************************
   1197           * @fn      zclGeneral_HdlIncoming
   1198           *
   1199           * @brief   Callback from ZCL to process incoming Commands specific
   1200           *          to this cluster library or Profile commands for attributes
   1201           *          that aren't in the attribute list
   1202           *
   1203           *
   1204           * @param   pInMsg - pointer to the incoming message
   1205           *
   1206           * @return  ZStatus_t
   1207           */

   \                                 In  segment CODE, align 2, keep-with-next
   1208          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlIncoming:
   1209          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
   1210            ZStatus_t stat = ZSuccess;
   1211          
   1212          #if defined ( INTER_PAN )
   1213            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   \   000004   2F4C         MOV.W   @R12, R15
   \   000006   5D4F0F00     MOV.B   0xf(R15), R13
   \   00000A   1C4F1000     MOV.W   0x10(R15), R12
   \   00000E   ........     CALLA   #StubAPS_InterPan
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   0224         JEQ     ??zclGeneral_HdlIncoming_1
   1214              return ( stat ); // Cluster not supported thru Inter-PAN
   \   000016   4C43         MOV.B   #0x0, R12
   \   000018   0B3C         JMP     ??zclGeneral_HdlIncoming_0
   1215          #endif
   1216            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   \                     ??zclGeneral_HdlIncoming_1:
   \   00001A   5E4A0200     MOV.B   0x2(R10), R14
   \   00001E   7EF00700     AND.B   #0x7, R14
   \   000022   5E93         CMP.B   #0x1, R14
   \   000024   0420         JNE     ??zclGeneral_HdlIncoming_2
   1217            {
   1218              // Is this a manufacturer specific command?
   1219              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   1220              {
   1221                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   \   000026   0C4A         MOV.W   R10, R12
   \   000028   ........     CALLA   #zclGeneral_HdlInSpecificCommands
   \   00002C   013C         JMP     ??zclGeneral_HdlIncoming_0
   1222              }
   1223              else
   1224              {
   1225                // We don't support any manufacturer specific command.
   1226                stat = ZFailure;
   1227              }
   1228            }
   1229            else
   1230            {
   1231              // Handle all the normal (Read, Write...) commands -- should never get here
   1232              stat = ZFailure;
   \                     ??zclGeneral_HdlIncoming_2:
   \   00002E   5C43         MOV.B   #0x1, R12
   1233            }
   1234            return ( stat );
   \                     ??zclGeneral_HdlIncoming_0:
   \   000030   3A41         POP.W   R10
   \   000032   1001         RETA
   1235          }
   1236          
   1237          /*********************************************************************
   1238           * @fn      zclGeneral_HdlInSpecificCommands
   1239           *
   1240           * @brief   Callback from ZCL to process incoming Commands specific
   1241           *          to this cluster library
   1242          
   1243           * @param   pInMsg - pointer to the incoming message
   1244           *
   1245           * @return  ZStatus_t
   1246           */

   \                                 In  segment CODE, align 2, keep-with-next
   1247          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   \                     zclGeneral_HdlInSpecificCommands:
   1248          {
   1249            ZStatus_t stat;
   1250            zclGeneral_AppCallbacks_t *pCBs;
   1251          
   1252            // make sure endpoint exists
   1253            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   \   000000   2F4C         MOV.W   @R12, R15
   \   000002   5E4F1400     MOV.B   0x14(R15), R14
   \   000006   1D42....     MOV.W   &zclGenCBs, R13
   \   00000A   013C         JMP     ??zclGeneral_HdlInSpecificCommands_6
   \                     ??zclGeneral_HdlInSpecificCommands_0:
   \   00000C   2D4D         MOV.W   @R13, R13
   \                     ??zclGeneral_HdlInSpecificCommands_6:
   \   00000E   0D93         CMP.W   #0x0, R13
   \   000010   1A24         JEQ     ??zclGeneral_HdlInSpecificCommands_5
   \   000012   CD9E0200     CMP.B   R14, 0x2(R13)
   \   000016   FA23         JNE     ??zclGeneral_HdlInSpecificCommands_0
   \   000018   1D4D0400     MOV.W   0x4(R13), R13
   1254            if ( pCBs == NULL )
   \   00001C   0D93         CMP.W   #0x0, R13
   \   00001E   1324         JEQ     ??zclGeneral_HdlInSpecificCommands_5
   1255              return ( ZFailure );
   1256          
   1257            switch ( pInMsg->msg->clusterId )
   \   000020   1F4F0400     MOV.W   0x4(R15), R15
   \   000024   0F83         SUB.W   #0x0, R15
   \   000026   0724         JEQ     ??zclGeneral_HdlInSpecificCommands_7
   \   000028   3F800300     SUB.W   #0x3, R15
   \   00002C   1824         JEQ     ??zclGeneral_HdlInSpecificCommands_8
   \   00002E   3F800300     SUB.W   #0x3, R15
   \   000032   1724         JEQ     ??zclGeneral_HdlInSpecificCommands_9
   \   000034   063C         JMP     ??zclGeneral_HdlInSpecificCommands_4
   1258            {
   1259          #ifdef ZCL_BASIC
   1260              case ZCL_CLUSTER_ID_GEN_BASIC:
   1261                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   \                     ??zclGeneral_HdlInSpecificCommands_7:
   \   000036   BCB20200     BIT.W   #0x8, 0x2(R12)
   \   00003A   0F2C         JC      ??zclGeneral_HdlInSpecificCommands_3
   \   00003C   CC930700     CMP.B   #0x0, 0x7(R12)
   \   000040   0424         JEQ     ??zclGeneral_HdlInSpecificCommands_10
   \                     ??zclGeneral_HdlInSpecificCommands_4:
   \   000042   5C43         MOV.B   #0x1, R12
   1262                break;
   1263          #endif // ZCL_BASIC
   1264          
   1265          #ifdef ZCL_IDENTIFY
   1266              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1267                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   1268                break;
   1269          #endif // ZCL_IDENTIFY
   1270          
   1271          #ifdef ZCL_GROUPS
   1272              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1273                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1274                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   1275                else
   1276                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   1277                break;
   1278          #endif // ZCL_GROUPS
   1279          
   1280          #ifdef ZCL_SCENES
   1281              case ZCL_CLUSTER_ID_GEN_SCENES:
   1282                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1283                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1284                else
   1285                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1286                break;
   1287          #endif // ZCL_SCENES
   1288          
   1289          #ifdef ZCL_ON_OFF
   1290              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1291                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   1292                break;
   1293          #endif // ZCL_ON_OFF
   1294          
   1295          #ifdef ZCL_LEVEL_CTRL
   1296              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1297                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1298                break;
   1299          #endif // ZCL_LEVEL_CTRL
   1300          
   1301          #ifdef ZCL_ALARMS
   1302              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1303                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1304                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1305                else
   1306                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1307                break;
   1308          #endif // ZCL_ALARMS
   1309          
   1310          #ifdef ZCL_LOCATION
   1311              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1312                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1313                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1314                else
   1315                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1316                break;
   1317          #endif // ZCL_LOCATION
   1318          
   1319              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1320              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1321              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1322              case ZCL_CLUSTER_ID_GEN_TIME:
   1323              default:
   1324                stat = ZFailure;
   1325                break;
   1326            }
   1327          
   1328            return ( stat );
   \   000044   1001         RETA
   \                     ??zclGeneral_HdlInSpecificCommands_5:
   \   000046   5C43         MOV.B   #0x1, R12
   \   000048   1001         RETA
   \                     ??zclGeneral_HdlInSpecificCommands_10:
   \   00004A   3E4D         MOV.W   @R13+, R14
   \   00004C   3F4D         MOV.W   @R13+, R15
   \   00004E   0D4E         MOV.W   R14, R13
   \   000050   0DDF         BIS.W   R15, R13
   \   000052   0D93         CMP.W   #0x0, R13
   \   000054   0224         JEQ     ??zclGeneral_HdlInSpecificCommands_3
   \   000056   ........     CALLA   #?IndCallR15
   \                     ??zclGeneral_HdlInSpecificCommands_3:
   \   00005A   4C43         MOV.B   #0x0, R12
   \   00005C   1001         RETA
   \                     ??zclGeneral_HdlInSpecificCommands_8:
   \   00005E   ........     BRA     #zclGeneral_ProcessInIdentity
   \                     ??zclGeneral_HdlInSpecificCommands_9:
   \   000062   BCB20200     BIT.W   #0x8, 0x2(R12)
   \   000066   F92F         JC      ??zclGeneral_HdlInSpecificCommands_3
   \   000068   5C4C0700     MOV.B   0x7(R12), R12
   \   00006C   7C900300     CMP.B   #0x3, R12
   \   000070   E82F         JC      ??zclGeneral_HdlInSpecificCommands_4
   \   000072   1E4D0C00     MOV.W   0xc(R13), R14
   \   000076   1F4D0E00     MOV.W   0xe(R13), R15
   \   00007A   0D4E         MOV.W   R14, R13
   \   00007C   0DDF         BIS.W   R15, R13
   \   00007E   0D93         CMP.W   #0x0, R13
   \   000080   EC27         JEQ     ??zclGeneral_HdlInSpecificCommands_3
   \   000082   ........     CALLA   #?IndCallR15
   \   000086   E93F         JMP     ??zclGeneral_HdlInSpecificCommands_3
   \   000088   0343         NOP
   1329          }
   1330          
   1331          #ifdef ZCL_BASIC
   1332          /*********************************************************************
   1333           * @fn      zclGeneral_ProcessInBasic
   1334           *
   1335           * @brief   Process in the received Basic Command.
   1336           *
   1337           * @param   pInMsg - pointer to the incoming message
   1338           *
   1339           * @return  ZStatus_t
   1340           */
   1341          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1342                                                      zclGeneral_AppCallbacks_t *pCBs )
   1343          {
   1344            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1345            {
   1346              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1347                return ( ZFailure );   // Error ignore the command
   1348          
   1349              if ( pCBs->pfnBasicReset )
   1350                pCBs->pfnBasicReset();
   1351            }
   1352            // no Client command
   1353          
   1354            return ( ZSuccess );
   1355          }
   1356          #endif // ZCL_BASIC
   1357          
   1358          #ifdef ZCL_IDENTIFY
   1359          /*********************************************************************
   1360           * @fn      zclGeneral_ProcessInIdentity
   1361           *
   1362           * @brief   Process in the received Identity Command.
   1363           *
   1364           * @param   pInMsg - pointer to the incoming message
   1365           *
   1366           * @return  ZStatus_t
   1367           */

   \                                 In  segment CODE, align 2, keep-with-next
   1368          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   \                     zclGeneral_ProcessInIdentity:
   1369                                                         zclGeneral_AppCallbacks_t *pCBs )
   1370          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   31800E00     SUB.W   #0xe, SP
   \   000006   084C         MOV.W   R12, R8
   1371            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   \   000008   5E4C0700     MOV.B   0x7(R12), R14
   \   00000C   BCB20200     BIT.W   #0x8, 0x2(R12)
   \   000010   332C         JC      ??zclGeneral_ProcessInIdentity_0
   1372            {
   1373              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY )
   \   000012   6E93         CMP.B   #0x2, R14
   \   000014   332C         JC      ??zclGeneral_ProcessInIdentity_1
   1374                return ( ZFailure );   // Error ignore the command
   1375          
   1376              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   \   000016   4E93         CMP.B   #0x0, R14
   \   000018   0520         JNE     ??zclGeneral_ProcessInIdentity_2
   1377              {
   1378                if ( pCBs->pfnIdentify )
   \   00001A   1A4D0400     MOV.W   0x4(R13), R10
   \   00001E   1B4D0600     MOV.W   0x6(R13), R11
   \   000022   323C         JMP     ??zclGeneral_ProcessInIdentity_3
   1379                {
   1380                  zclIdentify_t cmd;
   1381          
   1382                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1383                  cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1384          
   1385                  pCBs->pfnIdentify( &cmd );
   1386                }
   1387              }
   1388              else
   1389              {
   1390                zclAttrRec_t attrRec;
   1391                uint16 identifyTime = 0;
   \                     ??zclGeneral_ProcessInIdentity_2:
   \   000024   81430400     MOV.W   #0x0, 0x4(SP)
   1392          
   1393                // Retrieve Identify Time
   1394                if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, ATTRID_IDENTIFY_TIME, &attrRec ) )
   \   000028   2B4C         MOV.W   @R12, R11
   \   00002A   0F41         MOV.W   SP, R15
   \   00002C   3F500600     ADD.W   #0x6, R15
   \   000030   0E43         MOV.W   #0x0, R14
   \   000032   1D4B0400     MOV.W   0x4(R11), R13
   \   000036   5C4B1400     MOV.B   0x14(R11), R12
   \   00003A   ........     CALLA   #zclFindAttrRec
   \   00003E   4C93         CMP.B   #0x0, R12
   \   000040   0824         JEQ     ??zclGeneral_ProcessInIdentity_4
   1395                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec, NULL );
   \   000042   0E43         MOV.W   #0x0, R14
   \   000044   0D41         MOV.W   SP, R13
   \   000046   3D500600     ADD.W   #0x6, R13
   \   00004A   0C41         MOV.W   SP, R12
   \   00004C   2C52         ADD.W   #0x4, R12
   \   00004E   ........     CALLA   #zclReadAttrData
   1396          
   1397                // Is device identifying itself?
   1398                if ( identifyTime > 0 )
   \                     ??zclGeneral_ProcessInIdentity_4:
   \   000052   81930400     CMP.W   #0x0, 0x4(SP)
   \   000056   0E24         JEQ     ??zclGeneral_ProcessInIdentity_5
   1399                {
   1400                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1401                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   \   000058   2B48         MOV.W   @R8, R11
   \   00005A   58120600     PUSH.B  0x6(R8)
   \   00005E   5F43         MOV.B   #0x1, R15
   \   000060   1E410600     MOV.W   0x6(SP), R14
   \   000064   0D4B         MOV.W   R11, R13
   \   000066   3D500600     ADD.W   #0x6, R13
   \   00006A   5C4B1400     MOV.B   0x14(R11), R12
   \   00006E   ........     CALLA   #zclGeneral_SendIdentifyQueryResponse
   \   000072   2153         ADD.W   #0x2, SP
   1402                }
   1403          
   1404                return ( ZCL_STATUS_CMD_HAS_RSP );
   \                     ??zclGeneral_ProcessInIdentity_5:
   \   000074   7C43         MOV.B   #0xff, R12
   \   000076   1F3C         JMP     ??zclGeneral_ProcessInIdentity_6
   1405              }
   1406            }
   1407            else // Client Command
   1408            {
   1409              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   \                     ??zclGeneral_ProcessInIdentity_0:
   \   000078   4E93         CMP.B   #0x0, R14
   \   00007A   0224         JEQ     ??zclGeneral_ProcessInIdentity_7
   1410                return ( ZFailure );   // Error ignore the command
   \                     ??zclGeneral_ProcessInIdentity_1:
   \   00007C   5C43         MOV.B   #0x1, R12
   \   00007E   1B3C         JMP     ??zclGeneral_ProcessInIdentity_6
   1411          
   1412              if ( pCBs->pfnIdentifyQueryRsp )
   \                     ??zclGeneral_ProcessInIdentity_7:
   \   000080   1A4D0800     MOV.W   0x8(R13), R10
   \   000084   1B4D0A00     MOV.W   0xa(R13), R11
   \                     ??zclGeneral_ProcessInIdentity_3:
   \   000088   0F4A         MOV.W   R10, R15
   \   00008A   0FDB         BIS.W   R11, R15
   \   00008C   0F93         CMP.W   #0x0, R15
   \   00008E   1224         JEQ     ??zclGeneral_ProcessInIdentity_8
   1413              {
   1414                zclIdentifyQueryRsp_t rsp;
   1415          
   1416                rsp.srcAddr = &(pInMsg->msg->srcAddr);
   \   000090   2F4C         MOV.W   @R12, R15
   \   000092   3F500600     ADD.W   #0x6, R15
   \   000096   814F0000     MOV.W   R15, 0(SP)
   1417                rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   \   00009A   1F4C0800     MOV.W   0x8(R12), R15
   \   00009E   6E4F         MOV.B   @R15, R14
   \   0000A0   5F4F0100     MOV.B   0x1(R15), R15
   \   0000A4                RPT     #0x8
   \   0000A4   47180F5F     RLAX.W  R15
   \   0000A8   0E5F         ADD.W   R15, R14
   \   0000AA   814E0200     MOV.W   R14, 0x2(SP)
   1418          
   1419                pCBs->pfnIdentifyQueryRsp( &rsp );
   \   0000AE   0C41         MOV.W   SP, R12
   \   0000B0   ........     CALLA   #?IndCallR11
   1420              }
   1421            }
   1422          
   1423            return ( ZSuccess );
   \                     ??zclGeneral_ProcessInIdentity_8:
   \   0000B4   4C43         MOV.B   #0x0, R12
   \                     ??zclGeneral_ProcessInIdentity_6:
   \   0000B6   31500E00     ADD.W   #0xe, SP
   \   0000BA   3817         POPM.W  #0x4, R11
   \   0000BC   1001         RETA
   1424          }
   1425          #endif // ZCL_IDENTIFY
   1426          
   1427          #ifdef ZCL_GROUPS
   1428          
   1429          /*********************************************************************
   1430           * @fn      zclGeneral_AddGroup
   1431           *
   1432           * @brief   Add a Group.
   1433           *
   1434           * @param   endPoint - application endpoint
   1435           * @param   group - group to be added
   1436           * @param   pData - pointer to the group info
   1437           *
   1438           * @return  ZStatus_t
   1439           */
   1440          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   1441          {
   1442            zclAttrRec_t attrRec;
   1443            uint8 nameLen;
   1444            uint8 nameSupport = FALSE;
   1445          
   1446            pData += 2;   // Move past group ID
   1447            nameLen = *pData++;
   1448          
   1449            // Retrieve Name Support attribute
   1450            if ( zclFindAttrRec( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS, ATTRID_GROUP_NAME_SUPPORT, &attrRec ) )
   1451               zclReadAttrData( &nameSupport, &attrRec, NULL );
   1452          
   1453            if ( nameSupport )
   1454            {
   1455              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1456                 nameLen = (APS_GROUP_NAME_LEN-1);
   1457              group->name[0] = nameLen;
   1458              osal_memcpy( &(group->name[1]), pData, nameLen );
   1459            }
   1460          
   1461            return ( aps_AddGroup( endPoint, group ) );
   1462          }
   1463          
   1464          /*********************************************************************
   1465           * @fn      zclGeneral_ProcessInGroupsServer
   1466           *
   1467           * @brief   Process in the received Groups Command.
   1468           *
   1469           * @param   pInMsg - pointer to the incoming message
   1470           *
   1471           * @return  ZStatus_t
   1472           */
   1473          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   1474          {
   1475            zclAttrRec_t attrRec;
   1476            aps_Group_t group;
   1477            aps_Group_t *pGroup;
   1478            uint8 *pData;
   1479            uint8 status;
   1480            uint8 grpCnt;
   1481            uint8 grpRspCnt = 0;
   1482            uint16 *grpList;
   1483            uint16 identifyTime = 0;
   1484            uint8 i;
   1485            ZStatus_t stat = ZSuccess;
   1486          
   1487            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1488          
   1489            pData = pInMsg->pData;
   1490            group.ID = BUILD_UINT16( pData[0], pData[1] );
   1491            switch ( pInMsg->hdr.commandID )
   1492            {
   1493              case COMMAND_GROUP_ADD:
   1494                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1495                if ( status != ZSuccess )
   1496                {
   1497                  if ( status == ZApsDuplicateEntry )
   1498                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   1499                  else
   1500                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   1501                }
   1502          
   1503                zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1504                                                 status, group.ID, true, pInMsg->hdr.transSeqNum );
   1505                stat = ZCL_STATUS_CMD_HAS_RSP;
   1506                break;
   1507          
   1508              case COMMAND_GROUP_VIEW:
   1509                pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   1510                if ( pGroup )
   1511                {
   1512                  status = ZCL_STATUS_SUCCESS;
   1513                }
   1514                else
   1515                {
   1516                  // Group not found
   1517                  status = ZCL_STATUS_NOT_FOUND;
   1518                  pGroup = &group;
   1519                }
   1520                zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1521                                                  status, pGroup, true, pInMsg->hdr.transSeqNum );
   1522                stat = ZCL_STATUS_CMD_HAS_RSP;
   1523                break;
   1524          
   1525              case COMMAND_GROUP_GET_MEMBERSHIP:
   1526                grpCnt = *pData++;
   1527          
   1528                // Allocate space for the group list
   1529                grpList = osal_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   1530                if ( grpList != NULL )
   1531                {
   1532                  if ( grpCnt == 0 )
   1533                  {
   1534                    // Find out all the groups of which the endpoint is a member.
   1535                    grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   1536                  }
   1537                  else
   1538                  {
   1539                    // Find out the groups (in the list) of which the endpoint is a member.
   1540                    for ( i = 0; i < grpCnt; i++ )
   1541                    {
   1542                      group.ID = BUILD_UINT16( pData[0], pData[1] );
   1543                      pData += 2;
   1544          
   1545                      if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   1546                        grpList[grpRspCnt++] = group.ID;
   1547                    }
   1548                  }
   1549          
   1550                  if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1551                  {
   1552                    zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1553                                                               aps_GroupsRemaingCapacity(), grpRspCnt,
   1554                                                               grpList, true, pInMsg->hdr.transSeqNum );
   1555                  }
   1556          
   1557                  osal_mem_free( grpList );
   1558                }
   1559                else
   1560                {
   1561                  // Couldn't allocate space for the group list -- send a Default Response command back.
   1562                  zclDefaultRspCmd_t defaultRspCmd;
   1563          
   1564                  defaultRspCmd.commandID = pInMsg->hdr.commandID;
   1565                  defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   1566                  zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1567                                         pInMsg->msg->clusterId, &defaultRspCmd,
   1568                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   1569                }
   1570          
   1571                stat = ZCL_STATUS_CMD_HAS_RSP;
   1572                break;
   1573          
   1574              case COMMAND_GROUP_REMOVE:
   1575                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   1576                  status = ZCL_STATUS_SUCCESS;
   1577                else
   1578                  status = ZCL_STATUS_NOT_FOUND;
   1579                zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1580                                                    status, group.ID, true, pInMsg->hdr.transSeqNum );
   1581                stat = ZCL_STATUS_CMD_HAS_RSP;
   1582                break;
   1583          
   1584              case COMMAND_GROUP_REMOVE_ALL:
   1585                aps_RemoveAllGroup( pInMsg->msg->endPoint );
   1586                break;
   1587          
   1588              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   1589                // Retrieve Identify Time
   1590                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY, ATTRID_IDENTIFY_TIME, &attrRec ) )
   1591                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec, NULL );
   1592          
   1593                // Is device identifying itself?
   1594                if ( identifyTime > 0 )
   1595                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1596                break;
   1597          
   1598              default:
   1599                stat = ZFailure;
   1600                break;
   1601            }
   1602          
   1603            return ( stat );
   1604          }
   1605          
   1606          /*********************************************************************
   1607           * @fn      zclGeneral_ProcessInGroupsClient
   1608           *
   1609           * @brief   Process in the received Groups Command.
   1610           *
   1611           * @param   pInMsg - pointer to the incoming message
   1612           *
   1613           * @return  ZStatus_t
   1614           */
   1615          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   1616                                                             zclGeneral_AppCallbacks_t *pCBs )
   1617          {
   1618            aps_Group_t group;
   1619            uint8 *pData = pInMsg->pData;
   1620            uint8 grpCnt;
   1621            uint8 nameLen;
   1622            zclGroupRsp_t rsp;
   1623            uint8 i;
   1624            ZStatus_t stat = ZSuccess;
   1625          
   1626            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1627            osal_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   1628          
   1629            switch ( pInMsg->hdr.commandID )
   1630            {
   1631              case COMMAND_GROUP_ADD_RSP:
   1632              case COMMAND_GROUP_VIEW_RSP:
   1633              case COMMAND_GROUP_REMOVE_RSP:
   1634                rsp.status = *pData++;
   1635                group.ID = BUILD_UINT16( pData[0], pData[1] );
   1636          
   1637                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   1638                {
   1639                  pData += 2;   // Move past ID
   1640                  nameLen = *pData++;
   1641                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1642                    nameLen = (APS_GROUP_NAME_LEN-1);
   1643                  group.name[0] = nameLen;
   1644                  osal_memcpy( &(group.name[1]), pData, nameLen );
   1645                  rsp.grpName = group.name;
   1646                }
   1647          
   1648                if ( pCBs->pfnGroupRsp )
   1649                {
   1650                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1651                  rsp.cmdID = pInMsg->hdr.commandID;
   1652                  rsp.grpCnt = 1;
   1653                  rsp.grpList = &group.ID;
   1654                  rsp.capacity = 0;
   1655          
   1656                  pCBs->pfnGroupRsp( &rsp );
   1657                }
   1658                break;
   1659          
   1660              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   1661                {
   1662                  uint16 *grpList = NULL;
   1663                  rsp.capacity = *pData++;
   1664                  grpCnt = *pData++;
   1665          
   1666                  if ( grpCnt > 0 )
   1667                  {
   1668                    // Allocate space for the group list
   1669                    grpList = osal_mem_alloc( sizeof( uint16 ) * grpCnt );
   1670                    if ( grpList != NULL )
   1671                    {
   1672                      rsp.grpCnt = grpCnt;
   1673                      for ( i = 0; i < grpCnt; i++ )
   1674                      {
   1675                        grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   1676                        pData += 2;
   1677                      }
   1678                    }
   1679                  }
   1680          
   1681                  if ( pCBs->pfnGroupRsp )
   1682                  {
   1683                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1684                    rsp.cmdID = pInMsg->hdr.commandID;
   1685                    rsp.grpList = grpList;
   1686          
   1687                    pCBs->pfnGroupRsp( &rsp );
   1688                  }
   1689          
   1690                  if ( grpList != NULL )
   1691                  {
   1692                    osal_mem_free( grpList );
   1693                  }
   1694                }
   1695                break;
   1696          
   1697              default:
   1698                stat = ZFailure;
   1699                break;
   1700            }
   1701          
   1702            return ( stat );
   1703          }
   1704          #endif // ZCL_GROUPS
   1705          
   1706          #ifdef ZCL_SCENES
   1707          /*********************************************************************
   1708           * @fn      zclGeneral_AddScene
   1709           *
   1710           * @brief   Add a scene for an endpoint
   1711           *
   1712           * @param   endpoint -
   1713           * @param   scene - new scene item
   1714           *
   1715           * @return  ZStatus_t
   1716           */
   1717          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   1718          {
   1719            zclGenSceneItem_t *pNewItem;
   1720            zclGenSceneItem_t *pLoop;
   1721          
   1722            // Fill in the new profile list
   1723            pNewItem = osal_mem_alloc( sizeof( zclGenSceneItem_t ) );
   1724            if ( pNewItem == NULL )
   1725              return ( ZMemError );
   1726          
   1727            // Fill in the plugin record.
   1728            pNewItem->next = (zclGenSceneItem_t *)NULL;
   1729            pNewItem->endpoint = endpoint;
   1730            osal_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   1731          
   1732            // Find spot in list
   1733            if (  zclGenSceneTable == NULL )
   1734            {
   1735              zclGenSceneTable = pNewItem;
   1736            }
   1737            else
   1738            {
   1739              // Look for end of list
   1740              pLoop = zclGenSceneTable;
   1741              while ( pLoop->next != NULL )
   1742                pLoop = pLoop->next;
   1743          
   1744              // Put new item at end of list
   1745              pLoop->next = pNewItem;
   1746            }
   1747          
   1748            // Update NV
   1749            zclGeneral_ScenesWriteNV();
   1750          
   1751            return ( ZSuccess );
   1752          }
   1753          
   1754          /*********************************************************************
   1755           * @fn      zclGeneral_FindScene
   1756           *
   1757           * @brief   Find a scene with endpoint and sceneID
   1758           *
   1759           * @param   endpoint -
   1760           * @param   groupID - what group the scene belongs to
   1761           * @param   sceneID - ID to look for scene
   1762           *
   1763           * @return  a pointer to the scene information, NULL if not found
   1764           */
   1765          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1766          {
   1767            zclGenSceneItem_t *pLoop;
   1768          
   1769            // Look for end of list
   1770            pLoop = zclGenSceneTable;
   1771            while ( pLoop )
   1772            {
   1773              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   1774                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1775              {
   1776                return ( &(pLoop->scene) );
   1777              }
   1778              pLoop = pLoop->next;
   1779            }
   1780          
   1781            return ( (zclGeneral_Scene_t *)NULL );
   1782          }
   1783          
   1784          /*********************************************************************
   1785           * @fn      aps_FindAllScensForGroup
   1786           *
   1787           * @brief   Find all the scenes with groupID
   1788           *
   1789           * @param   endpoint - endpoint to look for
   1790           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   1791           *
   1792           * @return  number of scenes copied to sceneList
   1793           */
   1794          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   1795          {
   1796            zclGenSceneItem_t *pLoop;
   1797            uint8 cnt = 0;
   1798          
   1799            // Look for end of list
   1800            pLoop = zclGenSceneTable;
   1801            while ( pLoop )
   1802            {
   1803              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1804                sceneList[cnt++] = pLoop->scene.ID;
   1805              pLoop = pLoop->next;
   1806            }
   1807            return ( cnt );
   1808          }
   1809          
   1810          /*********************************************************************
   1811           * @fn      zclGeneral_RemoveScene
   1812           *
   1813           * @brief   Remove a scene with endpoint and sceneID
   1814           *
   1815           * @param   endpoint -
   1816           * @param   groupID - what group the scene belongs to
   1817           * @param   sceneID - ID to look for scene
   1818           *
   1819           * @return  TRUE if removed, FALSE if not found
   1820           */
   1821          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1822          {
   1823            zclGenSceneItem_t *pLoop;
   1824            zclGenSceneItem_t *pPrev;
   1825          
   1826            // Look for end of list
   1827            pLoop = zclGenSceneTable;
   1828            pPrev = NULL;
   1829            while ( pLoop )
   1830            {
   1831              if ( pLoop->endpoint == endpoint
   1832                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1833              {
   1834                if ( pPrev == NULL )
   1835                  zclGenSceneTable = pLoop->next;
   1836                else
   1837                  pPrev->next = pLoop->next;
   1838          
   1839                // Free the memory
   1840                osal_mem_free( pLoop );
   1841          
   1842                // Update NV
   1843                zclGeneral_ScenesWriteNV();
   1844          
   1845                return ( TRUE );
   1846              }
   1847              pPrev = pLoop;
   1848              pLoop = pLoop->next;
   1849            }
   1850          
   1851            return ( FALSE );
   1852          }
   1853          
   1854          /*********************************************************************
   1855           * @fn      zclGeneral_RemoveAllScenes
   1856           *
   1857           * @brief   Remove all scenes with endpoint and group Id
   1858           *
   1859           * @param   endpoint -
   1860           * @param   groupID - ID to look for group
   1861           *
   1862           * @return  none
   1863           */
   1864          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   1865          {
   1866            zclGenSceneItem_t *pLoop;
   1867            zclGenSceneItem_t *pPrev;
   1868            zclGenSceneItem_t *pNext;
   1869          
   1870            // Look for end of list
   1871            pLoop = zclGenSceneTable;
   1872            pPrev = NULL;
   1873            while ( pLoop )
   1874            {
   1875              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1876              {
   1877                if ( pPrev == NULL )
   1878                  zclGenSceneTable = pLoop->next;
   1879                else
   1880                  pPrev->next = pLoop->next;
   1881                pNext = pLoop->next;
   1882          
   1883                // Free the memory
   1884                osal_mem_free( pLoop );
   1885                pLoop = pNext;
   1886              }
   1887              else
   1888              {
   1889                pPrev = pLoop;
   1890                pLoop = pLoop->next;
   1891              }
   1892            }
   1893          
   1894            // Update NV
   1895            zclGeneral_ScenesWriteNV();
   1896          }
   1897          
   1898          /*********************************************************************
   1899           * @fn      zclGeneral_CountScenes
   1900           *
   1901           * @brief   Count the number of scenes for an endpoint
   1902           *
   1903           * @param   endpoint -
   1904           *
   1905           * @return  number of scenes assigned to an endpoint
   1906           */
   1907          uint8 zclGeneral_CountScenes( uint8 endpoint )
   1908          {
   1909            zclGenSceneItem_t *pLoop;
   1910            uint8 cnt = 0;
   1911          
   1912            // Look for end of list
   1913            pLoop = zclGenSceneTable;
   1914            while ( pLoop )
   1915            {
   1916              if ( pLoop->endpoint == endpoint  )
   1917                cnt++;
   1918              pLoop = pLoop->next;
   1919            }
   1920            return ( cnt );
   1921          }
   1922          
   1923          /*********************************************************************
   1924           * @fn      zclGeneral_CountAllScenes
   1925           *
   1926           * @brief   Count the total number of scenes
   1927           *
   1928           * @param   none
   1929           *
   1930           * @return  number of scenes
   1931           */
   1932          uint8 zclGeneral_CountAllScenes( void )
   1933          {
   1934            zclGenSceneItem_t *pLoop;
   1935            uint8 cnt = 0;
   1936          
   1937            // Look for end of list
   1938            pLoop = zclGenSceneTable;
   1939            while ( pLoop )
   1940            {
   1941              cnt++;
   1942              pLoop = pLoop->next;
   1943            }
   1944            return ( cnt );
   1945          }
   1946          
   1947          /*********************************************************************
   1948           * @fn      zclGeneral_ReadSceneCountCB
   1949           *
   1950           * @brief   Read the number of scenes currently in the device's
   1951           *          scene table (i.e., the Scene Count attribute).
   1952           *
   1953           *          Note: This function gets called only when the pointer
   1954           *                'dataPtr' to the Scene Count attribute value is
   1955           *                NULL in the attribute database registered with
   1956           *                the ZCL.
   1957           *
   1958           * @param   clusterId - cluster that attribute belongs to
   1959           * @param   attrId - attribute to be read
   1960           * @param   oper - ZCL_OPER_LEN, ZCL_OPER_READ
   1961           * @param   pValue - pointer to attribute value
   1962           * @param   pLen - pointer to length of attribute value read
   1963           *
   1964           * @return  status
   1965           */
   1966          ZStatus_t zclGeneral_ReadSceneCountCB( uint16 clusterId, uint16 attrId,
   1967                                                 uint8 oper, uint8 *pValue, uint16 *pLen )
   1968          {
   1969            ZStatus_t status = ZCL_STATUS_SUCCESS;
   1970          
   1971            // This callback function should only be called for the Scene Count attribute
   1972            switch ( oper )
   1973            {
   1974              case ZCL_OPER_LEN:
   1975                *pLen = 1; // uint8
   1976                break;
   1977          
   1978              case ZCL_OPER_READ:
   1979                *pValue = zclGeneral_CountAllScenes();
   1980          
   1981                if ( pLen != NULL )
   1982                {
   1983                  *pLen = 1;
   1984                }
   1985                break;
   1986          
   1987              default:
   1988                status = ZCL_STATUS_SOFTWARE_FAILURE; // should never get here!
   1989                break;
   1990            }
   1991          
   1992            return ( status );
   1993          }
   1994          
   1995          /*********************************************************************
   1996           * @fn      zclGeneral_ProcessInScenesServer
   1997           *
   1998           * @brief   Process in the received Scenes Command.
   1999           *
   2000           * @param   pInMsg - pointer to the incoming message
   2001           *
   2002           * @return  ZStatus_t
   2003           */
   2004          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   2005                                                             zclGeneral_AppCallbacks_t *pCBs )
   2006          {
   2007            zclAttrRec_t attrRec;
   2008            zclGeneral_Scene_t scene;
   2009            zclGeneral_Scene_t *pScene;
   2010            uint8 *pData = pInMsg->pData;
   2011            uint8 nameLen;
   2012            uint8 status;
   2013            uint8 sceneCnt = 0;
   2014            uint8 *sceneList = NULL;
   2015            uint8 sendRsp = FALSE;
   2016            uint8 nameSupport = FALSE;
   2017            ZStatus_t stat = ZSuccess;
   2018          
   2019            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2020          
   2021            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2022            pData += 2;   // Move past group ID
   2023            scene.ID = *pData++;
   2024          
   2025            switch ( pInMsg->hdr.commandID )
   2026            {
   2027              case COMMAND_SCENE_ADD:
   2028                // Parse the rest of the incoming message
   2029                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2030                pData += 2;
   2031                nameLen= *pData++; // Name length
   2032          
   2033                // Retrieve Name Support attribute
   2034                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES, ATTRID_SCENES_NAME_SUPPORT, &attrRec ) )
   2035                {
   2036                  zclReadAttrData( &nameSupport, &attrRec, NULL );
   2037                }
   2038          
   2039                if ( nameSupport )
   2040                {
   2041                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2042                  {
   2043                    // truncate to maximum size
   2044                    scene.name[0] = ZCL_GEN_SCENE_NAME_LEN-1;
   2045                  }
   2046                  else
   2047                  {
   2048                    scene.name[0] = nameLen;
   2049                  }
   2050                  osal_memcpy( &(scene.name[1]), pData, scene.name[0] );
   2051                }
   2052          
   2053                pData += nameLen; // move past name, use original length
   2054          
   2055                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   2056                if ( scene.extLen > 0 )
   2057                {
   2058                  // Copy the extention field(s)
   2059                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   2060                  {
   2061                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   2062                  }
   2063                  osal_memcpy( scene.extField, pData, scene.extLen );
   2064                }
   2065          
   2066                if ( scene.groupID == 0x0000 ||
   2067                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2068                {
   2069                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2070                  // does and the corresponding Group exits
   2071                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2072                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2073                  {
   2074                    status = ZCL_STATUS_SUCCESS;
   2075                    if ( pScene != NULL )
   2076                    {
   2077                      // The Scene already exists so update it
   2078                      pScene->transTime = scene.transTime;
   2079                      osal_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   2080          
   2081                      // Use the new extention field(s)
   2082                      osal_memcpy( pScene->extField, scene.extField, scene.extLen );
   2083                      pScene->extLen = scene.extLen;
   2084          
   2085                      // Update NV
   2086                      zclGeneral_ScenesWriteNV();
   2087                    }
   2088                    else
   2089                    {
   2090                      // The Scene doesn't exist so add it
   2091                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2092                    }
   2093                  }
   2094                  else
   2095                  {
   2096                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2097                  }
   2098                }
   2099                else
   2100                {
   2101                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2102                }
   2103          
   2104                zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2105                                                 status, scene.groupID, scene.ID,
   2106                                                 true, pInMsg->hdr.transSeqNum );
   2107                stat = ZCL_STATUS_CMD_HAS_RSP;
   2108                break;
   2109          
   2110              case COMMAND_SCENE_VIEW:
   2111                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2112                if ( pScene != NULL )
   2113                {
   2114                  status = ZCL_STATUS_SUCCESS;
   2115                }
   2116                else
   2117                {
   2118                  // Scene not found
   2119                  if ( scene.groupID != 0x0000 &&
   2120                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2121                  {
   2122                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2123                  }
   2124                  else
   2125                  {
   2126                    status = ZCL_STATUS_NOT_FOUND;
   2127                  }
   2128                  pScene = &scene;
   2129                }
   2130                zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2131                                                  status, pScene, true, pInMsg->hdr.transSeqNum );
   2132                stat = ZCL_STATUS_CMD_HAS_RSP;
   2133                break;
   2134          
   2135              case COMMAND_SCENE_REMOVE:
   2136                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2137                {
   2138                  status = ZCL_STATUS_SUCCESS;
   2139                }
   2140                else
   2141                {
   2142                  // Scene not found
   2143                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2144                  {
   2145                    // The Group is not in the Group Table
   2146                    status = ZCL_STATUS_INVALID_FIELD;
   2147                  }
   2148                  else
   2149                  {
   2150                    status = ZCL_STATUS_NOT_FOUND;
   2151                  }
   2152                }
   2153          
   2154                if ( UNICAST_MSG( pInMsg->msg ) )
   2155                {
   2156                  // Addressed to this device (not to a group) - send a response back
   2157                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2158                                                      status, scene.groupID,
   2159                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2160                }
   2161                stat = ZCL_STATUS_CMD_HAS_RSP;
   2162                break;
   2163          
   2164              case COMMAND_SCENE_REMOVE_ALL:
   2165                if ( scene.groupID == 0x0000 ||
   2166                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2167                {
   2168                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2169                  status = ZCL_STATUS_SUCCESS;
   2170                }
   2171                else
   2172                {
   2173                  status = ZCL_STATUS_INVALID_FIELD;
   2174                }
   2175          
   2176                if ( UNICAST_MSG( pInMsg->msg ) )
   2177                {
   2178                  // Addressed to this device (not to a group) - send a response back
   2179                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2180                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2181                }
   2182                stat = ZCL_STATUS_CMD_HAS_RSP;
   2183                break;
   2184          
   2185              case COMMAND_SCENE_STORE:
   2186                if ( scene.groupID == 0x0000 ||
   2187                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2188                {
   2189                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2190                  // does and the corresponding Group exits
   2191                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2192                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2193                  {
   2194                    uint8 sceneChanged = FALSE;
   2195          
   2196                    status = ZCL_STATUS_SUCCESS;
   2197                    if ( pScene == NULL )
   2198                    {
   2199                      // Haven't been added yet
   2200                      pScene = &scene;
   2201                    }
   2202          
   2203                    if ( pCBs->pfnSceneStoreReq )
   2204                    {
   2205                      zclSceneReq_t req;
   2206          
   2207                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2208                      req.scene = pScene;
   2209          
   2210                      // Get the latest Scene info
   2211                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2212                      {
   2213                        sceneChanged = TRUE;
   2214                      }
   2215                    }
   2216          
   2217                    if ( pScene == &scene )
   2218                    {
   2219                      // The Scene doesn't exist so add it
   2220                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2221                    }
   2222                    else if ( sceneChanged )
   2223                    {
   2224                      // The Scene already exists so update only NV
   2225                      zclGeneral_ScenesWriteNV();
   2226                    }
   2227                  }
   2228                  else
   2229                  {
   2230                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2231                  }
   2232                }
   2233                else
   2234                {
   2235                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2236                }
   2237          
   2238                if ( UNICAST_MSG( pInMsg->msg ) )
   2239                {
   2240                  // Addressed to this device (not to a group) - send a response back
   2241                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2242                                                     status, scene.groupID, scene.ID,
   2243                                                     true, pInMsg->hdr.transSeqNum );
   2244                }
   2245                stat = ZCL_STATUS_CMD_HAS_RSP;
   2246                break;
   2247          
   2248              case COMMAND_SCENE_RECALL:
   2249                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2250                if ( pScene && pCBs->pfnSceneRecallReq )
   2251                {
   2252                  zclSceneReq_t req;
   2253          
   2254                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2255                  req.scene = pScene;
   2256          
   2257                  pCBs->pfnSceneRecallReq( &req );
   2258                }
   2259                // No response
   2260                break;
   2261          
   2262              case COMMAND_SCENE_GET_MEMBERSHIP:
   2263                // Find all the Scenes corresponding to the Group ID
   2264                if ( scene.groupID == 0x0000 ||
   2265                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2266                {
   2267                  // Allocate space for the scene list
   2268                  sceneList = osal_mem_alloc( ZCL_GEN_MAX_SCENES );
   2269                  if ( sceneList != NULL )
   2270                  {
   2271                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint,
   2272                                                                 scene.groupID, sceneList );
   2273                    status = ZCL_STATUS_SUCCESS;
   2274                    if ( UNICAST_MSG( pInMsg->msg ) )
   2275                    {
   2276                      // Addressed only to this device - send a response back
   2277                      sendRsp = TRUE;
   2278                    }
   2279                    else
   2280                    {
   2281                      // Addressed to the Group - ONLY send a response if an entry within the
   2282                      // Scene Table corresponds to the Group ID
   2283                      if ( sceneCnt != 0 )
   2284                      {
   2285                        sendRsp = TRUE;
   2286                      }
   2287                    }
   2288                  }
   2289                  else
   2290                  {
   2291                    // Couldn't allocate space for the scene list!
   2292                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2293                    sendRsp = TRUE;
   2294                  }
   2295                }
   2296                else
   2297                {
   2298                  // The Group is not in the Group Table - send a response back
   2299                  status = ZCL_STATUS_INVALID_FIELD;
   2300                  sendRsp = TRUE;
   2301                }
   2302          
   2303                if ( sendRsp )
   2304                {
   2305                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2306                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2307                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2308                }
   2309          
   2310                if ( sceneList != NULL )
   2311                {
   2312                  osal_mem_free( sceneList );
   2313                }
   2314          
   2315                stat = ZCL_STATUS_CMD_HAS_RSP;
   2316                break;
   2317          
   2318              default:
   2319                stat = ZFailure;
   2320              break;
   2321            }
   2322          
   2323            return ( stat );
   2324          }
   2325          
   2326          /*********************************************************************
   2327           * @fn      zclGeneral_ProcessInScenesClient
   2328           *
   2329           * @brief   Process in the received Scenes Command.
   2330           *
   2331           * @param   pInMsg - pointer to the incoming message
   2332           *
   2333           * @return  ZStatus_t
   2334           */
   2335          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2336                                                             zclGeneral_AppCallbacks_t *pCBs )
   2337          {
   2338            zclGeneral_Scene_t scene;
   2339            uint8 *pData = pInMsg->pData;
   2340            uint8 nameLen;
   2341            zclSceneRsp_t rsp;
   2342            uint8 i;
   2343            ZStatus_t stat = ZSuccess;
   2344          
   2345            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2346            osal_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2347          
   2348            // Get the status field first
   2349            rsp.status = *pData++;
   2350          
   2351            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2352            {
   2353              rsp.capacity = *pData++;
   2354            }
   2355          
   2356            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2357            pData += 2;   // Move past group ID
   2358          
   2359            switch ( pInMsg->hdr.commandID )
   2360            {
   2361              case COMMAND_SCENE_VIEW_RSP:
   2362                // Parse the rest of the incoming message
   2363                scene.ID = *pData++; // Not applicable to Remove All Response command
   2364                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2365                pData += 2;
   2366                nameLen = *pData++; // Name length
   2367                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2368                {
   2369                  // truncate to maximum size
   2370                  scene.name[0] = ZCL_GEN_SCENE_NAME_LEN-1;
   2371                }
   2372                else
   2373                {
   2374                  scene.name[0] = nameLen;
   2375                }
   2376                osal_memcpy( &(scene.name[1]), pData, scene.name[0] );
   2377          
   2378                pData += nameLen; // move past name, use original length
   2379          
   2380                //*** Do something with the extension field(s)
   2381          
   2382                // Fall through to callback - break is left off intentionally
   2383          
   2384              case COMMAND_SCENE_ADD_RSP:
   2385              case COMMAND_SCENE_REMOVE_RSP:
   2386              case COMMAND_SCENE_REMOVE_ALL_RSP:
   2387              case COMMAND_SCENE_STORE_RSP:
   2388                if ( pCBs->pfnSceneRsp )
   2389                {
   2390                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2391                  rsp.cmdID = pInMsg->hdr.commandID;
   2392                  rsp.scene = &scene;
   2393          
   2394                  pCBs->pfnSceneRsp( &rsp );
   2395                }
   2396                break;
   2397          
   2398              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   2399                {
   2400                  uint8 *sceneList = NULL;
   2401          
   2402                  if ( rsp.status == ZCL_STATUS_SUCCESS )
   2403                  {
   2404                    uint8 sceneCnt = *pData++;
   2405          
   2406                    if ( sceneCnt > 0 )
   2407                    {
   2408                      // Allocate space for the scene list
   2409                      sceneList = osal_mem_alloc( sceneCnt );
   2410                      if ( sceneList != NULL )
   2411                      {
   2412                        rsp.sceneCnt = sceneCnt;
   2413                        for ( i = 0; i < sceneCnt; i++ )
   2414                          sceneList[i] = *pData++;
   2415                      }
   2416                    }
   2417                  }
   2418          
   2419                  if ( pCBs->pfnSceneRsp )
   2420                  {
   2421                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2422                    rsp.cmdID = pInMsg->hdr.commandID;
   2423                    rsp.sceneList = sceneList;
   2424                    rsp.scene = &scene;
   2425          
   2426                    pCBs->pfnSceneRsp( &rsp);
   2427                  }
   2428          
   2429                  if ( sceneList != NULL )
   2430                  {
   2431                    osal_mem_free( sceneList );
   2432                  }
   2433                }
   2434                break;
   2435          
   2436              default:
   2437                stat = ZFailure;
   2438                break;
   2439            }
   2440          
   2441            return ( stat );
   2442          }
   2443          #endif // ZCL_SCENES
   2444          
   2445          #ifdef ZCL_ON_OFF
   2446          /*********************************************************************
   2447           * @fn      zclGeneral_ProcessInCmdOnOff
   2448           *
   2449           * @brief   Process in the received On/Off Command.
   2450           *
   2451           * @param   pInMsg - pointer to the incoming message
   2452           *
   2453           * @return  ZStatus_t
   2454           */
   2455          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   2456                                                      zclGeneral_AppCallbacks_t *pCBs )
   2457          {
   2458            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2459            {
   2460              if ( pInMsg->hdr.commandID > COMMAND_TOGGLE )
   2461                return ( ZFailure );   // Error ignore the command
   2462          
   2463              if ( pCBs->pfnOnOff )
   2464                pCBs->pfnOnOff( pInMsg->hdr.commandID );
   2465            }
   2466            // no Client command
   2467          
   2468            return ( ZSuccess );
   2469          }
   2470          #endif // ZCL_ON_OFF
   2471          
   2472          #ifdef ZCL_LEVEL_CTRL
   2473          /*********************************************************************
   2474           * @fn      zclGeneral_ProcessInLevelControl
   2475           *
   2476           * @brief   Process in the received Level Control Command.
   2477           *
   2478           * @param   pInMsg - pointer to the incoming message
   2479           *
   2480           * @return  ZStatus_t
   2481           */
   2482          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   2483                                                             zclGeneral_AppCallbacks_t *pCBs )
   2484          {
   2485            uint8 withOnOff = FALSE;
   2486            ZStatus_t stat = ZSuccess;
   2487          
   2488            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2489            {
   2490              switch ( pInMsg->hdr.commandID )
   2491              {
   2492                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   2493                  withOnOff = TRUE;
   2494                  // fall through
   2495                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   2496                  if ( pCBs->pfnLevelControlMoveToLevel )
   2497                  {
   2498                    zclLCMoveToLevel_t cmd;
   2499          
   2500                    cmd.level = pInMsg->pData[0];
   2501                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   2502                    cmd.withOnOff = withOnOff;
   2503          
   2504                    pCBs->pfnLevelControlMoveToLevel( &cmd );
   2505                  }
   2506                  break;
   2507          
   2508                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   2509                  withOnOff = TRUE;
   2510                  // fall through
   2511                case COMMAND_LEVEL_MOVE:
   2512                  if ( pCBs->pfnLevelControlMove )
   2513                  {
   2514                    zclLCMove_t cmd;
   2515          
   2516                    cmd.moveMode = pInMsg->pData[0];
   2517                    cmd.rate = pInMsg->pData[1];
   2518                    cmd.withOnOff = withOnOff;
   2519          
   2520                    pCBs->pfnLevelControlMove( &cmd );
   2521                  }
   2522                  break;
   2523          
   2524                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   2525                  withOnOff = TRUE;
   2526                  // fall through
   2527                case COMMAND_LEVEL_STEP:
   2528                  if ( pCBs->pfnLevelControlStep )
   2529                  {
   2530                    zclLCStep_t cmd;
   2531          
   2532                    cmd.stepMode = pInMsg->pData[0];
   2533                    cmd.amount =  pInMsg->pData[1];
   2534                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   2535                    cmd.withOnOff = withOnOff;
   2536          
   2537                    pCBs->pfnLevelControlStep( &cmd );
   2538                  }
   2539                  break;
   2540          
   2541                case COMMAND_LEVEL_STOP:
   2542                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   2543                  // Both Stop commands are identical
   2544                  if ( pCBs->pfnLevelControlStop )
   2545                  {
   2546                    pCBs->pfnLevelControlStop();
   2547                  }
   2548                  break;
   2549          
   2550                default:
   2551                  stat = ZFailure;
   2552                  break;
   2553              }
   2554            }
   2555            // no Client command
   2556          
   2557            return ( stat );
   2558          }
   2559          #endif // ZCL_LEVEL_CTRL
   2560          
   2561          #ifdef ZCL_ALARMS
   2562          /*********************************************************************
   2563           * @fn      zclGeneral_AddAlarm
   2564           *
   2565           * @brief   Add an alarm for a cluster
   2566           *
   2567           * @param   endpoint -
   2568           * @param   alarm - new alarm item
   2569           *
   2570           * @return  ZStatus_t
   2571           */
   2572          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   2573          {
   2574            zclGenAlarmItem_t *pNewItem;
   2575            zclGenAlarmItem_t *pLoop;
   2576          
   2577            // Fill in the new profile list
   2578            pNewItem = osal_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   2579            if ( pNewItem == NULL )
   2580              return ( ZMemError );
   2581          
   2582            // Fill in the plugin record.
   2583            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   2584            pNewItem->endpoint =  endpoint;
   2585            osal_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   2586          
   2587            // Find spot in list
   2588            if (  zclGenAlarmTable == NULL )
   2589            {
   2590              zclGenAlarmTable = pNewItem;
   2591            }
   2592            else
   2593            {
   2594              // Look for end of list
   2595              pLoop = zclGenAlarmTable;
   2596              while ( pLoop->next != NULL )
   2597                pLoop = pLoop->next;
   2598          
   2599              // Put new item at end of list
   2600              pLoop->next = pNewItem;
   2601            }
   2602          
   2603            return ( ZSuccess );
   2604          }
   2605          
   2606          /*********************************************************************
   2607           * @fn      zclGeneral_FindAlarm
   2608           *
   2609           * @brief   Find an alarm with alarmCode and clusterID
   2610           *
   2611           * @param   endpoint -
   2612           * @param   groupID - what group the scene belongs to
   2613           * @param   sceneID - ID to look for scene
   2614           *
   2615           * @return  a pointer to the alarm information, NULL if not found
   2616           */
   2617          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2618          {
   2619            zclGenAlarmItem_t *pLoop;
   2620          
   2621            // Look for the alarm
   2622            pLoop = zclGenAlarmTable;
   2623            while ( pLoop )
   2624            {
   2625              if ( pLoop->endpoint == endpoint &&
   2626                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2627              {
   2628                return ( &(pLoop->alarm) );
   2629              }
   2630              pLoop = pLoop->next;
   2631            }
   2632          
   2633            return ( (zclGeneral_Alarm_t *)NULL );
   2634          }
   2635          
   2636          /*********************************************************************
   2637           * @fn      zclGeneral_FindEarliestAlarm
   2638           *
   2639           * @brief   Find an alarm with the earliest timestamp
   2640           *
   2641           * @param   endpoint -
   2642           *
   2643           * @return  a pointer to the alarm information, NULL if not found
   2644           */
   2645          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   2646          {
   2647            zclGenAlarmItem_t *pLoop;
   2648            zclGenAlarmItem_t earliestAlarm;
   2649            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   2650          
   2651            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   2652          
   2653            // Look for alarm with earliest time
   2654            pLoop = zclGenAlarmTable;
   2655            while ( pLoop )
   2656            {
   2657              if ( pLoop->endpoint == endpoint &&
   2658                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   2659              {
   2660                pEarliestAlarm = pLoop;
   2661              }
   2662              pLoop = pLoop->next;
   2663            }
   2664          
   2665            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   2666              return ( &(pEarliestAlarm->alarm) );
   2667          
   2668            // No alarm
   2669            return ( (zclGeneral_Alarm_t *)NULL );
   2670          }
   2671          
   2672          /*********************************************************************
   2673           * @fn      zclGeneral_ResetAlarm
   2674           *
   2675           * @brief   Remove a scene with endpoint and sceneID
   2676           *
   2677           * @param   endpoint -
   2678           * @param   alarmCode -
   2679           * @param   clusterID -
   2680           *
   2681           * @return  TRUE if removed, FALSE if not found
   2682           */
   2683          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2684          {
   2685            zclGenAlarmItem_t *pLoop;
   2686            zclGenAlarmItem_t *pPrev;
   2687          
   2688            // Look for end of list
   2689            pLoop = zclGenAlarmTable;
   2690            pPrev = NULL;
   2691            while ( pLoop )
   2692            {
   2693              if ( pLoop->endpoint == endpoint &&
   2694                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2695              {
   2696                if ( pPrev == NULL )
   2697                  zclGenAlarmTable = pLoop->next;
   2698                else
   2699                  pPrev->next = pLoop->next;
   2700          
   2701                // Free the memory
   2702                osal_mem_free( pLoop );
   2703          
   2704                // Notify the Application so that if the alarm condition still active then
   2705                // a new notification will be generated, and a new alarm record will be
   2706                // added to the alarm log
   2707                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   2708                return;
   2709              }
   2710              pPrev = pLoop;
   2711              pLoop = pLoop->next;
   2712            }
   2713          }
   2714          
   2715          /*********************************************************************
   2716           * @fn      zclGeneral_ResetAllAlarms
   2717           *
   2718           * @brief   Remove all alarms with endpoint
   2719           *
   2720           * @param   endpoint -
   2721           * @param   notifyApp -
   2722           *
   2723           * @return  none
   2724           */
   2725          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   2726          {
   2727            zclGenAlarmItem_t *pLoop;
   2728            zclGenAlarmItem_t *pPrev;
   2729            zclGenAlarmItem_t *pNext;
   2730          
   2731            // Look for end of list
   2732            pLoop = zclGenAlarmTable;
   2733            pPrev = NULL;
   2734            while ( pLoop )
   2735            {
   2736              if (  pLoop->endpoint == endpoint )
   2737              {
   2738                if ( pPrev == NULL )
   2739                  zclGenAlarmTable = pLoop->next;
   2740                else
   2741                  pPrev->next = pLoop->next;
   2742          
   2743                pNext = pLoop->next;
   2744          
   2745                // Free the memory
   2746                osal_mem_free( pLoop );
   2747          
   2748                pLoop = pNext;
   2749              }
   2750              else
   2751              {
   2752                pPrev = pLoop;
   2753                pLoop = pLoop->next;
   2754              }
   2755            }
   2756          
   2757            if ( notifyApp )
   2758            {
   2759              // Notify the Application so that if any alarm conditions still active then
   2760              // a new notification will be generated, and a new alarm record will be
   2761              // added to the alarm log
   2762              // zclGeneral_NotifyResetAll(); // callback function?
   2763            }
   2764          }
   2765          
   2766          /*********************************************************************
   2767           * @fn      zclGeneral_ProcessInAlarmsServer
   2768           *
   2769           * @brief   Process in the received Alarms Command.
   2770           *
   2771           * @param   pInMsg - pointer to the incoming message
   2772           *
   2773           * @return  ZStatus_t
   2774           */
   2775          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   2776                                                             zclGeneral_AppCallbacks_t *pCBs )
   2777          {
   2778            zclGeneral_Alarm_t *pAlarm;
   2779            uint8 *pData = pInMsg->pData;
   2780            ZStatus_t stat = ZSuccess;
   2781          
   2782            switch ( pInMsg->hdr.commandID )
   2783            {
   2784              case COMMAND_ALARMS_RESET:
   2785                zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pData[0],
   2786                                       BUILD_UINT16( pData[1], pData[2] ) );
   2787                break;
   2788          
   2789              case COMMAND_ALARMS_RESET_ALL:
   2790                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, TRUE );
   2791                break;
   2792          
   2793              case COMMAND_ALARMS_GET:
   2794                pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   2795                if ( pAlarm )
   2796                {
   2797                  // Send a response back
   2798                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2799                                                   ZCL_STATUS_SUCCESS, pAlarm->code,
   2800                                                   pAlarm->clusterID, pAlarm->timeStamp,
   2801                                                   true, pInMsg->hdr.transSeqNum );
   2802                  // Remove the entry from the Alarm table
   2803                  zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   2804                }
   2805                else
   2806                {
   2807                  // Send a response back
   2808                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2809                                                   ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   2810                                                   true, pInMsg->hdr.transSeqNum );
   2811                }
   2812                stat = ZCL_STATUS_CMD_HAS_RSP;
   2813                break;
   2814          
   2815              case COMMAND_ALARMS_RESET_LOG:
   2816                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   2817                break;
   2818          
   2819              default:
   2820                stat = ZFailure;
   2821                break;
   2822            }
   2823          
   2824            return ( stat );
   2825          }
   2826          
   2827          /*********************************************************************
   2828           * @fn      zclGeneral_ProcessInAlarmsClient
   2829           *
   2830           * @brief   Process in the received Alarms Command.
   2831           *
   2832           * @param   pInMsg - pointer to the incoming message
   2833           *
   2834           * @return  ZStatus_t
   2835           */
   2836          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   2837                                                             zclGeneral_AppCallbacks_t *pCBs )
   2838          {
   2839            uint8 *pData = pInMsg->pData;
   2840            zclAlarm_t alarm;
   2841            ZStatus_t stat = ZSuccess;
   2842          
   2843            osal_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   2844          
   2845            switch ( pInMsg->hdr.commandID )
   2846            {
   2847              case COMMAND_ALARMS_ALARM:
   2848                if ( pCBs->pfnAlarm )
   2849                {
   2850                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2851                  alarm.cmdID = pInMsg->hdr.commandID;
   2852                  alarm.status = *pData++;
   2853                  alarm.alarmCode = *pData++;
   2854                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2855                  pData += 2;
   2856                  alarm.timeStamp = osal_build_uint32( pData, 4 );
   2857          
   2858                  pCBs->pfnAlarm( &alarm );
   2859                }
   2860                break;
   2861          
   2862              case COMMAND_ALARMS_GET_RSP:
   2863                if ( pCBs->pfnAlarm )
   2864                {
   2865                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2866                  alarm.cmdID = pInMsg->hdr.commandID;
   2867                  alarm.alarmCode = *pData++;
   2868                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2869          
   2870                  pCBs->pfnAlarm( &alarm );
   2871                }
   2872                break;
   2873          
   2874              default:
   2875                stat = ZFailure;
   2876                break;
   2877            }
   2878          
   2879            return ( stat );
   2880          }
   2881          #endif // ZCL_ALARMS
   2882          
   2883          #ifdef ZCL_LOCATION
   2884          /*********************************************************************
   2885           * @fn      zclGeneral_ProcessInLocationServer
   2886           *
   2887           * @brief   Process in the received Location Command.
   2888           *
   2889           * @param   pInMsg - pointer to the incoming message
   2890           *
   2891           * @return  ZStatus_t
   2892           */
   2893          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   2894                                                               zclGeneral_AppCallbacks_t *pCBs )
   2895          {
   2896            uint8 *pData = pInMsg->pData;
   2897            zclLocation_t cmd;
   2898            ZStatus_t stat = ZSuccess;
   2899          
   2900            osal_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   2901          
   2902            switch ( pInMsg->hdr.commandID )
   2903            {
   2904              case COMMAND_LOCATION_SET_ABSOLUTE:
   2905                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   2906                pData += 2;
   2907                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   2908                pData += 2;
   2909                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   2910                pData += 2;
   2911                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   2912                pData += 2;
   2913                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2914          
   2915                if ( pCBs->pfnLocation )
   2916                {
   2917                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2918                  cmd.cmdID = pInMsg->hdr.commandID;
   2919          
   2920                  // Update the absolute location info
   2921                  pCBs->pfnLocation( &cmd );
   2922                }
   2923                break;
   2924          
   2925              case COMMAND_LOCATION_SET_DEV_CFG:
   2926                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   2927                pData += 2;
   2928                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2929                pData += 2;
   2930                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   2931                pData += 2;
   2932                cmd.un.devCfg.numMeasurements = *pData++;
   2933                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   2934          
   2935                if ( pCBs->pfnLocation )
   2936                {
   2937                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2938                  cmd.cmdID = pInMsg->hdr.commandID;
   2939          
   2940                  // Update the device configuration info
   2941                  pCBs->pfnLocation( &cmd );
   2942                }
   2943                break;
   2944          
   2945              case COMMAND_LOCATION_GET_DEV_CFG:
   2946                cmd.un.ieeeAddr = pData;
   2947          
   2948                if ( pCBs->pfnLocation )
   2949                {
   2950                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2951                  cmd.cmdID = pInMsg->hdr.commandID;
   2952                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   2953          
   2954                  // Retreive the Device Configuration
   2955                  pCBs->pfnLocation( &cmd );
   2956                }
   2957                stat = ZCL_STATUS_CMD_HAS_RSP;
   2958                break;
   2959          
   2960              case COMMAND_LOCATION_GET_DATA:
   2961                cmd.un.loc.bitmap.locByte = *pData++;
   2962                cmd.un.loc.numResponses = *pData++;
   2963          
   2964                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   2965                  osal_cpyExtAddr( cmd.un.loc.targetAddr, pData );
   2966          
   2967                if ( pCBs->pfnLocation )
   2968                {
   2969                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2970                  cmd.cmdID = pInMsg->hdr.commandID;
   2971                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   2972          
   2973                  // Retreive the Location Data
   2974                  pCBs->pfnLocation( &cmd );
   2975                }
   2976                stat = ZCL_STATUS_CMD_HAS_RSP;
   2977                break;
   2978          
   2979              default:
   2980                stat = ZFailure;
   2981                break;
   2982            }
   2983          
   2984            return ( stat );
   2985          }
   2986          
   2987          /*********************************************************************
   2988           * @fn      zclGeneral_ProcessInLocationDataRsp
   2989           *
   2990           * @brief   Process in the received Location Command.
   2991           *
   2992           * @param   pInMsg - pointer to the incoming message
   2993           *
   2994           * @return  ZStatus_t
   2995           */
   2996          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   2997                                                           zclGeneral_AppCallbacks_t *pCBs )
   2998          {
   2999            uint8 *pData = pInMsg->pData;
   3000            zclLocationRsp_t rsp;
   3001          
   3002            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3003          
   3004            if ( pCBs->pfnLocationRsp )
   3005            {
   3006              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   3007                rsp.un.loc.status = *pData++;
   3008          
   3009              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   3010                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   3011              {
   3012                rsp.un.loc.data.type = *pData++;
   3013                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   3014                pData += 2;
   3015                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   3016                pData += 2;
   3017          
   3018                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   3019                {
   3020                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   3021                  pData += 2;
   3022                }
   3023          
   3024                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3025                {
   3026                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   3027                  pData += 2;
   3028                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3029                  pData += 2;
   3030                }
   3031          
   3032                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   3033                {
   3034                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   3035                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   3036          
   3037                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   3038                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   3039                }
   3040              }
   3041          
   3042              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3043              rsp.cmdID = pInMsg->hdr.commandID;
   3044          
   3045              // Notify the Application
   3046              pCBs->pfnLocationRsp( &rsp );
   3047            }
   3048          }
   3049          
   3050          /*********************************************************************
   3051           * @fn      zclGeneral_ProcessInLocationClient
   3052           *
   3053           * @brief   Process in the received Location Command.
   3054           *
   3055           * @param   pInMsg - pointer to the incoming message
   3056           *
   3057           * @return  ZStatus_t
   3058           */
   3059          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   3060                                                               zclGeneral_AppCallbacks_t *pCBs )
   3061          {
   3062            uint8 *pData = pInMsg->pData;
   3063            zclLocationRsp_t rsp;
   3064            ZStatus_t stat = ZSuccess;
   3065          
   3066            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   3067          
   3068            switch ( pInMsg->hdr.commandID )
   3069            {
   3070              case COMMAND_LOCATION_DEV_CFG_RSP:
   3071                if ( pCBs->pfnLocationRsp )
   3072                {
   3073                  rsp.un.devCfg.status = *pData++;
   3074                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   3075                  {
   3076                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   3077                    pData += 2;
   3078                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   3079                    pData += 2;
   3080                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   3081                    pData += 2;
   3082                    rsp.un.devCfg.data.numMeasurements = *pData++;
   3083                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   3084          
   3085                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3086                    rsp.cmdID = pInMsg->hdr.commandID;
   3087          
   3088                    // Notify the Application
   3089                    pCBs->pfnLocationRsp( &rsp );
   3090                  }
   3091                }
   3092                break;
   3093          
   3094              case COMMAND_LOCATION_DATA_RSP:
   3095              case COMMAND_LOCATION_DATA_NOTIF:
   3096              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   3097                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   3098                break;
   3099          
   3100              case COMMAND_LOCATION_RSSI_PING:
   3101                if ( pCBs->pfnLocationRsp )
   3102                {
   3103                  rsp.un.locationType = *pData;
   3104          
   3105                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3106                  rsp.cmdID = pInMsg->hdr.commandID;
   3107          
   3108                  // Notify the Application
   3109                  pCBs->pfnLocationRsp( &rsp );
   3110                }
   3111                break;
   3112          
   3113              default:
   3114                stat = ZFailure;
   3115                break;
   3116            }
   3117          
   3118            return ( stat );
   3119          }
   3120          #endif // ZCL_LOCATION
   3121          
   3122          #ifdef ZCL_SCENES
   3123          /*********************************************************************
   3124           * @fn      zclGeneral_ScenesInitNV
   3125           *
   3126           * @brief   Initialize the NV Scene Table Items
   3127           *
   3128           * @param   none
   3129           *
   3130           * @return  number of scenes
   3131           */
   3132          static uint8 zclGeneral_ScenesInitNV( void )
   3133          {
   3134            uint8  status;
   3135            uint16 size;
   3136          
   3137            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3138                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3139          
   3140            status = osal_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3141          
   3142            if ( status != ZSUCCESS )
   3143            {
   3144              zclGeneral_ScenesSetDefaultNV();
   3145            }
   3146          
   3147            return status;
   3148          }
   3149          
   3150          /*********************************************************************
   3151           * @fn          zclGeneral_ScenesSetDefaultNV
   3152           *
   3153           * @brief       Write the defaults to NV
   3154           *
   3155           * @param       none
   3156           *
   3157           * @return      none
   3158           */
   3159          static void zclGeneral_ScenesSetDefaultNV( void )
   3160          {
   3161            nvGenScenesHdr_t hdr;
   3162          
   3163            // Initialize the header
   3164            hdr.numRecs = 0;
   3165          
   3166            // Save off the header
   3167            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3168          }
   3169          
   3170          /*********************************************************************
   3171           * @fn          zclGeneral_ScenesWriteNV
   3172           *
   3173           * @brief       Save the Scene Table in NV
   3174           *
   3175           * @param       none
   3176           *
   3177           * @return      none
   3178           */
   3179          static void zclGeneral_ScenesWriteNV( void )
   3180          {
   3181            nvGenScenesHdr_t hdr;
   3182            zclGenSceneItem_t *pLoop;
   3183            zclGenSceneNVItem_t item;
   3184          
   3185            hdr.numRecs = 0;
   3186          
   3187            // Look for end of list
   3188            pLoop = zclGenSceneTable;
   3189            while ( pLoop )
   3190            {
   3191              // Build the record
   3192              item.endpoint = pLoop->endpoint;
   3193              osal_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3194          
   3195              // Save the record to NV
   3196              osal_nv_write( ZCD_NV_SCENE_TABLE,
   3197                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3198                              sizeof ( zclGenSceneNVItem_t ), &item );
   3199          
   3200              hdr.numRecs++;
   3201          
   3202              pLoop = pLoop->next;
   3203            }
   3204          
   3205            // Save off the header
   3206            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3207          }
   3208          
   3209          /*********************************************************************
   3210           * @fn          zclGeneral_ScenesRestoreFromNV
   3211           *
   3212           * @brief       Restore the Scene table from NV
   3213           *
   3214           * @param       none
   3215           *
   3216           * @return      Number of entries restored
   3217           */
   3218          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   3219          {
   3220            uint16 x;
   3221            nvGenScenesHdr_t hdr;
   3222          
   3223            zclGenSceneNVItem_t item;
   3224            uint16 numAdded = 0;
   3225          
   3226            if ( osal_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   3227            {
   3228              // Read in the device list
   3229              for ( x = 0; x < hdr.numRecs; x++ )
   3230              {
   3231                if ( osal_nv_read( ZCD_NV_SCENE_TABLE,
   3232                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   3233                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   3234                {
   3235                  // Add the scene
   3236                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   3237                  {
   3238                    numAdded++;
   3239                  }
   3240                }
   3241              }
   3242            }
   3243          
   3244            return ( numAdded );
   3245          }
   3246          #endif // ZCL_SCENES
   3247          
   3248          /***************************************************************************
   3249          ****************************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       4  zclGeneral_HdlInSpecificCommands
             4 -- Indirect call
             4 -> zclGeneral_ProcessInIdentity
       6  zclGeneral_HdlIncoming
             6 -> StubAPS_InterPan
             6 -> zclGeneral_HdlInSpecificCommands
      28  zclGeneral_ProcessInIdentity
            26 -- Indirect call
            26 -> zclFindAttrRec
            28 -> zclGeneral_SendIdentifyQueryResponse
            26 -> zclReadAttrData
       8  zclGeneral_RegisterCmdCallbacks
             8 -> osal_mem_alloc
             8 -> zcl_registerPlugin
      20  zclGeneral_SendIdentify
            20 -> zcl_SendCommand
      20  zclGeneral_SendIdentifyQueryResponse
            20 -> zcl_SendCommand


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      18  ?Subroutine0
      14  ?Subroutine1
       2  zclGenCBs
       1  zclGenPluginRegisted
     138  zclGeneral_HdlInSpecificCommands
      52  zclGeneral_HdlIncoming
     190  zclGeneral_ProcessInIdentity
      96  zclGeneral_RegisterCmdCallbacks
      26  zclGeneral_SendIdentify
      22  zclGeneral_SendIdentifyQueryResponse

 
 556 bytes in segment CODE
   3 bytes in segment DATA16_Z
 
 556 bytes of CODE memory
   3 bytes of DATA memory

Errors: none
Warnings: none
