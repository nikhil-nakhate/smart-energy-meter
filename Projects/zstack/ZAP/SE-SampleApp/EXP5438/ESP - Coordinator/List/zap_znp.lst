###############################################################################
#                                                                             #
#                                                       29/Jan/2012  16:16:21 #
# IAR C/C++ Compiler V5.40.2.20380/W32, Evaluation edition for MSP430         #
# Copyright 1996-2011 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\Source\zap_znp.c                                     #
#    Command line  =  -f "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\Source\zap.cfg"       #
#                     (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=!ZAP_PHY_SPI            #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f   #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\..\..\..\Tools\MSP5438\f8wZCL. #
#                     cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC                #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE) "C:\Texas Instruments\ZAP-MSP430-2.5.0\P #
#                     rojects\zstack\ZAP\Source\zap_znp.c" -D                 #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D             #
#                     TC_LINKKEY_JOIN -D ZCL_REPORT -D INTER_PAN -lC          #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\List\" -lA   #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\List\"       #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\Obj\"        #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\" -I "C:\Texas                 #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\Source\" -I "C:\Texas                 #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\Source\" -I "C:\Texas              #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\hal\target\MSP #
#                     5438ZAP\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pro #
#                     jects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Co #
#                     mponents\hal\include\" -I "C:\Texas                     #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\mac\include\"  #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\m #
#                     t\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\ #
#                     zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Componen #
#                     ts\osal\include\" -I "C:\Texas                          #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\osal\mcu\msp43 #
#                     0\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\ #
#                     zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Componen #
#                     ts\services\saddr\" -I "C:\Texas                        #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\services\sdata #
#                     \" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\z #
#                     stack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\ #
#                     Projects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\.. #
#                     \Components\stack\nwk\" -I "C:\Texas                    #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\stack\sapi\"   #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\s #
#                     tack\sec\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pr #
#                     ojects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\C #
#                     omponents\stack\sys\" -I "C:\Texas                      #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\stack\zcl\"    #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\s #
#                     tack\zdo\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pr #
#                     ojects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\C #
#                     omponents\zmac\" -I "C:\Texas                           #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\zmac\f8w\"     #
#                     --core=430X --data_model=small -Ohz --multiplier=32     #
#                     --multiplier_location=4C0 --require_prototypes          #
#                     --hw_workaround=CPU40                                   #
#    List file     =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\SE-SampleApp\EXP5438\ESP -                           #
#                     Coordinator\List\zap_znp.lst                            #
#    Object file   =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\SE-SampleApp\EXP5438\ESP -                           #
#                     Coordinator\Obj\zap_znp.r43                             #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\Source\zap_znp.c
      1          /**************************************************************************************************
      2              Filename:       zap_znp.c
      3              Revised:        $Date: 2010-07-28 17:08:02 -0700 (Wed, 28 Jul 2010) $
      4              Revision:       $Revision: 23200 $
      5          
      6              Description:
      7          
      8              This file defines the ZAP proxy functionality to the ZNP.
      9          
     10          
     11              Copyright 2009-2010 Texas Instruments Incorporated. All rights reserved.
     12          
     13              IMPORTANT: Your use of this Software is limited to those specific rights
     14              granted under the terms of a software license agreement between the user
     15              who downloaded the software, his/her employer (which must be your employer)
     16              and Texas Instruments Incorporated (the "License").  You may not use this
     17              Software unless you agree to abide by the terms of the License. The License
     18              limits your use, and you acknowledge, that the Software may not be modified,
     19              copied or distributed unless embedded on a Texas Instruments microcontroller
     20              or used solely and exclusively in conjunction with a Texas Instruments radio
     21              frequency transceiver, which is integrated into your product.  Other than for
     22              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23              works of, modify, distribute, perform, display or sell this Software and/or
     24              its documentation for any purpose.
     25          
     26              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     28              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     29              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38              Should you have any questions regarding your right to use this Software,
     39              contact Texas Instruments Incorporated at www.TI.com.
     40          **************************************************************************************************/
     41          
     42          /* ------------------------------------------------------------------------------------------------
     43           *                                          Includes
     44           * ------------------------------------------------------------------------------------------------
     45           */
     46          
     47          #include "mt.h"
     48          #include "mt_rpc.h"
     49          #include "zap_app.h"
     50          #include "zap_phy.h"
     51          #include "zap_znp.h"
     52          #include "ZDApp.h"
     53          #include "ZComDef.h"
     54          
     55          /* ------------------------------------------------------------------------------------------------
     56           *                                          Constants
     57           * ------------------------------------------------------------------------------------------------
     58           */
     59          
     60          /* ------------------------------------------------------------------------------------------------
     61           *                                           Typedefs
     62           * ------------------------------------------------------------------------------------------------
     63           */
     64          
     65          /* ------------------------------------------------------------------------------------------------
     66           *                                          Macros
     67           * ------------------------------------------------------------------------------------------------
     68           */
     69          
     70          /* ------------------------------------------------------------------------------------------------
     71           *                                           Global Variables
     72           * ------------------------------------------------------------------------------------------------
     73           */
     74          
     75          /* ------------------------------------------------------------------------------------------------
     76           *                                           Local Variables
     77           * ------------------------------------------------------------------------------------------------
     78           */
     79          
     80          /* ------------------------------------------------------------------------------------------------
     81           *                                           Local Functions
     82           * ------------------------------------------------------------------------------------------------
     83           */
     84          
     85          /**************************************************************************************************
     86           * @fn          znp_afRegisterExtended
     87           *
     88           * @brief       This function is the ZAP proxy to the ZNP afRegisterExtended() functionality.
     89           *
     90           * input parameters
     91           *
     92           * @param       epDesc - A pointer to the EndPoint descriptor to register. The 'simpleDesc' member
     93           *                       of the EndPoint descriptor must be a non-NULL pointer to a valid
     94           *                       SimpleDescriptionFormat_t. If the 'simpleDesc' member is NULL, this is a
     95           *                       dummy EndPoint descriptor and does not need to be registered with the AF
     96           *                       on the ZNP.
     97           *
     98           * output parameters
     99           *
    100           * None.
    101           *
    102           * @return      SUCCESS or FAILURE.
    103           **************************************************************************************************
    104           */

   \                                 In  segment CODE, align 2
    105          uint8 znp_afRegisterExtended(endPointDesc_t *epDesc)
   \                     znp_afRegisterExtended:
    106          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   084C         MOV.W   R12, R8
   \   000006   1F4C0400     MOV.W   0x4(R12), R15
   \   00000A   5B4F0700     MOV.B   0x7(R15), R11
   \   00000E   5B5F0A00     ADD.B   0xa(R15), R11
   \   000012   4B5B         RLA.B   R11
   \   000014   7B500900     ADD.B   #0x9, R11
    107            const uint8 len = ((epDesc->simpleDesc->AppNumInClusters) * 2) +
    108                              ((epDesc->simpleDesc->AppNumOutClusters) * 2) + 9;
    109            uint8 *pBuf = zap_msg_allocate(len, (uint8)MT_RPC_SYS_AF | (uint8)MT_RPC_CMD_SREQ,
    110                                                (uint8)MT_AF_REGISTER);
   \   000018   4E43         MOV.B   #0x0, R14
   \   00001A   7D402400     MOV.B   #0x24, R13
   \   00001E   4C4B         MOV.B   R11, R12
   \   000020   ........     CALLA   #zap_msg_allocate
   \   000024   814C0000     MOV.W   R12, 0(SP)
    111            uint8 rtrn = FAILURE;
   \   000028   5A43         MOV.B   #0x1, R10
    112          
    113            if (pBuf != NULL)
   \   00002A   0C93         CMP.W   #0x0, R12
   \   00002C   6124         JEQ     ??znp_afRegisterExtended_2
    114            {
    115              uint8 idx;
    116          
    117              *pBuf++ = (uint8)epDesc->endPoint;
   \   00002E   EC480000     MOV.B   @R8, 0(R12)
   \   000032   91530000     ADD.W   #0x1, 0(SP)
    118              *pBuf++ = (uint8)(epDesc->simpleDesc->AppProfId);
   \   000036   1F480400     MOV.W   0x4(R8), R15
   \   00003A   2E41         MOV.W   @SP, R14
   \   00003C   DE4F02000000 MOV.B   0x2(R15), 0(R14)
   \   000042   91530000     ADD.W   #0x1, 0(SP)
    119              *pBuf++ = (uint8)(epDesc->simpleDesc->AppProfId >> 8);
   \   000046   2E41         MOV.W   @SP, R14
   \   000048   DE4F03000000 MOV.B   0x3(R15), 0(R14)
   \   00004E   91530000     ADD.W   #0x1, 0(SP)
    120              *pBuf++ = (uint8)(epDesc->simpleDesc->AppDeviceId);
   \   000052   2E41         MOV.W   @SP, R14
   \   000054   DE4F04000000 MOV.B   0x4(R15), 0(R14)
   \   00005A   91530000     ADD.W   #0x1, 0(SP)
    121              *pBuf++ = (uint8)(epDesc->simpleDesc->AppDeviceId >> 8);
   \   00005E   2E41         MOV.W   @SP, R14
   \   000060   DE4F05000000 MOV.B   0x5(R15), 0(R14)
   \   000066   91530000     ADD.W   #0x1, 0(SP)
    122              *pBuf++ = epDesc->simpleDesc->AppDevVer;
   \   00006A   5E4F0600     MOV.B   0x6(R15), R14
   \   00006E   7EF00F00     AND.B   #0xf, R14
   \   000072   2F41         MOV.W   @SP, R15
   \   000074   CF4E0000     MOV.B   R14, 0(R15)
   \   000078   91530000     ADD.W   #0x1, 0(SP)
    123              *pBuf++ = epDesc->latencyReq;
   \   00007C   2F41         MOV.W   @SP, R15
   \   00007E   DF4806000000 MOV.B   0x6(R8), 0(R15)
   \   000084   91530000     ADD.W   #0x1, 0(SP)
    124              *pBuf++ = epDesc->simpleDesc->AppNumInClusters;
   \   000088   1F480400     MOV.W   0x4(R8), R15
   \   00008C   2E41         MOV.W   @SP, R14
   \   00008E   DE4F07000000 MOV.B   0x7(R15), 0(R14)
   \   000094   91530000     ADD.W   #0x1, 0(SP)
    125              for (idx = 0; idx < epDesc->simpleDesc->AppNumInClusters; idx++)
   \   000098   4E43         MOV.B   #0x0, R14
   \   00009A   0A3C         JMP     ??znp_afRegisterExtended_3
    126              {
    127                *pBuf++ = LO_UINT16(epDesc->simpleDesc->pAppInClusterList[idx]);
   \                     ??znp_afRegisterExtended_0:
   \   00009C   4D4E         MOV.B   R14, R13
   \   00009E   0D5D         RLA.W   R13
   \   0000A0   1A4F0800     MOV.W   0x8(R15), R10
   \   0000A4   ........     CALLA   #?Subroutine4
    128                *pBuf++ = HI_UINT16(epDesc->simpleDesc->pAppInClusterList[idx]);
   \                     ??CrossCallReturnLabel_4:
   \   0000A8   1A4F0800     MOV.W   0x8(R15), R10
   \   0000AC   ........     CALLA   #?Subroutine2
    129              }
   \                     ??znp_afRegisterExtended_3:
   \   0000B0   5E9F0700     CMP.B   0x7(R15), R14
   \   0000B4   F32B         JNC     ??znp_afRegisterExtended_0
    130              *pBuf++ = epDesc->simpleDesc->AppNumOutClusters;
   \   0000B6   2E41         MOV.W   @SP, R14
   \   0000B8   DE4F0A000000 MOV.B   0xa(R15), 0(R14)
   \   0000BE   91530000     ADD.W   #0x1, 0(SP)
    131              for (idx = 0; idx < epDesc->simpleDesc->AppNumOutClusters; idx++)
   \   0000C2   4E43         MOV.B   #0x0, R14
   \   0000C4   0A3C         JMP     ??znp_afRegisterExtended_4
    132              {
    133                *pBuf++ = LO_UINT16(epDesc->simpleDesc->pAppOutClusterList[idx]);
   \                     ??znp_afRegisterExtended_1:
   \   0000C6   4D4E         MOV.B   R14, R13
   \   0000C8   0D5D         RLA.W   R13
   \   0000CA   1A4F0C00     MOV.W   0xc(R15), R10
   \   0000CE   ........     CALLA   #?Subroutine4
    134                *pBuf++ = HI_UINT16(epDesc->simpleDesc->pAppOutClusterList[idx]);
   \                     ??CrossCallReturnLabel_5:
   \   0000D2   1A4F0C00     MOV.W   0xc(R15), R10
   \   0000D6   ........     CALLA   #?Subroutine2
    135              }
   \                     ??znp_afRegisterExtended_4:
   \   0000DA   5E9F0A00     CMP.B   0xa(R15), R14
   \   0000DE   F32B         JNC     ??znp_afRegisterExtended_1
    136          
    137              pBuf -= len;
   \   0000E0   818B0000     SUB.W   R11, 0(SP)
    138              zapPhySend(zapAppPort, pBuf);
   \   0000E4   ........     CALLA   #?Subroutine3
    139              rtrn = ZAP_SRSP_STATUS(pBuf);
   \                     ??CrossCallReturnLabel_3:
   \   0000E8   6A4F         MOV.B   @R15, R10
    140              zap_msg_deallocate(&pBuf);
   \   0000EA   0C41         MOV.W   SP, R12
   \   0000EC   ........     CALLA   #zap_msg_deallocate
    141            }
    142          
    143            return rtrn;
   \                     ??znp_afRegisterExtended_2:
   \   0000F0   4C4A         MOV.B   R10, R12
   \   0000F2   2153         ADD.W   #0x2, SP
   \   0000F4   3817         POPM.W  #0x4, R11
   \   0000F6   1001         RETA
    144          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine4:
   \   000000   0A5D         ADD.W   R13, R10
   \   000002   18410400     MOV.W   0x4(SP), R8
   \   000006   E84A0000     MOV.B   @R10, 0(R8)
   \   00000A   91530400     ADD.W   #0x1, 0x4(SP)
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   1D410400     MOV.W   0x4(SP), R13
   \   000004   5C42....     MOV.B   &zapAppPort, R12
   \   000008   ........     CALLA   #zapPhySend
   \   00000C   1F410400     MOV.W   0x4(SP), R15
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   0A5D         ADD.W   R13, R10
   \   000002   1D410400     MOV.W   0x4(SP), R13
   \   000006   DD4A01000000 MOV.B   0x1(R10), 0(R13)
   \   00000C   91530400     ADD.W   #0x1, 0x4(SP)
   \   000010   5E53         ADD.B   #0x1, R14
   \   000012   1001         RETA
    145          
    146          /**************************************************************************************************
    147           * @fn          znp_nv_read
    148           *
    149           * @brief       This function is the ZAP proxy to the ZNP uint8 osal_nv_read() functionality.
    150           *
    151           * input parameters
    152           *
    153           * @param       id  - Valid NV item Id.
    154           * @param       ndx - Index offset into item
    155           * @param       len - Length of data to read.
    156           * @param       *buf - Data to read.
    157           *
    158           * output parameters
    159           *
    160           * None.
    161           *
    162           * @return      ZSUCCESS if NV data was copied to the parameter 'buf'.
    163           *              Otherwise, NV_OPER_FAILED for failure.
    164           **************************************************************************************************
    165           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   ........     CALLA   #zapSysReq
   \   000004   6C41         MOV.B   @SP, R12
   \   000006   2152         ADD.W   #0x4, SP
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
    166          uint8 znp_nv_read(uint16 id, uint8 ndx, uint8 len, void *buf)
   \                     znp_nv_read:
    167          {
   \   000000   2182         SUB.W   #0x4, SP
    168            uint8 args[4];
    169          
    170            args[0] = LO_UINT16(id);
   \   000002   ........     CALLA   #?Subroutine1
    171            args[1] = HI_UINT16(id);
    172            args[2] = ndx;  // TODO - ZNP MT_SYS_OSAL_NV_READ is only supporting uint8 here.
    173            args[3] = len;  // TODO - ZNP MT_SYS_OSAL_NV_READ is not even supporting len.
    174          
    175            zapSysReq(MT_SYS_OSAL_NV_READ, (uint8 *)buf, args);
   \                     ??CrossCallReturnLabel_1:
   \   000006   0E41         MOV.W   SP, R14
   \   000008   0D4F         MOV.W   R15, R13
   \   00000A   7C42         MOV.B   #0x8, R12
   \   00000C   ....         JMP     ?Subroutine0
   \   00000E   0343         NOP
    176            return args[0];
    177          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine1:
   \   000000   C14C0400     MOV.B   R12, 0x4(SP)
   \   000004                RPT     #0x8
   \   000004   47190C10     RRUX.W  R12
   \   000008   C14C0500     MOV.B   R12, 0x5(SP)
   \   00000C   C14D0600     MOV.B   R13, 0x6(SP)
   \   000010   C14E0700     MOV.B   R14, 0x7(SP)
   \   000014   1001         RETA
    178          
    179          /**************************************************************************************************
    180           * @fn          znp_nv_write
    181           *
    182           * @brief       This function is the ZAP proxy to the ZNP uint8 osal_nv_write() functionality.
    183           *
    184           * input parameters
    185           *
    186           * @param       id  - Valid NV item Id.
    187           * @param       ndx - Index offset into item
    188           * @param       len - Length of data to write.
    189           * @param       *buf - Data to write.
    190           *
    191           * output parameters
    192           *
    193           * None.
    194           *
    195           * @return      SUCCESS if successful.
    196           *              NV_ITEM_UNINIT if item did not exist in NV.
    197           *              NV_OPER_FAILED if failure.
    198           **************************************************************************************************
    199           */

   \                                 In  segment CODE, align 2, keep-with-next
    200          uint8 znp_nv_write(uint16 id, uint8 ndx, uint8 len, void *buf)
   \                     znp_nv_write:
    201          {
   \   000000   2182         SUB.W   #0x4, SP
    202            uint8 args[4];
    203          
    204            args[0] = LO_UINT16(id);
   \   000002   ........     CALLA   #?Subroutine1
    205            args[1] = HI_UINT16(id);
    206            args[2] = ndx;  // TODO - ZNP MT_SYS_OSAL_NV_WRITE is only supporting uint8 here.
    207            args[3] = len;  // TODO - ZNP MT_SYS_OSAL_NV_WRITE is only supporting uint8 here.
    208          
    209            zapSysReq(MT_SYS_OSAL_NV_WRITE, (uint8 *)buf, args);
   \                     ??CrossCallReturnLabel_0:
   \   000006   0E41         MOV.W   SP, R14
   \   000008   0D4F         MOV.W   R15, R13
   \   00000A   7C400900     MOV.B   #0x9, R12
   \   00000E                REQUIRE ?Subroutine0
   \   00000E                // Fall through to label ?Subroutine0
    210            return args[0];
    211          }
    212          
    213          /*********************************************************************
    214           * @fn          znp_ZDO_RegisterForZDOMsg
    215           *
    216           * @brief       This function is the ZAP proxy to the ZNP ZDO_RegisterForZDOMsg() functionality.
    217           *
    218           * @param       clusterID - What message?
    219           *
    220           * @return      ZSuccess - successful, ZMemError if not
    221           */

   \                                 In  segment CODE, align 2
    222          ZStatus_t znp_ZDO_RegisterForZDOMsg(uint16 clusterID)
   \                     znp_ZDO_RegisterForZDOMsg:
    223          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   0A4C         MOV.W   R12, R10
    224            uint8 *pBuf, rtrn = ZMemError;
   \   000006   7B401000     MOV.B   #0x10, R11
    225          
    226            // Note that this could be sent AREQ to free up the host (but then no status.)
    227            if ((pBuf = zap_msg_allocate(2, (uint8)MT_RPC_SYS_ZDO | (uint8)MT_RPC_CMD_SREQ,
    228                                                    (uint8)MT_ZDO_MSG_CB_REGISTER)))
   \   00000A   7E403E00     MOV.B   #0x3e, R14
   \   00000E   7D402500     MOV.B   #0x25, R13
   \   000012   6C43         MOV.B   #0x2, R12
   \   000014   ........     CALLA   #zap_msg_allocate
   \   000018   814C0000     MOV.W   R12, 0(SP)
   \   00001C   0C93         CMP.W   #0x0, R12
   \   00001E   0D24         JEQ     ??znp_ZDO_RegisterForZDOMsg_0
    229            {
    230              pBuf[0] = LO_UINT16(clusterID);
   \   000020   CC4A0000     MOV.B   R10, 0(R12)
    231              pBuf[1] = HI_UINT16(clusterID);
   \   000024                RPT     #0x8
   \   000024   47190A10     RRUX.W  R10
   \   000028   2F41         MOV.W   @SP, R15
   \   00002A   CF4A0100     MOV.B   R10, 0x1(R15)
    232              zapPhySend(zapAppPort, pBuf);
   \   00002E   ........     CALLA   #?Subroutine3
    233              rtrn = ZAP_SRSP_STATUS(pBuf);
   \                     ??CrossCallReturnLabel_2:
   \   000032   6B4F         MOV.B   @R15, R11
    234              zap_msg_deallocate(&pBuf);
   \   000034   0C41         MOV.W   SP, R12
   \   000036   ........     CALLA   #zap_msg_deallocate
    235            }
    236          
    237            return (ZStatus_t)rtrn;
   \                     ??znp_ZDO_RegisterForZDOMsg_0:
   \   00003A   4C4B         MOV.B   R11, R12
   \   00003C   2153         ADD.W   #0x2, SP
   \   00003E   1A17         POPM.W  #0x2, R11
   \   000040   1001         RETA
    238          }
    239          
    240          /**************************************************************************************************
    241           * @fn          znpSystemReset
    242           *
    243           * @brief       This function is the ZAP proxy to the ZNP SystemReset() functionality.
    244           *
    245           * input parameters
    246           *
    247           * @param       type - Hard or soft reset type: ZNP_RESET_HARD  or ZNP_RESET_SOFT.
    248           *
    249           * output parameters
    250           *
    251           * None.
    252           *
    253           * @return      None.
    254           **************************************************************************************************
    255           */

   \                                 In  segment CODE, align 2
    256          void znpSystemReset(uint8 type)
   \                     znpSystemReset:
    257          {
   \   000000   4C12         PUSH.B  R12
    258            zapSysReq(MT_SYS_RESET_REQ, NULL, &type);
   \   000002   0E41         MOV.W   SP, R14
   \   000004   0D43         MOV.W   #0x0, R13
   \   000006   4C43         MOV.B   #0x0, R12
   \   000008   ........     CALLA   #zapSysReq
    259          }
   \   00000C   2153         ADD.W   #0x2, SP
   \   00000E   1001         RETA
    260          
    261          /**************************************************************************************************
    262          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       6  znpSystemReset
             6 -> zapSysReq
      10  znp_ZDO_RegisterForZDOMsg
            10 -> zapPhySend
            10 -> zap_msg_allocate
            10 -> zap_msg_deallocate
      14  znp_afRegisterExtended
            14 -> zapPhySend
            14 -> zap_msg_allocate
            14 -> zap_msg_deallocate
       8  znp_nv_read
             8 -> zapSysReq
       8  znp_nv_write
             8 -> zapSysReq


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?Subroutine0
      22  ?Subroutine1
      20  ?Subroutine2
      18  ?Subroutine3
      16  ?Subroutine4
      16  znpSystemReset
      66  znp_ZDO_RegisterForZDOMsg
     248  znp_afRegisterExtended
      16  znp_nv_read
      14  znp_nv_write

 
 446 bytes in segment CODE
 
 446 bytes of CODE memory

Errors: none
Warnings: none
