###############################################################################
#                                                                             #
#                                                       29/Jan/2012  16:16:20 #
# IAR C/C++ Compiler V5.40.2.20380/W32, Evaluation edition for MSP430         #
# Copyright 1996-2011 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430X                                                    #
#    __data_model  =  small                                                   #
#    Source file   =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Components\stack\ #
#                     zcl\zcl.c                                               #
#    Command line  =  -f "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\Source\zap.cfg"       #
#                     (-DZAP_PHY_SPI=1 -DZAP_PHY_UART=!ZAP_PHY_SPI            #
#                     -DZAP_PHY_RESET_ZNP=TRUE -DZAP_ZNP_MT=FALSE             #
#                     -DZAP_APP_MSG=FALSE -DZAP_SBL_PROXY=FALSE               #
#                     -DZAP_AUTO_CFG=TRUE -DZAP_AUTO_START=TRUE               #
#                     -DZAP_NV_RESTORE=FALSE -DLCD_SUPPORTED                  #
#                     -DZAP_AF_DATA_REQ_FRAG=FALSE                            #
#                     -DZAP_AF_DATA_REQ_AREQ=!ZAP_AF_DATA_REQ_FRAG            #
#                     -DZAP_ZDO_STARTUP_AREQ=TRUE -DZAP_AF_FUNC               #
#                     -DZAP_SAPI_FUNC -DZAP_SYS_FUNC -DZAP_UTIL_FUNC          #
#                     -DZAP_ZDO_FUNC -DSECURE=0 -DZG_SECURE_DYNAMIC=0         #
#                     "-DDEFAULT_CHANLIST=(uint32)0x00000800"                 #
#                     -DZDAPP_CONFIG_PAN_ID=0xFFFF -DPOLL_RATE=1000           #
#                     -DNWK_START_DELAY=100 -DMAX_BINDING_CLUSTER_IDS=4) -f   #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\..\..\..\Tools\MSP5438\f8wZCL. #
#                     cfg" (-DZCL_READ -DZCL_WRITE -DZCL_BASIC                #
#                     -DZCL_IDENTIFY -DZCL_ON_OFF -DZCL_KEY_ESTABLISH         #
#                     -DZCL_KEY_ESTABLISHMENT_KEY_GENERATE_TIMEOUT=4          #
#                     -DZCL_KEY_ESTABLISHMENT_MAC_GENERATE_TIMEOUT=10         #
#                     -DZCL_KEY_ESTABLISHMENT_EKEY_GENERATE_TIMEOUT=10        #
#                     -DZCL_LOAD_CONTROL -DZCL_SIMPLE_METERING -DZCL_PRICING  #
#                     -DZCL_MESSAGE) "C:\Texas Instruments\ZAP-MSP430-2.5.0\C #
#                     omponents\stack\zcl\zcl.c" -D                           #
#                     ZAP_DEVICETYPE=ZG_DEVICETYPE_COORDINATOR -D             #
#                     TC_LINKKEY_JOIN -D ZCL_REPORT -D INTER_PAN -lC          #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\List\" -lA   #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\List\"       #
#                     --remarks --diag_suppress Pe001,Pe193,Pe236,Pe826 -o    #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\ESP - Coordinator\Obj\"        #
#                     --debug -D__MSP430F5438A__ -e --double=32 --clib -I     #
#                     "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ #
#                     ZAP\SE-SampleApp\EXP5438\" -I "C:\Texas                 #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\Source\" -I "C:\Texas                 #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\Source\" -I "C:\Texas              #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\hal\target\MSP #
#                     5438ZAP\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pro #
#                     jects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Co #
#                     mponents\hal\include\" -I "C:\Texas                     #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\mac\include\"  #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\m #
#                     t\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\ #
#                     zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Componen #
#                     ts\osal\include\" -I "C:\Texas                          #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\osal\mcu\msp43 #
#                     0\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\ #
#                     zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Componen #
#                     ts\services\saddr\" -I "C:\Texas                        #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\services\sdata #
#                     \" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\z #
#                     stack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Component #
#                     s\stack\af\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\ #
#                     Projects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\.. #
#                     \Components\stack\nwk\" -I "C:\Texas                    #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\stack\sapi\"   #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\s #
#                     tack\sec\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pr #
#                     ojects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\C #
#                     omponents\stack\sys\" -I "C:\Texas                      #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\stack\zcl\"    #
#                     -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zsta #
#                     ck\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\Components\s #
#                     tack\zdo\" -I "C:\Texas Instruments\ZAP-MSP430-2.5.0\Pr #
#                     ojects\zstack\ZAP\SE-SampleApp\EXP5438\..\..\..\..\..\C #
#                     omponents\zmac\" -I "C:\Texas                           #
#                     Instruments\ZAP-MSP430-2.5.0\Projects\zstack\ZAP\SE-Sam #
#                     pleApp\EXP5438\..\..\..\..\..\Components\zmac\f8w\"     #
#                     --core=430X --data_model=small -Ohz --multiplier=32     #
#                     --multiplier_location=4C0 --require_prototypes          #
#                     --hw_workaround=CPU40                                   #
#    List file     =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\SE-SampleApp\EXP5438\ESP - Coordinator\List\zcl.lst  #
#    Object file   =  C:\Texas Instruments\ZAP-MSP430-2.5.0\Projects\zstack\Z #
#                     AP\SE-SampleApp\EXP5438\ESP - Coordinator\Obj\zcl.r43   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZAP-MSP430-2.5.0\Components\stack\zcl\zcl.c
      1          /**************************************************************************************************
      2            Filename:       zcl.c
      3            Revised:        $Date: 2011-04-21 09:26:27 -0700 (Thu, 21 Apr 2011) $
      4            Revision:       $Revision: 25774 $
      5          
      6            Description:    This file contains the Zigbee Cluster Library Foundation functions.
      7          
      8          
      9            Copyright 2006-2011 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "OSAL_Tasks.h"
     46          #include "AF.h"
     47          #include "ZDConfig.h"
     48          
     49          #include "zcl.h"
     50          #include "zcl_general.h"
     51          
     52          #if defined ( INTER_PAN )
     53            #include "stub_aps.h"
     54          #endif
     55          
     56          /*********************************************************************
     57           * MACROS
     58           */
     59          /*** Frame Control ***/
     60          #define zcl_FCType( a )               ( (a) & ZCL_FRAME_CONTROL_TYPE )
     61          #define zcl_FCManuSpecific( a )       ( (a) & ZCL_FRAME_CONTROL_MANU_SPECIFIC )
     62          #define zcl_FCDirection( a )          ( (a) & ZCL_FRAME_CONTROL_DIRECTION )
     63          #define zcl_FCDisableDefaultRsp( a )  ( (a) & ZCL_FRAME_CONTROL_DISABLE_DEFAULT_RSP )
     64          
     65          /*** Attribute Access Control ***/
     66          #define zcl_AccessCtrlRead( a )       ( (a) & ACCESS_CONTROL_READ )
     67          #define zcl_AccessCtrlWrite( a )      ( (a) & ACCESS_CONTROL_WRITE )
     68          #define zcl_AccessCtrlCmd( a )        ( (a) & ACCESS_CONTROL_CMD )
     69          #define zcl_AccessCtrlAuthRead( a )   ( (a) & ACCESS_CONTROL_AUTH_READ )
     70          #define zcl_AccessCtrlAuthWrite( a )  ( (a) & ACCESS_CONTROL_AUTH_WRITE )
     71          
     72          #define zclParseCmd( a, b )           zclCmdTable[(a)].pfnParseInProfile( (b) )
     73          #define zclProcessCmd( a, b )         zclCmdTable[(a)].pfnProcessInProfile( (b) )
     74          
     75          #define zcl_DefaultRspCmd( zclHdr )   ( zcl_ProfileCmd( (zclHdr).fc.type )     && \
     76                                                  (zclHdr).fc.manuSpecific == 0          && \
     77                                                  (zclHdr).commandID == ZCL_CMD_DEFAULT_RSP )
     78          
     79          // Commands that have corresponding responses
     80          #define CMD_HAS_RSP( cmd )            ( (cmd) == ZCL_CMD_READ            || \
     81                                                  (cmd) == ZCL_CMD_WRITE           || \
     82                                                  (cmd) == ZCL_CMD_WRITE_UNDIVIDED || \
     83                                                  (cmd) == ZCL_CMD_CONFIG_REPORT   || \
     84                                                  (cmd) == ZCL_CMD_READ_REPORT_CFG || \
     85                                                  (cmd) == ZCL_CMD_DISCOVER        || \
     86                                                  (cmd) == ZCL_CMD_DEFAULT_RSP ) // exception
     87          
     88          /*********************************************************************
     89           * CONSTANTS
     90           */
     91          
     92          /*********************************************************************
     93           * TYPEDEFS
     94           */
     95          typedef struct zclLibPlugin
     96          {
     97            struct zclLibPlugin *next;
     98            uint16              startClusterID;    // starting cluster ID
     99            uint16              endClusterID;      // ending cluster ID
    100            zclInHdlr_t         pfnIncomingHdlr;    // function to handle incoming message
    101          } zclLibPlugin_t;
    102          
    103          // Attribute record list item
    104          typedef struct zclAttrRecsList
    105          {
    106            struct zclAttrRecsList *next;
    107            uint8                  endpoint;      // Used to link it into the endpoint descriptor
    108            zclReadWriteCB_t       pfnReadWriteCB;// Read or Write attribute value callback function
    109            zclAuthorizeCB_t       pfnAuthorizeCB;// Authorize Read or Write operation
    110            uint8                  numAttributes; // Number of the following records
    111            CONST zclAttrRec_t     *attrs;        // attribute records
    112          } zclAttrRecsList;
    113          
    114          // Cluster option list item
    115          typedef struct zclClusterOptionList
    116          {
    117            struct zclClusterOptionList *next;
    118            uint8                       endpoint;   // Used to link it into the endpoint descriptor
    119            uint8                       numOptions; // Number of the following records
    120            zclOptionRec_t              *options;   // option records
    121          } zclClusterOptionList;
    122          
    123          typedef void *(*zclParseInProfileCmd_t)( zclParseCmd_t *pCmd );
    124          typedef uint8 (*zclProcessInProfileCmd_t)( zclIncoming_t *pInMsg );
    125          
    126          typedef struct
    127          {
    128            zclParseInProfileCmd_t   pfnParseInProfile;
    129            zclProcessInProfileCmd_t pfnProcessInProfile;
    130          } zclCmdItems_t;
    131          
    132          
    133          /*********************************************************************
    134           * GLOBAL VARIABLES
    135           */

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    136          uint8 zcl_TaskID;
   \                     zcl_TaskID:
   \   000000                DS8 1
    137          
    138          // The task Id of the Application where the unprocessed Foundation
    139          // Command/Response messages will be sent to.

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
    140          uint8 zcl_RegisteredMsgTaskID = TASK_NO_TASK;
   \                     zcl_RegisteredMsgTaskID:
   \   000000                DS8 1
   \   000001                REQUIRE `?<Initializer for zcl_RegisteredMsgTaskID>`
    141          
    142          // The Application should register its attribute data validation function

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    143          zclValidateAttrData_t zcl_ValidateAttrDataCB = NULL;
   \                     zcl_ValidateAttrDataCB:
   \   000000                DS8 4
    144          
    145          // ZCL Sequence number

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    146          uint8 zcl_SeqNum = 0x00;
   \                     zcl_SeqNum:
   \   000000                DS8 1
    147          
    148          /*********************************************************************
    149           * EXTERNAL VARIABLES
    150           */
    151          
    152          /*********************************************************************
    153           * EXTERNAL FUNCTIONS
    154           */
    155          
    156          /*********************************************************************
    157           * LOCAL VARIABLES
    158           */

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    159          static zclLibPlugin_t *plugins;
   \                     plugins:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    160          static zclAttrRecsList *attrList;
   \                     attrList:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    161          static zclClusterOptionList *clusterOptionList;
   \                     clusterOptionList:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    162          static uint8 zcl_TransID = 0;  // This is the unique message ID (counter)
   \                     zcl_TransID:
   \   000000                DS8 1
    163          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    164          static afIncomingMSGPacket_t *rawAFMsg = NULL;
   \                     rawAFMsg:
   \   000000                DS8 2
    165          
    166          /*********************************************************************
    167           * LOCAL FUNCTIONS
    168           */
    169          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt );  // Not static for ZNP build.
    170          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData );
    171          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr );
    172          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID );
    173          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint );
    174          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID );
    175          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID );
    176          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable );
    177          
    178          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID, uint8 frameType, uint8 cmd, uint16 profileID );
    179          
    180          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
    181          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint );
    182          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint );
    183          #endif // ZCL_READ || ZCL_WRITE
    184          
    185          #ifdef ZCL_READ
    186          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterID, uint16 attrId );
    187          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
    188                                                   uint8 *pAttrData, uint16 *pDataLen );
    189          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    190          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd );
    191          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg );
    192          #endif // ZCL_READ
    193          
    194          #ifdef ZCL_WRITE
    195          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr, 
    196                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec );
    197          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr, 
    198                                                    zclAttrRec_t *pAttr, uint8 *pAttrData );
    199          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr );
    200          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd );
    201          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg );
    202          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg );
    203          #endif // ZCL_WRITE
    204          
    205          #ifdef ZCL_REPORT
    206          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd );
    207          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd );
    208          #endif // ZCL_REPORT
    209          
    210          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd );
    211          
    212          #ifdef ZCL_DISCOVER
    213          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID, uint16 *attrId, zclAttrRec_t *pAttr );
    214          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd );
    215          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg );
    216          #endif // ZCL_DISCOVER
    217          
    218          static uint8 zclSendMsg( zclIncoming_t *pInMsg );
    219          
    220          /*********************************************************************
    221           * Parse Profile Command Function Table
    222           */

   \                                 In  segment DATA16_C, align 2, align-sorted
    223          static CONST zclCmdItems_t zclCmdTable[] =
   \                     zclCmdTable:
   \   000000   ............ DC32 zclParseInReadCmd, zclProcessInReadCmd, zclParseInReadRspCmd
   \            ............
   \   00000C   ............ DC32 zclSendMsg, zclParseInWriteCmd, zclProcessInWriteCmd
   \            ............
   \   000018   ............ DC32 zclParseInWriteCmd, zclProcessInWriteUndividedCmd
   \            ....        
   \   000020   ............ DC32 zclParseInWriteRspCmd, zclSendMsg, zclParseInWriteCmd
   \            ............
   \   00002C   ............ DC32 zclProcessInWriteCmd, zclParseInConfigReportCmd, zclSendMsg
   \            ............
   \   000038   ............ DC32 zclParseInConfigReportRspCmd, zclSendMsg
   \            ....        
   \   000040   ............ DC32 zclParseInReadReportCfgCmd, zclSendMsg
   \            ....        
   \   000048   ............ DC32 zclParseInReadReportCfgRspCmd, zclSendMsg, zclParseInReportCmd
   \            ............
   \   000054   ............ DC32 zclSendMsg, zclParseInDefaultRspCmd, zclSendMsg, 0H, 0H, 0H, 0H
   \            ............
   \            000000000000
   \            000000000000
   \            00000000    
    224          {
    225          #ifdef ZCL_READ
    226            /* ZCL_CMD_READ */                { zclParseInReadCmd,             zclProcessInReadCmd             },
    227            /* ZCL_CMD_READ_RSP */            { zclParseInReadRspCmd,          zclSendMsg                      },
    228          #else
    229            /* ZCL_CMD_READ */                { NULL,                          NULL                            },
    230            /* ZCL_CMD_READ_RSP */            { NULL,                          NULL                            },
    231          #endif // ZCL_READ
    232          
    233          #ifdef ZCL_WRITE
    234            /* ZCL_CMD_WRITE */               { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    235            /* ZCL_CMD_WRITE_UNDIVIDED */     { zclParseInWriteCmd,            zclProcessInWriteUndividedCmd   },
    236            /* ZCL_CMD_WRITE_RSP */           { zclParseInWriteRspCmd,         zclSendMsg                      },
    237            /* ZCL_CMD_WRITE_NO_RSP */        { zclParseInWriteCmd,            zclProcessInWriteCmd            },
    238          #else
    239            /* ZCL_CMD_WRITE */               { NULL,                          NULL                            },
    240            /* ZCL_CMD_WRITE_UNDIVIDED */     { NULL,                          NULL                            },
    241            /* ZCL_CMD_WRITE_RSP */           { NULL,                          NULL                            },
    242            /* ZCL_CMD_WRITE_NO_RSP */        { NULL,                          NULL                            },
    243          #endif // ZCL_WRITE
    244          
    245          #ifdef ZCL_REPORT
    246            /* ZCL_CMD_CONFIG_REPORT */       { zclParseInConfigReportCmd,     zclSendMsg                      },
    247            /* ZCL_CMD_CONFIG_REPORT_RSP */   { zclParseInConfigReportRspCmd,  zclSendMsg                      },
    248            /* ZCL_CMD_READ_REPORT_CFG */     { zclParseInReadReportCfgCmd,    zclSendMsg                      },
    249            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { zclParseInReadReportCfgRspCmd, zclSendMsg                      },
    250            /* ZCL_CMD_REPORT */              { zclParseInReportCmd,           zclSendMsg                      },
    251          #else
    252            /* ZCL_CMD_CONFIG_REPORT */       { NULL,                          NULL                            },
    253            /* ZCL_CMD_CONFIG_REPORT_RSP */   { NULL,                          NULL                            },
    254            /* ZCL_CMD_READ_REPORT_CFG */     { NULL,                          NULL                            },
    255            /* ZCL_CMD_READ_REPORT_CFG_RSP */ { NULL,                          NULL                            },
    256            /* ZCL_CMD_REPORT */              { NULL,                          NULL                            },
    257          #endif // ZCL_REPORT
    258          
    259            /* ZCL_CMD_DEFAULT_RSP */         { zclParseInDefaultRspCmd,       zclSendMsg                      },
    260          
    261          #ifdef ZCL_DISCOVER
    262            /* ZCL_CMD_DISCOVER */            { zclParseInDiscCmd,             zclProcessInDiscCmd             },
    263            /* ZCL_CMD_DISCOVER_RSP */        { zclParseInDiscRspCmd,          zclSendMsg                      }
    264          #else
    265            /* ZCL_CMD_DISCOVER */            { NULL,                          NULL                            },
    266            /* ZCL_CMD_DISCOVER_RSP */        { NULL,                          NULL                            }
    267          #endif // ZCL_DISCOVER
    268          };
    269          
    270          /*********************************************************************
    271           * PUBLIC FUNCTIONS
    272           *********************************************************************/
    273          
    274          /*********************************************************************
    275           * @fn          zcl_Init
    276           *
    277           * @brief       Initialization function for the zcl layer.
    278           *
    279           * @param       task_id - ZCL task id
    280           *
    281           * @return      none
    282           */

   \                                 In  segment CODE, align 2
    283          void zcl_Init( uint8 task_id )
   \                     zcl_Init:
    284          {
    285            zcl_TaskID = task_id;
   \   000000   C24C....     MOV.B   R12, &zcl_TaskID
    286          
    287            plugins = (zclLibPlugin_t  *)NULL;
   \   000004   8243....     MOV.W   #0x0, &plugins
    288            attrList = (zclAttrRecsList *)NULL;
   \   000008   8243....     MOV.W   #0x0, &attrList
    289            clusterOptionList = (zclClusterOptionList *)NULL;
   \   00000C   8243....     MOV.W   #0x0, &clusterOptionList
    290          }
   \   000010   1001         RETA
    291          
    292          /*********************************************************************
    293           * @fn          zcl_event_loop
    294           *
    295           * @brief       Event Loop Processor for zcl.
    296           *
    297           * @param       task_id - task id
    298           * @param       events - event bitmap
    299           *
    300           * @return      unprocessed events
    301           */

   \                                 In  segment CODE, align 2
    302          uint16 zcl_event_loop( uint8 task_id, uint16 events )
   \                     zcl_event_loop:
    303          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4D         MOV.W   R13, R10
    304            uint8 *msgPtr;
    305          
    306            (void)task_id;  // Intentionally unreferenced parameter
    307          
    308            if ( events & SYS_EVENT_MSG )
   \   000004   0D93         CMP.W   #0x0, R13
   \   000006   2034         JGE     ??zcl_event_loop_3
    309            {
    310              msgPtr = osal_msg_receive( zcl_TaskID );
   \   000008   0A3C         JMP     ??zcl_event_loop_2
    311              while ( msgPtr != NULL )
    312              {
    313                uint8 dealloc = TRUE;
    314          
    315                if ( *msgPtr == AF_INCOMING_MSG_CMD )
    316                {
    317                  rawAFMsg = (afIncomingMSGPacket_t *)msgPtr;
   \                     ??zcl_event_loop_0:
   \   00000A   824B....     MOV.W   R11, &rawAFMsg
    318                  zclProcessMessageMSG( rawAFMsg );
   \   00000E   0C4B         MOV.W   R11, R12
   \   000010   ........     CALLA   #zclProcessMessageMSG
    319                  rawAFMsg = NULL;
   \   000014   8243....     MOV.W   #0x0, &rawAFMsg
    320                }
    321                else if ( zcl_RegisteredMsgTaskID != TASK_NO_TASK )
    322                {
    323                  // send it to another task to process.
    324                  osal_msg_send( zcl_RegisteredMsgTaskID, msgPtr );
    325                  dealloc = FALSE;
    326                }
    327          
    328                // Release the memory
    329                if ( dealloc )
    330                {
    331                  osal_msg_deallocate( msgPtr );
   \                     ??zcl_event_loop_1:
   \   000018   0C4B         MOV.W   R11, R12
   \   00001A   ........     CALLA   #osal_msg_deallocate
    332                }
    333          
    334                // Next
    335                msgPtr = osal_msg_receive( zcl_TaskID );
   \                     ??zcl_event_loop_2:
   \   00001E   5C42....     MOV.B   &zcl_TaskID, R12
   \   000022   ........     CALLA   #osal_msg_receive
   \   000026   0B4C         MOV.W   R12, R11
   \   000028   0B93         CMP.W   #0x0, R11
   \   00002A   0A24         JEQ     ??zcl_event_loop_4
   \   00002C   FB901A000000 CMP.B   #0x1a, 0(R11)
   \   000032   EB27         JEQ     ??zcl_event_loop_0
   \   000034   F293....     CMP.B   #0xff, &zcl_RegisteredMsgTaskID
   \   000038   EF27         JEQ     ??zcl_event_loop_1
   \   00003A   ........     CALLA   #?Subroutine11
   \                     ??CrossCallReturnLabel_6:
   \   00003E   EF3F         JMP     ??zcl_event_loop_2
    336              }
    337          
    338              // return unprocessed events
    339              return (events ^ SYS_EVENT_MSG);
   \                     ??zcl_event_loop_4:
   \   000040   3AE00080     XOR.W   #0x8000, R10
   \   000044   0C4A         MOV.W   R10, R12
   \   000046   013C         JMP     ??zcl_event_loop_5
    340            }
    341          
    342            // Discard unknown events
    343            return 0;
   \                     ??zcl_event_loop_3:
   \   000048   0C43         MOV.W   #0x0, R12
   \                     ??zcl_event_loop_5:
   \   00004A   1A17         POPM.W  #0x2, R11
   \   00004C   1001         RETA
    344          }

   \                                 In  segment CODE, align 2
   \                     ?Subroutine11:
   \   000000   0D4B         MOV.W   R11, R13
   \   000002   5C42....     MOV.B   &zcl_RegisteredMsgTaskID, R12
   \   000006   ........     BRA     #osal_msg_send
    345          
    346          /*********************************************************************
    347           * @fn          zcl_getRawAFMsg
    348           *
    349           * @brief       Call to get original unprocessed AF message
    350           *              (not parsed by ZCL).
    351           *
    352           *   NOTE:  This function can only be called during a ZCL callback function
    353           *          and the calling function must NOT change any data in the message.
    354           *
    355           * @param       none
    356           *
    357           * @return      pointer to original AF message, NULL if not processing
    358           *              AF message.
    359           */

   \                                 In  segment CODE, align 2
    360          afIncomingMSGPacket_t *zcl_getRawAFMsg( void )
   \                     zcl_getRawAFMsg:
    361          {
    362            return ( rawAFMsg );
   \   000000   1C42....     MOV.W   &rawAFMsg, R12
   \   000004   1001         RETA
    363          }
    364          
    365          /*********************************************************************
    366           * @fn          zcl_registerPlugin
    367           *
    368           * @brief       Add a Cluster Library handler
    369           *
    370           * @param       startClusterID - starting cluster ID
    371           * @param       endClusterID - ending cluster ID
    372           * @param       pfnHdlr - function pointer to incoming message handler
    373           *
    374           * @return      ZSuccess if OK
    375           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine52:
   \   000000   ........     CALLA   #osal_mem_alloc
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    376          ZStatus_t zcl_registerPlugin( uint16 startClusterID,
   \                     zcl_registerPlugin:
    377                    uint16 endClusterID, zclInHdlr_t pfnIncomingHdlr )
    378          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   084C         MOV.W   R12, R8
   \   000004   094D         MOV.W   R13, R9
   \   000006   0A4E         MOV.W   R14, R10
   \   000008   0B4F         MOV.W   R15, R11
    379            zclLibPlugin_t *pNewItem;
    380            zclLibPlugin_t *pLoop;
    381          
    382            // Fill in the new profile list
    383            pNewItem = osal_mem_alloc( sizeof( zclLibPlugin_t ) );
   \   00000A   3C400A00     MOV.W   #0xa, R12
   \   00000E   ........     CALLA   #?Subroutine52
    384            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_97:
   \   000012   0320         JNE     ??zcl_registerPlugin_3
    385            {
    386              return (ZMemError);
   \   000014   7C401000     MOV.B   #0x10, R12
   \   000018   183C         JMP     ??zcl_registerPlugin_4
    387            }
    388          
    389            // Fill in the plugin record.
    390            pNewItem->next = (zclLibPlugin_t *)NULL;
   \                     ??zcl_registerPlugin_3:
   \   00001A   8C430000     MOV.W   #0x0, 0(R12)
    391            pNewItem->startClusterID = startClusterID;
   \   00001E   8C480200     MOV.W   R8, 0x2(R12)
    392            pNewItem->endClusterID = endClusterID;
   \   000022   8C490400     MOV.W   R9, 0x4(R12)
    393            pNewItem->pfnIncomingHdlr = pfnIncomingHdlr;
   \   000026   8C4A0600     MOV.W   R10, 0x6(R12)
   \   00002A   8C4B0800     MOV.W   R11, 0x8(R12)
    394          
    395            // Find spot in list
    396            if (  plugins == NULL )
   \   00002E   1F42....     MOV.W   &plugins, R15
   \   000032   0F93         CMP.W   #0x0, R15
   \   000034   0420         JNE     ??zcl_registerPlugin_2
    397            {
    398              plugins = pNewItem;
   \   000036   824C....     MOV.W   R12, &plugins
   \   00003A   063C         JMP     ??zcl_registerPlugin_5
    399            }
    400            else
    401            {
    402              // Look for end of list
    403              pLoop = plugins;
    404              while ( pLoop->next != NULL )
    405              {
    406                pLoop = pLoop->next;
   \                     ??zcl_registerPlugin_0:
   \   00003C   0F4B         MOV.W   R11, R15
    407              }
   \                     ??zcl_registerPlugin_2:
   \   00003E   2B4F         MOV.W   @R15, R11
   \   000040   0B93         CMP.W   #0x0, R11
   \   000042   FC23         JNE     ??zcl_registerPlugin_0
    408          
    409              // Put new item at end of list
    410              pLoop->next = pNewItem;
   \   000044   8F4C0000     MOV.W   R12, 0(R15)
    411            }
    412          
    413            return ( ZSuccess );
   \                     ??zcl_registerPlugin_5:
   \   000048   4C43         MOV.B   #0x0, R12
   \                     ??zcl_registerPlugin_4:
   \   00004A   3817         POPM.W  #0x4, R11
   \   00004C   1001         RETA
    414          }
    415          
    416          /*********************************************************************
    417           * @fn          zcl_registerAttrList
    418           *
    419           * @brief       Register an Attribute List with ZCL Foundation
    420           *
    421           * @param       endpoint - endpoint the attribute list belongs to
    422           * @param       numAttr - number of attributes in list
    423           * @param       newAttrList - array of Attribute records.
    424           *                            NOTE: THE ATTRIBUTE IDs (FOR A CLUSTER) MUST BE IN
    425           *                            ASCENDING ORDER. OTHERWISE, THE DISCOVERY RESPONSE
    426           *                            COMMAND WILL NOT HAVE THE RIGHT ATTRIBUTE INFO
    427           *
    428           * @return      ZSuccess if OK
    429           */

   \                                 In  segment CODE, align 2
    430          ZStatus_t zcl_registerAttrList( uint8 endpoint, uint8 numAttr, CONST zclAttrRec_t newAttrList[] )
   \                     zcl_registerAttrList:
    431          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   084E         MOV.W   R14, R8
    432            zclAttrRecsList *pNewItem;
    433            zclAttrRecsList *pLoop;
    434          
    435            // Fill in the new profile list
    436            pNewItem = osal_mem_alloc( sizeof( zclAttrRecsList ) );
   \   000008   3C401000     MOV.W   #0x10, R12
   \   00000C   ........     CALLA   #?Subroutine52
    437            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_96:
   \   000010   0320         JNE     ??zcl_registerAttrList_3
    438            {
    439              return (ZMemError);
   \   000012   7C401000     MOV.B   #0x10, R12
   \   000016   1A3C         JMP     ??zcl_registerAttrList_4
    440            }
    441          
    442            pNewItem->next = (zclAttrRecsList *)NULL;
   \                     ??zcl_registerAttrList_3:
   \   000018   8C430000     MOV.W   #0x0, 0(R12)
    443            pNewItem->endpoint = endpoint;
   \   00001C   CC4A0200     MOV.B   R10, 0x2(R12)
    444            pNewItem->pfnReadWriteCB = NULL;
   \   000020   8C430400     MOV.W   #0x0, 0x4(R12)
   \   000024   8C430600     MOV.W   #0x0, 0x6(R12)
    445            pNewItem->numAttributes = numAttr;
   \   000028   CC4B0C00     MOV.B   R11, 0xc(R12)
    446            pNewItem->attrs = newAttrList;
   \   00002C   8C480E00     MOV.W   R8, 0xe(R12)
    447          
    448            // Find spot in list
    449            if ( attrList == NULL )
   \   000030   1F42....     MOV.W   &attrList, R15
   \   000034   0F93         CMP.W   #0x0, R15
   \   000036   0420         JNE     ??zcl_registerAttrList_2
    450            {
    451              attrList = pNewItem;
   \   000038   824C....     MOV.W   R12, &attrList
   \   00003C   063C         JMP     ??zcl_registerAttrList_5
    452            }
    453            else
    454            {
    455              // Look for end of list
    456              pLoop = attrList;
    457              while ( pLoop->next != NULL )
    458              {
    459                pLoop = pLoop->next;
   \                     ??zcl_registerAttrList_0:
   \   00003E   0F4B         MOV.W   R11, R15
    460              }
   \                     ??zcl_registerAttrList_2:
   \   000040   2B4F         MOV.W   @R15, R11
   \   000042   0B93         CMP.W   #0x0, R11
   \   000044   FC23         JNE     ??zcl_registerAttrList_0
    461          
    462              // Put new item at end of list
    463              pLoop->next = pNewItem;
   \   000046   8F4C0000     MOV.W   R12, 0(R15)
    464            }
    465          
    466            return ( ZSuccess );
   \                     ??zcl_registerAttrList_5:
   \   00004A   4C43         MOV.B   #0x0, R12
   \                     ??zcl_registerAttrList_4:
   \   00004C   3817         POPM.W  #0x4, R11
   \   00004E   1001         RETA
    467          }
    468          
    469          /*********************************************************************
    470           * @fn          zcl_registerClusterOptionList
    471           *
    472           * @brief       Register a Cluster Option List with ZCL Foundation
    473           *
    474           * @param       endpoint - endpoint the option list belongs to
    475           * @param       numOption - number of options in list
    476           * @param       optionList - array of cluster option records.
    477           *
    478           *              NOTE: This API should be called to enable 'Application
    479           *                    Link Key' security and/or 'APS ACK' for a specific
    480           *                    Cluster. The 'Application Link Key' is discarded
    481           *                    if security isn't enabled on the device.
    482           *                    The default behavior is 'Network Key' when security
    483           *                    is enabled and no 'APS ACK' for the ZCL messages.
    484           *
    485           * @return      ZSuccess if OK
    486           */

   \                                 In  segment CODE, align 2
    487          ZStatus_t zcl_registerClusterOptionList( uint8 endpoint, uint8 numOption, zclOptionRec_t optionList[] )
   \                     zcl_registerClusterOptionList:
    488          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   4B4D         MOV.B   R13, R11
   \   000006   084E         MOV.W   R14, R8
    489            zclClusterOptionList *pNewItem;
    490            zclClusterOptionList *pLoop;
    491          
    492            // Fill in the new profile list
    493            pNewItem = osal_mem_alloc( sizeof( zclClusterOptionList ) );
   \   000008   3C400600     MOV.W   #0x6, R12
   \   00000C   ........     CALLA   #?Subroutine52
    494            if ( pNewItem == NULL )
   \                     ??CrossCallReturnLabel_95:
   \   000010   0320         JNE     ??zcl_registerClusterOptionList_3
    495            {
    496              return (ZMemError);
   \   000012   7C401000     MOV.B   #0x10, R12
   \   000016   163C         JMP     ??zcl_registerClusterOptionList_4
    497            }
    498          
    499            pNewItem->next = (zclClusterOptionList *)NULL;
   \                     ??zcl_registerClusterOptionList_3:
   \   000018   8C430000     MOV.W   #0x0, 0(R12)
    500            pNewItem->endpoint = endpoint;
   \   00001C   CC4A0200     MOV.B   R10, 0x2(R12)
    501            pNewItem->numOptions = numOption;
   \   000020   CC4B0300     MOV.B   R11, 0x3(R12)
    502            pNewItem->options = optionList;
   \   000024   8C480400     MOV.W   R8, 0x4(R12)
    503          
    504            // Find spot in list
    505            if ( clusterOptionList == NULL )
   \   000028   1F42....     MOV.W   &clusterOptionList, R15
   \   00002C   0F93         CMP.W   #0x0, R15
   \   00002E   0420         JNE     ??zcl_registerClusterOptionList_2
    506            {
    507              clusterOptionList = pNewItem;
   \   000030   824C....     MOV.W   R12, &clusterOptionList
   \   000034   063C         JMP     ??zcl_registerClusterOptionList_5
    508            }
    509            else
    510            {
    511              // Look for end of list
    512              pLoop = clusterOptionList;
    513              while ( pLoop->next != NULL )
    514              {
    515                pLoop = pLoop->next;
   \                     ??zcl_registerClusterOptionList_0:
   \   000036   0F4B         MOV.W   R11, R15
    516              }
   \                     ??zcl_registerClusterOptionList_2:
   \   000038   2B4F         MOV.W   @R15, R11
   \   00003A   0B93         CMP.W   #0x0, R11
   \   00003C   FC23         JNE     ??zcl_registerClusterOptionList_0
    517          
    518              // Put new item at end of list
    519              pLoop->next = pNewItem;
   \   00003E   8F4C0000     MOV.W   R12, 0(R15)
    520            }
    521          
    522            return ( ZSuccess );
   \                     ??zcl_registerClusterOptionList_5:
   \   000042   4C43         MOV.B   #0x0, R12
   \                     ??zcl_registerClusterOptionList_4:
   \   000044   3817         POPM.W  #0x4, R11
   \   000046   1001         RETA
    523          }
    524          
    525          /*********************************************************************
    526           * @fn          zcl_registerValidateAttrData
    527           *
    528           * @brief       Add a validation function for attribute data
    529           *
    530           * @param       pfnValidateAttrData - function pointer to validate routine
    531           *
    532           * @return      ZSuccess if OK
    533           */

   \                                 In  segment CODE, align 2
    534          ZStatus_t zcl_registerValidateAttrData( zclValidateAttrData_t pfnValidateAttrData )
   \                     zcl_registerValidateAttrData:
    535          {
    536            zcl_ValidateAttrDataCB = pfnValidateAttrData;
   \   000000   824C....     MOV.W   R12, &zcl_ValidateAttrDataCB
   \   000004   824D....     MOV.W   R13, &zcl_ValidateAttrDataCB + 2
    537          
    538            return ( ZSuccess );
   \   000008   4C43         MOV.B   #0x0, R12
   \   00000A   1001         RETA
    539          }
    540          
    541          /*********************************************************************
    542           * @fn          zcl_registerReadWriteCB
    543           *
    544           * @brief       Register the application's callback function to read/write
    545           *              attribute data, and authorize read/write operation.
    546           *
    547           *              Note: The pfnReadWriteCB callback function is only required 
    548           *                    when the attribute data format is unknown to ZCL. The
    549           *                    callback function gets called when the pointer 'dataPtr'
    550           *                    to the attribute value is NULL in the attribute database
    551           *                    registered with the ZCL.
    552           *
    553           *              Note: The pfnAuthorizeCB callback function is only required
    554           *                    when the Read/Write operation on an attribute requires 
    555           *                    authorization (i.e., attributes with ACCESS_CONTROL_AUTH_READ
    556           *                    or ACCESS_CONTROL_AUTH_WRITE access permissions).
    557           *
    558           * @param       endpoint - application's endpoint
    559           * @param       pfnReadWriteCB - function pointer to read/write routine
    560           * @param       pfnAuthorizeCB - function pointer to authorize read/write operation
    561           *
    562           * @return      ZSuccess if successful. ZFailure, otherwise.
    563           */

   \                                 In  segment CODE, align 2
    564          ZStatus_t zcl_registerReadWriteCB( uint8 endpoint, zclReadWriteCB_t pfnReadWriteCB,
   \                     zcl_registerReadWriteCB:
    565                                             zclAuthorizeCB_t pfnAuthorizeCB )
    566          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4F         MOV.W   R15, R11
    567            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000004   ........     CALLA   #zclFindAttrRecsList
    568          
    569            if ( pRec != NULL )
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   0C24         JEQ     ??zcl_registerReadWriteCB_0
    570            {
    571              pRec->pfnReadWriteCB = pfnReadWriteCB;
   \   00000C   8C4E0400     MOV.W   R14, 0x4(R12)
   \   000010   8C4B0600     MOV.W   R11, 0x6(R12)
    572              pRec->pfnAuthorizeCB = pfnAuthorizeCB;
   \   000014   9C4108000800 MOV.W   0x8(SP), 0x8(R12)
   \   00001A   9C410A000A00 MOV.W   0xa(SP), 0xa(R12)
    573          
    574              return ( ZSuccess );
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   013C         JMP     ??zcl_registerReadWriteCB_1
    575            }
    576          
    577            return ( ZFailure );
   \                     ??zcl_registerReadWriteCB_0:
   \   000024   5C43         MOV.B   #0x1, R12
   \                     ??zcl_registerReadWriteCB_1:
   \   000026   1A17         POPM.W  #0x2, R11
   \   000028   1001         RETA
    578          }
    579          
    580          /*********************************************************************
    581           * @fn      zcl_registerForMsg
    582           *
    583           * @brief   The ZCL is setup to send all incoming Foundation Command/Response
    584           *          messages that aren't processed to one task (if a task is
    585           *          registered).
    586           *
    587           * @param   taskId - task Id of the Application where commands will be sent to
    588           *
    589           * @return  TRUE if task registeration successful, FALSE otherwise
    590           *********************************************************************/

   \                                 In  segment CODE, align 2
    591          uint8 zcl_registerForMsg( uint8 taskId )
   \                     zcl_registerForMsg:
    592          {
    593            // Allow only the first task
    594            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000000   F293....     CMP.B   #0xff, &zcl_RegisteredMsgTaskID
   \   000004   0420         JNE     ??zcl_registerForMsg_0
    595            {
    596              zcl_RegisteredMsgTaskID = taskId;
   \   000006   C24C....     MOV.B   R12, &zcl_RegisteredMsgTaskID
    597          
    598              return ( true );
   \   00000A   5C43         MOV.B   #0x1, R12
   \   00000C   1001         RETA
    599            }
    600          
    601            return ( false );
   \                     ??zcl_registerForMsg_0:
   \   00000E   4C43         MOV.B   #0x0, R12
   \   000010   1001         RETA
    602          }
    603          
    604          /*********************************************************************
    605           * @fn      zcl_DeviceOperational
    606           *
    607           * @brief   Used to see whether or not the device can send or respond
    608           *          to application level commands.
    609           *
    610           * @param   srcEP - source endpoint
    611           * @param   clusterID - cluster ID
    612           * @param   frameType - command type
    613           * @param   cmd - command ID
    614           *
    615           * @return  TRUE if device is operational, FALSE otherwise
    616           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine23_0:
   \   000000   ........     CALLA   #zclFindAttrRec
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2
    617          static uint8 zcl_DeviceOperational( uint8 srcEP, uint16 clusterID,
   \                     zcl_DeviceOperational:
    618                                              uint8 frameType, uint8 cmd, uint16 profileID )
    619          {
   \   000000   31800A00     SUB.W   #0xa, SP
    620            zclAttrRec_t attrRec;
    621            uint8 deviceEnabled = DEVICE_ENABLED; // default value
   \   000004   D1430000     MOV.B   #0x1, 0(SP)
    622          
    623            (void)profileID;  // Intentionally unreferenced parameter
    624          
    625            // If the device is Disabled (DeviceEnabled attribute is set to Disabled), it
    626            // cannot send or respond to application level commands, other than commands
    627            // to read or write attributes. Note that the Identify cluster cannot be
    628            // disabled, and remains functional regardless of this setting.
    629            if ( zcl_ProfileCmd( frameType ) && cmd <= ZCL_CMD_WRITE_NO_RSP )
   \   000008   4E93         CMP.B   #0x0, R14
   \   00000A   0320         JNE     ??zcl_DeviceOperational_4
   \   00000C   7F900600     CMP.B   #0x6, R15
   \   000010   1628         JNC     ??zcl_DeviceOperational_1
    630            {
    631              return ( TRUE );
    632            }
    633          
    634            if ( clusterID == ZCL_CLUSTER_ID_GEN_IDENTIFY )
   \                     ??zcl_DeviceOperational_4:
   \   000012   3D900300     CMP.W   #0x3, R13
   \   000016   1324         JEQ     ??zcl_DeviceOperational_1
    635            {
    636              return ( TRUE );
    637            }
    638          
    639            // Is device enabled?
    640            if ( zclFindAttrRec( srcEP, ZCL_CLUSTER_ID_GEN_BASIC,
    641                                 ATTRID_BASIC_DEVICE_ENABLED, &attrRec ) )
   \   000018   0F41         MOV.W   SP, R15
   \   00001A   2F53         ADD.W   #0x2, R15
   \   00001C   3E401200     MOV.W   #0x12, R14
   \   000020   0D43         MOV.W   #0x0, R13
   \   000022   ........     CALLA   #??Subroutine23_0
   \                     ??CrossCallReturnLabel_87:
   \   000026   0624         JEQ     ??zcl_DeviceOperational_5
    642            {
    643              zclReadAttrData( &deviceEnabled, &attrRec, NULL );
   \   000028   0E43         MOV.W   #0x0, R14
   \   00002A   0D41         MOV.W   SP, R13
   \   00002C   2D53         ADD.W   #0x2, R13
   \   00002E   0C41         MOV.W   SP, R12
   \   000030   ........     CALLA   #zclReadAttrData
    644            }
    645          
    646            return ( deviceEnabled == DEVICE_ENABLED ? TRUE : FALSE );
   \                     ??zcl_DeviceOperational_5:
   \   000034   D1930000     CMP.B   #0x1, 0(SP)
   \   000038   0224         JEQ     ??zcl_DeviceOperational_1
   \   00003A   4C43         MOV.B   #0x0, R12
   \   00003C   013C         JMP     ??zcl_DeviceOperational_0
   \                     ??zcl_DeviceOperational_1:
   \   00003E   5C43         MOV.B   #0x1, R12
   \                     ??zcl_DeviceOperational_0:
   \   000040   31500A00     ADD.W   #0xa, SP
   \   000044   1001         RETA
    647          }
    648          
    649          /*********************************************************************
    650           * @fn      zcl_SendCommand
    651           *
    652           * @brief   Used to send Profile and Cluster Specific Command messages.
    653           *
    654           *          NOTE: The calling application is responsible for incrementing
    655           *                the Sequence Number.
    656           *
    657           * @param   srcEp - source endpoint
    658           * @param   destAddr - destination address
    659           * @param   clusterID - cluster ID
    660           * @param   cmd - command ID
    661           * @param   specific - whether the command is Cluster Specific
    662           * @param   direction - client/server direction of the command
    663           * @param   disableDefaultRsp - disable Default Response command
    664           * @param   manuCode - manufacturer code for proprietary extensions to a profile
    665           * @param   seqNumber - identification number for the transaction
    666           * @param   cmdFormatLen - length of the command to be sent
    667           * @param   cmdFormat - command to be sent
    668           *
    669           * @return  ZSuccess if OK
    670           */

   \                                 In  segment CODE, align 2
    671          ZStatus_t zcl_SendCommand( uint8 srcEP, afAddrType_t *destAddr,
   \                     zcl_SendCommand:
    672                                     uint16 clusterID, uint8 cmd, uint8 specific, uint8 direction,
    673                                     uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum,
    674                                     uint16 cmdFormatLen, uint8 *cmdFormat )
    675          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31800600     SUB.W   #0x6, SP
   \   000006   4A4C         MOV.B   R12, R10
   \   000008   0B4D         MOV.W   R13, R11
   \   00000A   084E         MOV.W   R14, R8
   \   00000C   454F         MOV.B   R15, R5
   \   00000E   14412000     MOV.W   0x20(SP), R4
   \   000012   17412400     MOV.W   0x24(SP), R7
    676            endPointDesc_t *epDesc;
    677            zclFrameHdr_t hdr;
    678            uint8 *msgBuf;
    679            uint16 msgLen;
    680            uint8 *pBuf;
    681            uint8 options;
    682            ZStatus_t status;
    683          
    684            epDesc = afFindEndPointDesc( srcEP );
   \   000016   ........     CALLA   #afFindEndPointDesc
   \   00001A   094C         MOV.W   R12, R9
    685            if ( epDesc == NULL )
   \   00001C   0C93         CMP.W   #0x0, R12
   \   00001E   0220         JNE     ??zcl_SendCommand_1
    686            {
    687              return ( ZInvalidParameter ); // EMBEDDED RETURN
   \   000020   6C43         MOV.B   #0x2, R12
   \   000022   7B3C         JMP     ??zcl_SendCommand_2
    688            }
    689          
    690          #if defined ( INTER_PAN )
    691            if ( StubAPS_InterPan( destAddr->panId, destAddr->endPoint ) )
   \                     ??zcl_SendCommand_1:
   \   000024   5D4B0900     MOV.B   0x9(R11), R13
   \   000028   1C4B0A00     MOV.W   0xa(R11), R12
   \   00002C   ........     CALLA   #StubAPS_InterPan
   \   000030   4C93         CMP.B   #0x0, R12
   \   000032   0224         JEQ     ??zcl_SendCommand_3
    692            {
    693              options = AF_TX_OPTIONS_NONE;
   \   000034   4643         MOV.B   #0x0, R6
   \   000036   053C         JMP     ??zcl_SendCommand_4
    694            }
    695            else
    696          #endif
    697            {
    698              options = zclGetClusterOption( srcEP, clusterID );
   \                     ??zcl_SendCommand_3:
   \   000038   0D48         MOV.W   R8, R13
   \   00003A   4C4A         MOV.B   R10, R12
   \   00003C   ........     CALLA   #zclGetClusterOption
   \   000040   464C         MOV.B   R12, R6
    699            }
    700          
    701            osal_memset( &hdr, 0, sizeof( zclFrameHdr_t ) );
   \                     ??zcl_SendCommand_4:
   \   000042   3E400600     MOV.W   #0x6, R14
   \   000046   4D43         MOV.B   #0x0, R13
   \   000048   0C41         MOV.W   SP, R12
   \   00004A   ........     CALLA   #osal_memset
    702          
    703            // Not Profile wide command (like READ, WRITE)
    704            if ( specific )
   \   00004E   2F41         MOV.W   @SP, R15
   \   000050   3FF0FCFF     AND.W   #0xfffc, R15
   \   000054   C1931A00     CMP.B   #0x0, 0x1a(SP)
   \   000058   0124         JEQ     ??zcl_SendCommand_0
    705            {
    706              hdr.fc.type = ZCL_FRAME_TYPE_SPECIFIC_CMD;
   \   00005A   1FD3         BIS.W   #0x1, R15
    707            }
    708            else
    709            {
    710              hdr.fc.type = ZCL_FRAME_TYPE_PROFILE_CMD;
   \                     ??zcl_SendCommand_0:
   \   00005C   814F0000     MOV.W   R15, 0(SP)
    711            }
    712          
    713            if ( ( epDesc->simpleDesc == NULL ) ||
    714                 ( zcl_DeviceOperational( srcEP, clusterID, hdr.fc.type, 
    715                                          cmd, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \   000060   1F490400     MOV.W   0x4(R9), R15
   \   000064   0F93         CMP.W   #0x0, R15
   \   000066   0E24         JEQ     ??zcl_SendCommand_5
   \   000068   1F120200     PUSH.W  0x2(R15)
   \   00006C   4F45         MOV.B   R5, R15
   \   00006E   5E410200     MOV.B   0x2(SP), R14
   \   000072   7EF00300     AND.B   #0x3, R14
   \   000076   0D48         MOV.W   R8, R13
   \   000078   4C4A         MOV.B   R10, R12
   \   00007A   ........     CALLA   #zcl_DeviceOperational
   \   00007E   2153         ADD.W   #0x2, SP
   \   000080   4C93         CMP.B   #0x0, R12
   \   000082   0220         JNE     ??zcl_SendCommand_6
    716            {
    717              return ( ZFailure ); // EMBEDDED RETURN
   \                     ??zcl_SendCommand_5:
   \   000084   5C43         MOV.B   #0x1, R12
   \   000086   493C         JMP     ??zcl_SendCommand_2
    718            }
    719          
    720            // Fill in the Maufacturer Code
    721            if ( manuCode != 0 )
   \                     ??zcl_SendCommand_6:
   \   000088   0493         CMP.W   #0x0, R4
   \   00008A   0424         JEQ     ??zcl_SendCommand_7
    722            {
    723              hdr.fc.manuSpecific = 1;
   \   00008C   A1D20000     BIS.W   #0x4, 0(SP)
    724              hdr.manuCode = manuCode;
   \   000090   81440200     MOV.W   R4, 0x2(SP)
    725            }
    726          
    727            // Set the Command Direction
    728            if ( direction )
   \                     ??zcl_SendCommand_7:
   \   000094   C1931C00     CMP.B   #0x0, 0x1c(SP)
   \   000098   0324         JEQ     ??zcl_SendCommand_8
    729            {
    730              hdr.fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00009A   B1D20000     BIS.W   #0x8, 0(SP)
   \   00009E   023C         JMP     ??zcl_SendCommand_9
    731            }
    732            else
    733            {
    734              hdr.fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zcl_SendCommand_8:
   \   0000A0   B1C20000     BIC.W   #0x8, 0(SP)
    735            }
    736          
    737            // Set the Disable Default Response field
    738            if ( disableDefaultRsp )
   \                     ??zcl_SendCommand_9:
   \   0000A4   C1931E00     CMP.B   #0x0, 0x1e(SP)
   \   0000A8   0424         JEQ     ??zcl_SendCommand_10
    739            {
    740              hdr.fc.disableDefaultRsp = 1;
   \   0000AA   B1D010000000 BIS.W   #0x10, 0(SP)
   \   0000B0   033C         JMP     ??zcl_SendCommand_11
    741            }
    742            else
    743            {
    744              hdr.fc.disableDefaultRsp = 0;
   \                     ??zcl_SendCommand_10:
   \   0000B2   B1C010000000 BIC.W   #0x10, 0(SP)
    745            }
    746          
    747            // Fill in the Transaction Sequence Number
    748            hdr.transSeqNum = seqNum;
   \                     ??zcl_SendCommand_11:
   \   0000B8   D14122000400 MOV.B   0x22(SP), 0x4(SP)
    749          
    750            // Fill in the command
    751            hdr.commandID = cmd;
   \   0000BE   C1450500     MOV.B   R5, 0x5(SP)
    752          
    753            // calculate the needed buffer size
    754            msgLen = zclCalcHdrSize( &hdr );
   \   0000C2   7A400300     MOV.B   #0x3, R10
   \   0000C6   A1B20000     BIT.W   #0x4, 0(SP)
   \   0000CA   0228         JNC     ??zcl_SendCommand_12
   \   0000CC   7A400500     MOV.B   #0x5, R10
    755            msgLen += cmdFormatLen;
   \                     ??zcl_SendCommand_12:
   \   0000D0   0A57         ADD.W   R7, R10
    756          
    757            // Allocate the buffer needed
    758            msgBuf = osal_mem_alloc( msgLen );
   \   0000D2   0C4A         MOV.W   R10, R12
   \   0000D4   ........     CALLA   #osal_mem_alloc
   \   0000D8   044C         MOV.W   R12, R4
    759            if ( msgBuf != NULL )
   \   0000DA   0C93         CMP.W   #0x0, R12
   \   0000DC   1B24         JEQ     ??zcl_SendCommand_13
    760            {
    761              // Fill in the ZCL Header
    762              pBuf = zclBuildHdr( &hdr, msgBuf );
   \   0000DE   0D4C         MOV.W   R12, R13
   \   0000E0   0C41         MOV.W   SP, R12
   \   0000E2   ........     CALLA   #zclBuildHdr
    763          
    764              // Fill in the command frame
    765              osal_memcpy( pBuf, cmdFormat, cmdFormatLen );
   \   0000E6   0E47         MOV.W   R7, R14
   \   0000E8   1D412600     MOV.W   0x26(SP), R13
   \   0000EC   ........     CALLA   #osal_memcpy
    766          
    767              status = AF_DataRequest( destAddr, epDesc, clusterID, msgLen, msgBuf,
    768                                       &zcl_TransID, options, AF_DEFAULT_RADIUS );
   \   0000F0   70121E00     PUSH.B  #0x1e
   \   0000F4   4612         PUSH.B  R6
   \   0000F6   3012....     PUSH.W  #zcl_TransID
   \   0000FA   0412         PUSH.W  R4
   \   0000FC   0F4A         MOV.W   R10, R15
   \   0000FE   0E48         MOV.W   R8, R14
   \   000100   0D49         MOV.W   R9, R13
   \   000102   0C4B         MOV.W   R11, R12
   \   000104   ........     CALLA   #AF_DataRequest
   \   000108   4A4C         MOV.B   R12, R10
    769              osal_mem_free ( msgBuf );
   \   00010A   0C44         MOV.W   R4, R12
   \   00010C   ........     CALLA   #osal_mem_free
   \   000110   3152         ADD.W   #0x8, SP
   \   000112   023C         JMP     ??zcl_SendCommand_14
    770            }
    771            else
    772            {
    773              status = ZMemError;
   \                     ??zcl_SendCommand_13:
   \   000114   7A401000     MOV.B   #0x10, R10
    774            }
    775          
    776            return ( status );
   \                     ??zcl_SendCommand_14:
   \   000118   4C4A         MOV.B   R10, R12
   \                     ??zcl_SendCommand_2:
   \   00011A   31500600     ADD.W   #0x6, SP
   \   00011E   7417         POPM.W  #0x8, R11
   \   000120   1001         RETA
    777          }
    778          
    779          #ifdef ZCL_READ
    780          /*********************************************************************
    781           * @fn      zcl_SendRead
    782           *
    783           * @brief   Send a Read command
    784           *
    785           * @param   srcEP - Application's endpoint
    786           * @param   dstAddr - destination address
    787           * @param   clusterID - cluster ID
    788           * @param   readCmd - read command to be sent
    789           * @param   direction - direction of the command
    790           * @param   seqNum - transaction sequence number
    791           *
    792           * @return  ZSuccess if OK
    793           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002   5617         POPM.W  #0x6, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine28_0:
   \   000000   ........     CALLA   #osal_mem_alloc
   \   000004   084C         MOV.W   R12, R8
   \   000006   0C93         CMP.W   #0x0, R12
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine27:
   \   000000   4A4C         MOV.B   R12, R10
   \   000002   0C48         MOV.W   R8, R12
   \   000004   ........     BRA     #osal_mem_free

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine57:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002   ........     BRA     #zcl_SendCommand

   \                                 In  segment CODE, align 2, keep-with-next
    794          ZStatus_t zcl_SendRead( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendRead:
    795                                  uint16 clusterID, zclReadCmd_t *readCmd,
    796                                  uint8 direction, uint8 disableDefaultRsp, uint8 seqNum)
    797          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   094D         MOV.W   R13, R9
   \   000006   064E         MOV.W   R14, R6
   \   000008   074F         MOV.W   R15, R7
    798            uint16 dataLen;
    799            uint8 *buf;
    800            uint8 *pBuf;
    801            ZStatus_t status;
    802          
    803            dataLen = readCmd->numAttr * 2; // Attribute ID
   \   00000A   6B4F         MOV.B   @R15, R11
   \   00000C   0B5B         RLA.W   R11
    804          
    805            buf = osal_mem_alloc( dataLen );
   \   00000E   0C4B         MOV.W   R11, R12
   \   000010   ........     CALLA   #??Subroutine28_0
    806            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_112:
   \   000014   2024         JEQ     ??zcl_SendRead_1
    807            {
    808              uint8 i;
    809          
    810              // Load the buffer - serially
    811              pBuf = buf;
   \   000016   0F4C         MOV.W   R12, R15
    812              for (i = 0; i < readCmd->numAttr; i++)
   \   000018   4E43         MOV.B   #0x0, R14
   \   00001A   073C         JMP     ??zcl_SendRead_2
    813              {
    814                *pBuf++ = LO_UINT16( readCmd->attrID[i] );
   \                     ??zcl_SendRead_0:
   \   00001C   4C4E         MOV.B   R14, R12
   \   00001E   0C5C         RLA.W   R12
   \   000020   0D47         MOV.W   R7, R13
   \   000022   0D5C         ADD.W   R12, R13
   \   000024   2D53         ADD.W   #0x2, R13
   \   000026   ........     CALLA   #?Subroutine55
    815                *pBuf++ = HI_UINT16( readCmd->attrID[i] );
    816              }
   \                     ??zcl_SendRead_2:
   \   00002A   6E97         CMP.B   @R7, R14
   \   00002C   F72B         JNC     ??zcl_SendRead_0
    817          
    818              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ, FALSE,
    819                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   00002E   0812         PUSH.W  R8
   \   000030   0B12         PUSH.W  R11
   \   000032   51121A00     PUSH.B  0x1a(SP)
   \   000036   0312         PUSH.W  #0x0
   \   000038   51121C00     PUSH.B  0x1c(SP)
   \   00003C   51121C00     PUSH.B  0x1c(SP)
   \   000040   4312         PUSH.B  #0x0
   \   000042   4F43         MOV.B   #0x0, R15
   \   000044   0E46         MOV.W   R6, R14
   \   000046   0D49         MOV.W   R9, R13
   \   000048   ........     CALLA   #?Subroutine57
    820              osal_mem_free( buf );
    821            }
   \                     ??CrossCallReturnLabel_68:
   \   00004C   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_26:
   \   000050   31500E00     ADD.W   #0xe, SP
   \   000054   023C         JMP     ??zcl_SendRead_3
    822            else
    823            {
    824              status = ZMemError;
   \                     ??zcl_SendRead_1:
   \   000056   7A401000     MOV.B   #0x10, R10
    825            }
    826          
    827            return ( status );
   \                     ??zcl_SendRead_3:
   \   00005A   ....         JMP     ?Subroutine1
   \   00005C   0343         NOP
    828          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine55:
   \   000000   EF4D0000     MOV.B   @R13, 0(R15)
   \   000004   1F53         ADD.W   #0x1, R15
   \   000006   DF4D01000000 MOV.B   0x1(R13), 0(R15)
   \   00000C   1F53         ADD.W   #0x1, R15
   \   00000E   5E53         ADD.B   #0x1, R14
   \   000010   1001         RETA
    829          
    830          /*********************************************************************
    831           * @fn      zcl_SendReadRsp
    832           *
    833           * @brief   Send a Read Response command.
    834           *
    835           * @param   srcEP - Application's endpoint
    836           * @param   dstAddr - destination address
    837           * @param   clusterID - cluster ID
    838           * @param   readRspCmd - read response command to be sent
    839           * @param   direction - direction of the command
    840           * @param   seqNum - transaction sequence number
    841           *
    842           * @return  ZSuccess if OK
    843           */

   \                                 In  segment CODE, align 2, keep-with-next
    844          ZStatus_t zcl_SendReadRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadRsp:
    845                                     uint16 clusterID, zclReadRspCmd_t *readRspCmd,
    846                                     uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    847          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   4A4C         MOV.B   R12, R10
   \   000006   054D         MOV.W   R13, R5
   \   000008   0B4E         MOV.W   R14, R11
   \   00000A   094F         MOV.W   R15, R9
    848            uint8 *buf;
    849            uint16 len = 0;
   \   00000C   0643         MOV.W   #0x0, R6
    850            ZStatus_t status;
    851          
    852            // calculate the size of the command
    853            for ( uint8 i = 0; i < readRspCmd->numAttr; i++ )
   \   00000E   4843         MOV.B   #0x0, R8
   \   000010   073C         JMP     ??zcl_SendReadRsp_4
    854            {
    855              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
    856          
    857              len += 2 + 1; // Attribute ID + Status
    858          
    859              if ( statusRec->status == ZCL_STATUS_SUCCESS )
    860              {
    861                len++; // Attribute Data Type length
    862          
    863                // Attribute Data length
    864                if ( statusRec->data != NULL )
    865                {
    866                  len += zclGetAttrDataLength( statusRec->dataType, statusRec->data );
    867                }
    868                else
    869                {
    870                  len += zclGetAttrDataLengthUsingCB( srcEP, clusterID, statusRec->attrID );
   \                     ??zcl_SendReadRsp_1:
   \   000012   2E4F         MOV.W   @R15, R14
   \   000014   0D4B         MOV.W   R11, R13
   \   000016   4C4A         MOV.B   R10, R12
   \   000018   ........     CALLA   #zclGetAttrDataLengthUsingCB
   \                     ??zcl_SendReadRsp_6:
   \   00001C   065C         ADD.W   R12, R6
    871                }
   \                     ??zcl_SendReadRsp_0:
   \   00001E   5853         ADD.B   #0x1, R8
   \                     ??zcl_SendReadRsp_4:
   \   000020   6899         CMP.B   @R9, R8
   \   000022   152C         JC      ??zcl_SendReadRsp_5
   \   000024   0748         MOV.W   R8, R7
   \   000026                RPT     #0x5
   \   000026   44180758     ADDX.W  R8, R7
   \   00002A   0F49         MOV.W   R9, R15
   \   00002C   0F57         ADD.W   R7, R15
   \   00002E   2F53         ADD.W   #0x2, R15
   \   000030   36500300     ADD.W   #0x3, R6
   \   000034   CF930200     CMP.B   #0x0, 0x2(R15)
   \   000038   F223         JNE     ??zcl_SendReadRsp_0
   \   00003A   1653         ADD.W   #0x1, R6
   \   00003C   1D4F0400     MOV.W   0x4(R15), R13
   \   000040   0D93         CMP.W   #0x0, R13
   \   000042   E727         JEQ     ??zcl_SendReadRsp_1
   \   000044   5C4F0300     MOV.B   0x3(R15), R12
   \   000048   ........     CALLA   #zclGetAttrDataLength
   \   00004C   E73F         JMP     ??zcl_SendReadRsp_6
    872              }
    873            }
    874          
    875            buf = osal_mem_alloc( len );
   \                     ??zcl_SendReadRsp_5:
   \   00004E   0C46         MOV.W   R6, R12
   \   000050   ........     CALLA   #??Subroutine28_0
    876            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_108:
   \   000054   4824         JEQ     ??zcl_SendReadRsp_7
    877            {
    878              // Load the buffer - serially
    879              uint8 *pBuf = buf;
   \   000056   074C         MOV.W   R12, R7
    880              for ( uint8 i = 0; i < readRspCmd->numAttr; i++ )
   \   000058   4443         MOV.B   #0x0, R4
   \   00005A   0C3C         JMP     ??zcl_SendReadRsp_8
    881              {
    882                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
    883          
    884                *pBuf++ = LO_UINT16( statusRec->attrID );
    885                *pBuf++ = HI_UINT16( statusRec->attrID );
    886                *pBuf++ = statusRec->status;
    887          
    888                if ( statusRec->status == ZCL_STATUS_SUCCESS )
    889                {
    890                  *pBuf++ = statusRec->dataType;
    891          
    892                  if ( statusRec->data != NULL )
    893                  {
    894                    // Copy attribute data to the buffer to be sent out
    895                    pBuf = zclSerializeData( statusRec->dataType, statusRec->data, pBuf );
    896                  }
    897                  else
    898                  {
    899                    uint16 dataLen;
    900          
    901                    // Read attribute data directly into the buffer to be sent out
    902                    zclReadAttrDataUsingCB( srcEP, clusterID, statusRec->attrID, pBuf, &dataLen );
   \                     ??zcl_SendReadRsp_3:
   \   00005C   0F41         MOV.W   SP, R15
   \   00005E   0F12         PUSH.W  R15
   \   000060   0F47         MOV.W   R7, R15
   \   000062   2E4C         MOV.W   @R12, R14
   \   000064   0D4B         MOV.W   R11, R13
   \   000066   4C4A         MOV.B   R10, R12
   \   000068   ........     CALLA   #zclReadAttrDataUsingCB
    903                    pBuf += dataLen;
   \   00006C   17510200     ADD.W   0x2(SP), R7
   \   000070   2153         ADD.W   #0x2, SP
    904                  }
   \                     ??zcl_SendReadRsp_2:
   \   000072   5453         ADD.B   #0x1, R4
   \                     ??zcl_SendReadRsp_8:
   \   000074   6499         CMP.B   @R9, R4
   \   000076   232C         JC      ??zcl_SendReadRsp_9
   \   000078   0F44         MOV.W   R4, R15
   \   00007A                RPT     #0x5
   \   00007A   44180F54     ADDX.W  R4, R15
   \   00007E   0C49         MOV.W   R9, R12
   \   000080   0C5F         ADD.W   R15, R12
   \   000082   2C53         ADD.W   #0x2, R12
   \   000084   E74C0000     MOV.B   @R12, 0(R7)
   \   000088   1753         ADD.W   #0x1, R7
   \   00008A   D74C01000000 MOV.B   0x1(R12), 0(R7)
   \   000090   1753         ADD.W   #0x1, R7
   \   000092   D74C02000000 MOV.B   0x2(R12), 0(R7)
   \   000098   1753         ADD.W   #0x1, R7
   \   00009A   CC930200     CMP.B   #0x0, 0x2(R12)
   \   00009E   E923         JNE     ??zcl_SendReadRsp_2
   \   0000A0   D74C03000000 MOV.B   0x3(R12), 0(R7)
   \   0000A6   1753         ADD.W   #0x1, R7
   \   0000A8   1D4C0400     MOV.W   0x4(R12), R13
   \   0000AC   0D93         CMP.W   #0x0, R13
   \   0000AE   D627         JEQ     ??zcl_SendReadRsp_3
   \   0000B0   0E47         MOV.W   R7, R14
   \   0000B2   5C4C0300     MOV.B   0x3(R12), R12
   \   0000B6   ........     CALLA   #zclSerializeData
   \   0000BA   074C         MOV.W   R12, R7
   \   0000BC   DA3F         JMP     ??zcl_SendReadRsp_2
    905                }
    906              } // for loop
    907          
    908              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_RSP, FALSE,
    909                                        direction, disableDefaultRsp, 0, seqNum, len, buf );
   \                     ??zcl_SendReadRsp_9:
   \   0000BE   0812         PUSH.W  R8
   \   0000C0   0612         PUSH.W  R6
   \   0000C2   51122000     PUSH.B  0x20(SP)
   \   0000C6   0312         PUSH.W  #0x0
   \   0000C8   51122200     PUSH.B  0x22(SP)
   \   0000CC   51122200     PUSH.B  0x22(SP)
   \   0000D0   4312         PUSH.B  #0x0
   \   0000D2   5F43         MOV.B   #0x1, R15
   \   0000D4   0E4B         MOV.W   R11, R14
   \   0000D6   0D45         MOV.W   R5, R13
   \   0000D8   ........     CALLA   #?Subroutine57
    910              osal_mem_free( buf );
    911            }
   \                     ??CrossCallReturnLabel_70:
   \   0000DC   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_28:
   \   0000E0   31500E00     ADD.W   #0xe, SP
   \   0000E4   023C         JMP     ??zcl_SendReadRsp_10
    912            else
    913            {
    914              status = ZMemError;
   \                     ??zcl_SendReadRsp_7:
   \   0000E6   7A401000     MOV.B   #0x10, R10
    915            }
    916          
    917            return ( status );
   \                     ??zcl_SendReadRsp_10:
   \   0000EA   4C4A         MOV.B   R10, R12
   \   0000EC   2153         ADD.W   #0x2, SP
   \   0000EE   7417         POPM.W  #0x8, R11
   \   0000F0   1001         RETA
    918          }
    919          #endif // ZCL_READ
    920          
    921          #ifdef ZCL_WRITE
    922          /*********************************************************************
    923           * @fn      sendWriteRequest
    924           *
    925           * @brief   Send a Write command
    926           *
    927           * @param   dstAddr - destination address
    928           * @param   clusterID - cluster ID
    929           * @param   writeCmd - write command to be sent
    930           * @param   cmd - ZCL_CMD_WRITE, ZCL_CMD_WRITE_UNDIVIDED or ZCL_CMD_WRITE_NO_RSP
    931           * @param   direction - direction of the command
    932           * @param   seqNum - transaction sequence number
    933           *
    934           * @return  ZSuccess if OK
    935           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002   7417         POPM.W  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine54:
   \   000000   0F46         MOV.W   R6, R15
   \   000002   0F5D         ADD.W   R13, R15
   \   000004   2F53         ADD.W   #0x2, R15
   \   000006   EE4F0000     MOV.B   @R15, 0(R14)
   \   00000A   1E53         ADD.W   #0x1, R14
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine29:
   \   000000   0C47         MOV.W   R7, R12
   \   000002   ........     CALLA   #osal_mem_alloc
   \   000006   0B4C         MOV.W   R12, R11
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine26:
   \   000000   0E49         MOV.W   R9, R14
   \   000002   0D48         MOV.W   R8, R13
   \   000004                REQUIRE ?Subroutine57
   \   000004                // Fall through to label ?Subroutine57

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine25:
   \   000000   4A4C         MOV.B   R12, R10
   \   000002   0C4B         MOV.W   R11, R12
   \   000004   ........     BRA     #osal_mem_free

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine24:
   \   000000   4A4C         MOV.B   R12, R10
   \   000002   084D         MOV.W   R13, R8
   \   000004   094E         MOV.W   R14, R9
   \   000006   064F         MOV.W   R15, R6
   \   000008   0743         MOV.W   #0x0, R7
   \   00000A   4E43         MOV.B   #0x0, R14
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
    936          ZStatus_t zcl_SendWriteRequest( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendWriteRequest:
    937                                          zclWriteCmd_t *writeCmd, uint8 cmd, uint8 direction,
    938                                          uint8 disableDefaultRsp, uint8 seqNum )
    939          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   ........     CALLA   #?Subroutine24
    940            uint8 *buf;
    941            uint16 dataLen = 0;
    942            ZStatus_t status;
    943          
    944            for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_21:
   \   000006   023C         JMP     ??zcl_SendWriteRequest_2
    945            {
    946              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_0:
   \   000008   ........     CALLA   #?Subroutine9
    947          
    948              dataLen += 2 + 1; // Attribute ID + Attribute Type
    949          
    950              // Attribute Data
    951              dataLen += zclGetAttrDataLength( statusRec->dataType, statusRec->attrData );
    952            }
   \                     ??zcl_SendWriteRequest_2:
   \   00000C   6E96         CMP.B   @R6, R14
   \   00000E   FC2B         JNC     ??zcl_SendWriteRequest_0
    953          
    954            buf = osal_mem_alloc( dataLen );
   \   000010   ........     CALLA   #?Subroutine29
    955            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_32:
   \   000014   1A24         JEQ     ??zcl_SendWriteRequest_3
    956            {
    957              // Load the buffer - serially
    958              uint8 *pBuf = buf;
   \   000016   0E4C         MOV.W   R12, R14
    959              for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   000018   4443         MOV.B   #0x0, R4
   \   00001A   023C         JMP     ??zcl_SendWriteRequest_4
    960              {
    961                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   \                     ??zcl_SendWriteRequest_1:
   \   00001C   ........     CALLA   #?Subroutine8
    962          
    963                *pBuf++ = LO_UINT16( statusRec->attrID );
    964                *pBuf++ = HI_UINT16( statusRec->attrID );
    965                *pBuf++ = statusRec->dataType;
    966          
    967                pBuf = zclSerializeData( statusRec->dataType, statusRec->attrData, pBuf );
    968              }
   \                     ??zcl_SendWriteRequest_4:
   \   000020   6496         CMP.B   @R6, R4
   \   000022   FC2B         JNC     ??zcl_SendWriteRequest_1
    969          
    970              status = zcl_SendCommand( srcEP, dstAddr, clusterID, cmd, FALSE,
    971                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000024   0B12         PUSH.W  R11
   \   000026   0712         PUSH.W  R7
   \   000028   51122000     PUSH.B  0x20(SP)
   \   00002C   0312         PUSH.W  #0x0
   \   00002E   51122200     PUSH.B  0x22(SP)
   \   000032   51122200     PUSH.B  0x22(SP)
   \   000036   4312         PUSH.B  #0x0
   \   000038   5F412200     MOV.B   0x22(SP), R15
   \   00003C   ........     CALLA   #?Subroutine26
    972              osal_mem_free( buf );
    973            }
   \                     ??CrossCallReturnLabel_73:
   \   000040   ........     CALLA   #?Subroutine25
   \                     ??CrossCallReturnLabel_22:
   \   000044   31500E00     ADD.W   #0xe, SP
   \   000048   023C         JMP     ??zcl_SendWriteRequest_5
    974            else
    975            {
    976              status = ZMemError;
   \                     ??zcl_SendWriteRequest_3:
   \   00004A   7A401000     MOV.B   #0x10, R10
    977            }
    978          
    979            return ( status);
   \                     ??zcl_SendWriteRequest_5:
   \   00004E   ....         JMP     ?Subroutine5
   \   000050   0343         NOP
    980          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine9:
   \   000000   0B4E         MOV.W   R14, R11
   \   000002                RPT     #0x5
   \   000002   44180B5E     ADDX.W  R14, R11
   \   000006   0F46         MOV.W   R6, R15
   \   000008   0F5B         ADD.W   R11, R15
   \   00000A   2F53         ADD.W   #0x2, R15
   \   00000C   1D4F0400     MOV.W   0x4(R15), R13
   \   000010   5C4F0200     MOV.B   0x2(R15), R12
   \   000014   ........     CALLA   #zclGetAttrDataLength
   \   000018   3C500300     ADD.W   #0x3, R12
   \   00001C   075C         ADD.W   R12, R7
   \   00001E   5E53         ADD.B   #0x1, R14
   \   000020   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine8:
   \   000000   0D44         MOV.W   R4, R13
   \   000002                RPT     #0x5
   \   000002   44180D54     ADDX.W  R4, R13
   \   000006   ........     CALLA   #?Subroutine54
   \                     ??CrossCallReturnLabel_61:
   \   00000A   DE4F01000000 MOV.B   0x1(R15), 0(R14)
   \   000010   1E53         ADD.W   #0x1, R14
   \   000012   DE4F02000000 MOV.B   0x2(R15), 0(R14)
   \   000018   1E53         ADD.W   #0x1, R14
   \   00001A   1D4F0400     MOV.W   0x4(R15), R13
   \   00001E   5C4F0200     MOV.B   0x2(R15), R12
   \   000022   ........     CALLA   #zclSerializeData
   \   000026   0E4C         MOV.W   R12, R14
   \   000028   5453         ADD.B   #0x1, R4
   \   00002A   1001         RETA
    981          
    982          /*********************************************************************
    983           * @fn      zcl_SendWriteRsp
    984           *
    985           * @brief   Send a Write Response command
    986           *
    987           * @param   dstAddr - destination address
    988           * @param   clusterID - cluster ID
    989           * @param   wrtieRspCmd - write response command to be sent
    990           * @param   direction - direction of the command
    991           * @param   seqNum - transaction sequence number
    992           *
    993           * @return  ZSuccess if OK
    994           */

   \                                 In  segment CODE, align 2, keep-with-next
    995          ZStatus_t zcl_SendWriteRsp( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendWriteRsp:
    996                                      uint16 clusterID, zclWriteRspCmd_t *writeRspCmd,
    997                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
    998          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   ........     CALLA   #?Subroutine19
    999            uint16 dataLen;
   1000            uint8 *buf;
   1001            ZStatus_t status;
   1002          
   1003            dataLen = writeRspCmd->numAttr * ( 1 + 2 ); // status + attribute id
   1004          
   1005            buf = osal_mem_alloc( dataLen );
   1006            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_12:
   \   000006   2024         JEQ     ??zcl_SendWriteRsp_1
   1007            {
   1008              // Load the buffer - serially
   1009              uint8 *pBuf = buf;
   \   000008   0F4C         MOV.W   R12, R15
   1010              for ( uint8 i = 0; i < writeRspCmd->numAttr; i++ )
   \   00000A   4E43         MOV.B   #0x0, R14
   \   00000C   023C         JMP     ??zcl_SendWriteRsp_2
   1011              {
   1012                *pBuf++ = writeRspCmd->attrList[i].status;
   \                     ??zcl_SendWriteRsp_0:
   \   00000E   ........     CALLA   #?Subroutine33
   1013                *pBuf++ = LO_UINT16( writeRspCmd->attrList[i].attrID );
   1014                *pBuf++ = HI_UINT16( writeRspCmd->attrList[i].attrID );
   1015              }
   \                     ??zcl_SendWriteRsp_2:
   \   000012   6D46         MOV.B   @R6, R13
   \   000014   4E9D         CMP.B   R13, R14
   \   000016   FB2B         JNC     ??zcl_SendWriteRsp_0
   1016          
   1017              // If there's only a single status record and its status field is set to
   1018              // SUCCESS then omit the attribute ID field.
   1019              if ( writeRspCmd->numAttr == 1 && writeRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000018   5D93         CMP.B   #0x1, R13
   \   00001A   0420         JNE     ??zcl_SendWriteRsp_3
   \   00001C   C6930200     CMP.B   #0x0, 0x2(R6)
   \   000020   0120         JNE     ??zcl_SendWriteRsp_3
   1020              {
   1021                dataLen = 1;
   \   000022   1743         MOV.W   #0x1, R7
   1022              }
   1023          
   1024              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_WRITE_RSP, FALSE,
   1025                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendWriteRsp_3:
   \   000024   0912         PUSH.W  R9
   \   000026   0712         PUSH.W  R7
   \   000028   51121A00     PUSH.B  0x1a(SP)
   \   00002C   0312         PUSH.W  #0x0
   \   00002E   51121C00     PUSH.B  0x1c(SP)
   \   000032   51121C00     PUSH.B  0x1c(SP)
   \   000036   4312         PUSH.B  #0x0
   \   000038   6F42         MOV.B   #0x4, R15
   \   00003A   ........     CALLA   #?Subroutine32
   1026              osal_mem_free( buf );
   1027            }
   \                     ??CrossCallReturnLabel_72:
   \   00003E   ........     CALLA   #?Subroutine34
   \                     ??CrossCallReturnLabel_79:
   \   000042   31500E00     ADD.W   #0xe, SP
   \   000046   023C         JMP     ??zcl_SendWriteRsp_4
   1028            else
   1029            {
   1030              status = ZMemError;
   \                     ??zcl_SendWriteRsp_1:
   \   000048   7A401000     MOV.B   #0x10, R10
   1031            }
   1032          
   1033            return ( status );
   \                     ??zcl_SendWriteRsp_4:
   \   00004C   ........     BRA     #?Subroutine1
   1034          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine34:
   \   000000   4A4C         MOV.B   R12, R10
   \   000002                REQUIRE ??Subroutine34_0
   \   000002                // Fall through to label ??Subroutine34_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine34_0:
   \   000000   0C49         MOV.W   R9, R12
   \   000002   ........     BRA     #osal_mem_free

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine33:
   \   000000   4C4E         MOV.B   R14, R12
   \   000002   5C06         RLAM.W  #0x2, R12
   \   000004   0D46         MOV.W   R6, R13
   \   000006   0D5C         ADD.W   R12, R13
   \   000008   DF4D02000000 MOV.B   0x2(R13), 0(R15)
   \   00000E   1F53         ADD.W   #0x1, R15
   \   000010   2D52         ADD.W   #0x4, R13
   \   000012   ........     BRA     #?Subroutine55

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine19:
   \   000000   4A4C         MOV.B   R12, R10
   \   000002   0B4D         MOV.W   R13, R11
   \   000004   084E         MOV.W   R14, R8
   \   000006   064F         MOV.W   R15, R6
   \   000008   6F46         MOV.B   @R6, R15
   \   00000A   074F         MOV.W   R15, R7
   \   00000C                RPT     #0x2
   \   00000C   4118075F     ADDX.W  R15, R7
   \   000010   0C47         MOV.W   R7, R12
   \   000012   ........     CALLA   #osal_mem_alloc
   \   000016   094C         MOV.W   R12, R9
   \   000018   0C93         CMP.W   #0x0, R12
   \   00001A   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine32:
   \   000000   0E48         MOV.W   R8, R14
   \   000002   0D4B         MOV.W   R11, R13
   \   000004   ....         JMP     ?Subroutine57
   \   000006   0343         NOP
   1035          #endif // ZCL_WRITE
   1036          
   1037          #ifdef ZCL_REPORT
   1038          /*********************************************************************
   1039           * @fn      zcl_SendConfigReportCmd
   1040           *
   1041           * @brief   Send a Configure Reporting command
   1042           *
   1043           * @param   dstAddr - destination address
   1044           * @param   clusterID - cluster ID
   1045           * @param   cfgReportCmd - configure reporting command to be sent
   1046           * @param   direction - direction of the command
   1047           * @param   seqNum - transaction sequence number
   1048           *
   1049           * @return  ZSuccess if OK
   1050           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine56:
   \   000000   ........     CALLA   #zclAnalogDataType
   \   000004   4C93         CMP.B   #0x0, R12
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1051          ZStatus_t zcl_SendConfigReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportCmd:
   1052                                    uint16 clusterID, zclCfgReportCmd_t *cfgReportCmd,
   1053                                    uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1054          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   ........     CALLA   #?Subroutine24
   1055            uint8 *buf;
   1056            uint16 dataLen = 0;
   1057            ZStatus_t status;
   1058          
   1059            // Find out the data length
   1060            for ( uint8 i = 0; i < cfgReportCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_20:
   \   000006   023C         JMP     ??zcl_SendConfigReportCmd_4
   1061            {
   1062              zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1063          
   1064              dataLen += 1 + 2; // Direction + Attribute ID
   1065          
   1066              if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1067              {
   1068                dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1069          
   1070                // Find out the size of the Reportable Change field (for Analog data types)
   1071                if ( zclAnalogDataType( reportRec->dataType ) )
   1072                {
   1073                  dataLen += zclGetDataTypeLength( reportRec->dataType );
   1074                }
   1075              }
   1076              else
   1077              {
   1078                dataLen += 2; // Timeout Period
   \                     ??zcl_SendConfigReportCmd_0:
   \   000008   2753         ADD.W   #0x2, R7
   1079              }
   \                     ??zcl_SendConfigReportCmd_1:
   \   00000A   5E53         ADD.B   #0x1, R14
   \                     ??zcl_SendConfigReportCmd_4:
   \   00000C   6E96         CMP.B   @R6, R14
   \   00000E   0E2C         JC      ??zcl_SendConfigReportCmd_5
   \   000010   ........     CALLA   #?Subroutine43
   \                     ??CrossCallReturnLabel_46:
   \   000014   37500300     ADD.W   #0x3, R7
   \   000018   CF930000     CMP.B   #0x0, 0(R15)
   \   00001C   F523         JNE     ??zcl_SendConfigReportCmd_0
   \   00001E   ........     CALLA   #?Subroutine46
   \                     ??CrossCallReturnLabel_49:
   \   000022   4C93         CMP.B   #0x0, R12
   \   000024   F227         JEQ     ??zcl_SendConfigReportCmd_1
   \   000026   ........     CALLA   #?Subroutine49
   1080            }
   \                     ??CrossCallReturnLabel_54:
   \   00002A   EF3F         JMP     ??zcl_SendConfigReportCmd_1
   1081          
   1082            buf = osal_mem_alloc( dataLen );
   \                     ??zcl_SendConfigReportCmd_5:
   \   00002C   ........     CALLA   #?Subroutine29
   1083            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_31:
   \   000030   2724         JEQ     ??zcl_SendConfigReportCmd_6
   1084            {
   1085              // Load the buffer - serially
   1086              uint8 *pBuf = buf;
   \   000032   0E4C         MOV.W   R12, R14
   1087              for ( uint8 i = 0; i < cfgReportCmd->numAttr; i++ )
   \   000034   4443         MOV.B   #0x0, R4
   \   000036   033C         JMP     ??zcl_SendConfigReportCmd_7
   1088              {
   1089                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   1090          
   1091                *pBuf++ = reportRec->direction;
   1092                *pBuf++ = LO_UINT16( reportRec->attrID );
   1093                *pBuf++ = HI_UINT16( reportRec->attrID );
   1094          
   1095                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   1096                {
   1097                  *pBuf++ = reportRec->dataType;
   1098                  *pBuf++ = LO_UINT16( reportRec->minReportInt );
   1099                  *pBuf++ = HI_UINT16( reportRec->minReportInt );
   1100                  *pBuf++ = LO_UINT16( reportRec->maxReportInt );
   1101                  *pBuf++ = HI_UINT16( reportRec->maxReportInt );
   1102          
   1103                  if ( zclAnalogDataType( reportRec->dataType ) )
   1104                  {
   1105                    pBuf = zclSerializeData( reportRec->dataType, reportRec->reportableChange, pBuf );
   1106                  }
   1107                }
   1108                else
   1109                {
   1110                  *pBuf++ = LO_UINT16( reportRec->timeoutPeriod );
   \                     ??zcl_SendConfigReportCmd_2:
   \   000038   ........     CALLA   #?Subroutine48
   1111                  *pBuf++ = HI_UINT16( reportRec->timeoutPeriod );
   1112                }
   \                     ??zcl_SendConfigReportCmd_3:
   \   00003C   5453         ADD.B   #0x1, R4
   \                     ??zcl_SendConfigReportCmd_7:
   \   00003E   6496         CMP.B   @R6, R4
   \   000040   0C2C         JC      ??zcl_SendConfigReportCmd_8
   \   000042   ........     CALLA   #?Subroutine39
   \                     ??CrossCallReturnLabel_60:
   \   000046   ........     CALLA   #?Subroutine42
   \                     ??CrossCallReturnLabel_44:
   \   00004A   F623         JNE     ??zcl_SendConfigReportCmd_2
   \   00004C   ........     CALLA   #?Subroutine40
   \                     ??CrossCallReturnLabel_63:
   \   000050   F527         JEQ     ??zcl_SendConfigReportCmd_3
   \   000052   ........     CALLA   #?Subroutine44
   1113              } // for loop
   \                     ??CrossCallReturnLabel_47:
   \   000056   0E4C         MOV.W   R12, R14
   \   000058   F13F         JMP     ??zcl_SendConfigReportCmd_3
   1114          
   1115              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_CONFIG_REPORT, FALSE,
   1116                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportCmd_8:
   \   00005A   0B12         PUSH.W  R11
   \   00005C   0712         PUSH.W  R7
   \   00005E   51121E00     PUSH.B  0x1e(SP)
   \   000062   0312         PUSH.W  #0x0
   \   000064   51122000     PUSH.B  0x20(SP)
   \   000068   51122000     PUSH.B  0x20(SP)
   \   00006C   4312         PUSH.B  #0x0
   \   00006E   7F400600     MOV.B   #0x6, R15
   \   000072   ........     CALLA   #?Subroutine26
   1117              osal_mem_free( buf );
   1118            }
   \                     ??CrossCallReturnLabel_74:
   \   000076   ........     CALLA   #?Subroutine25
   \                     ??CrossCallReturnLabel_23:
   \   00007A   31500E00     ADD.W   #0xe, SP
   \   00007E   023C         JMP     ??zcl_SendConfigReportCmd_9
   1119            else
   1120            {
   1121              status = ZMemError;
   \                     ??zcl_SendConfigReportCmd_6:
   \   000080   7A401000     MOV.B   #0x10, R10
   1122            }
   1123          
   1124            return ( status );
   \                     ??zcl_SendConfigReportCmd_9:
   \   000084                REQUIRE ?Subroutine5
   \   000084                // Fall through to label ?Subroutine5
   1125          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine49:
   \   000000   5C4F0400     MOV.B   0x4(R15), R12
   \   000004   ........     CALLA   #zclGetDataTypeLength
   \   000008   4C4C         MOV.B   R12, R12
   \   00000A   075C         ADD.W   R12, R7
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine48:
   \   000000   DE4F0A000000 MOV.B   0xa(R15), 0(R14)
   \   000006   1E53         ADD.W   #0x1, R14
   \   000008   DE4F0B000000 MOV.B   0xb(R15), 0(R14)
   \   00000E   1E53         ADD.W   #0x1, R14
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine46:
   \   000000   37500500     ADD.W   #0x5, R7
   \   000004   5C4F0400     MOV.B   0x4(R15), R12
   \   000008   ........     BRA     #zclAnalogDataType

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine44:
   \   000000   1D4F0C00     MOV.W   0xc(R15), R13
   \   000004   5C4F0400     MOV.B   0x4(R15), R12
   \   000008   ........     BRA     #zclSerializeData

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine43:
   \   000000   0B4E         MOV.W   R14, R11
   \   000002                RPT     #0xd
   \   000002   4C180B5E     ADDX.W  R14, R11
   \   000006   0F46         MOV.W   R6, R15
   \   000008   0F5B         ADD.W   R11, R15
   \   00000A   2F53         ADD.W   #0x2, R15
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine42:
   \   000000   DE4F02000000 MOV.B   0x2(R15), 0(R14)
   \   000006   1E53         ADD.W   #0x1, R14
   \   000008   DE4F03000000 MOV.B   0x3(R15), 0(R14)
   \   00000E   1E53         ADD.W   #0x1, R14
   \   000010   CF930000     CMP.B   #0x0, 0(R15)
   \   000014   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine40:
   \   000000   DE4F04000000 MOV.B   0x4(R15), 0(R14)
   \   000006   1E53         ADD.W   #0x1, R14
   \   000008   DE4F06000000 MOV.B   0x6(R15), 0(R14)
   \   00000E   1E53         ADD.W   #0x1, R14
   \   000010   DE4F07000000 MOV.B   0x7(R15), 0(R14)
   \   000016   1E53         ADD.W   #0x1, R14
   \   000018   DE4F08000000 MOV.B   0x8(R15), 0(R14)
   \   00001E   1E53         ADD.W   #0x1, R14
   \   000020   DE4F09000000 MOV.B   0x9(R15), 0(R14)
   \   000026   1E53         ADD.W   #0x1, R14
   \   000028   5C4F0400     MOV.B   0x4(R15), R12
   \   00002C   ........     BRA     #?Subroutine56

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine39:
   \   000000   0D44         MOV.W   R4, R13
   \   000002                RPT     #0xd
   \   000002   4C180D54     ADDX.W  R4, R13
   \   000006                REQUIRE ?Subroutine54
   \   000006                // Fall through to label ?Subroutine54
   1126          
   1127          /*********************************************************************
   1128           * @fn      zcl_SendConfigReportRspCmd
   1129           *
   1130           * @brief   Send a Configure Reporting Response command
   1131           *
   1132           * @param   dstAddr - destination address
   1133           * @param   clusterID - cluster ID
   1134           * @param   cfgReportRspCmd - configure reporting response command to be sent
   1135           * @param   direction - direction of the command
   1136           * @param   seqNum - transaction sequence number
   1137           *
   1138           * @return  ZSuccess if OK
   1139           */

   \                                 In  segment CODE, align 2, keep-with-next
   1140          ZStatus_t zcl_SendConfigReportRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendConfigReportRspCmd:
   1141                              uint16 clusterID, zclCfgReportRspCmd_t *cfgReportRspCmd,
   1142                              uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1143          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   094D         MOV.W   R13, R9
   \   000006   064E         MOV.W   R14, R6
   \   000008   074F         MOV.W   R15, R7
   1144            uint16 dataLen;
   1145            uint8 *buf;
   1146            ZStatus_t status;
   1147          
   1148            // Atrribute list (Status, Direction and Attribute ID)
   1149            dataLen = cfgReportRspCmd->numAttr * ( 1 + 1 + 2 );
   \   00000A   6B4F         MOV.B   @R15, R11
   \   00000C   5B06         RLAM.W  #0x2, R11
   1150          
   1151            buf = osal_mem_alloc( dataLen );
   \   00000E   0C4B         MOV.W   R11, R12
   \   000010   ........     CALLA   #??Subroutine28_0
   1152            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_111:
   \   000014   3024         JEQ     ??zcl_SendConfigReportRspCmd_1
   1153            {
   1154              // Load the buffer - serially
   1155              uint8 *pBuf = buf;
   \   000016   0F4C         MOV.W   R12, R15
   1156              for ( uint8 i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   000018   4E43         MOV.B   #0x0, R14
   \   00001A   0F3C         JMP     ??zcl_SendConfigReportRspCmd_2
   1157              {
   1158                *pBuf++ = cfgReportRspCmd->attrList[i].status;
   \                     ??zcl_SendConfigReportRspCmd_0:
   \   00001C   4C4E         MOV.B   R14, R12
   \   00001E   5C06         RLAM.W  #0x2, R12
   \   000020   0D47         MOV.W   R7, R13
   \   000022   0D5C         ADD.W   R12, R13
   \   000024   DF4D02000000 MOV.B   0x2(R13), 0(R15)
   \   00002A   1F53         ADD.W   #0x1, R15
   1159                *pBuf++ = cfgReportRspCmd->attrList[i].direction;
   \   00002C   DF4D03000000 MOV.B   0x3(R13), 0(R15)
   \   000032   1F53         ADD.W   #0x1, R15
   1160                *pBuf++ = LO_UINT16( cfgReportRspCmd->attrList[i].attrID );
   \   000034   2D52         ADD.W   #0x4, R13
   \   000036   ........     CALLA   #?Subroutine55
   1161                *pBuf++ = HI_UINT16( cfgReportRspCmd->attrList[i].attrID );
   1162              }
   \                     ??zcl_SendConfigReportRspCmd_2:
   \   00003A   6D47         MOV.B   @R7, R13
   \   00003C   4E9D         CMP.B   R13, R14
   \   00003E   EE2B         JNC     ??zcl_SendConfigReportRspCmd_0
   1163          
   1164              // If there's only a single status record and its status field is set to
   1165              // SUCCESS then omit the attribute ID field.
   1166              if ( cfgReportRspCmd->numAttr == 1 && cfgReportRspCmd->attrList[0].status == ZCL_STATUS_SUCCESS )
   \   000040   5D93         CMP.B   #0x1, R13
   \   000042   0420         JNE     ??zcl_SendConfigReportRspCmd_3
   \   000044   C7930200     CMP.B   #0x0, 0x2(R7)
   \   000048   0120         JNE     ??zcl_SendConfigReportRspCmd_3
   1167              {
   1168                dataLen = 1;
   \   00004A   1B43         MOV.W   #0x1, R11
   1169              }
   1170          
   1171              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1172                                        ZCL_CMD_CONFIG_REPORT_RSP, FALSE, direction,
   1173                                        disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendConfigReportRspCmd_3:
   \   00004C   0812         PUSH.W  R8
   \   00004E   0B12         PUSH.W  R11
   \   000050   51121A00     PUSH.B  0x1a(SP)
   \   000054   0312         PUSH.W  #0x0
   \   000056   51121C00     PUSH.B  0x1c(SP)
   \   00005A   51121C00     PUSH.B  0x1c(SP)
   \   00005E   4312         PUSH.B  #0x0
   \   000060   7F400700     MOV.B   #0x7, R15
   \   000064   0E46         MOV.W   R6, R14
   \   000066   0D49         MOV.W   R9, R13
   \   000068   ........     CALLA   #?Subroutine57
   1174              osal_mem_free( buf );
   1175            }
   \                     ??CrossCallReturnLabel_69:
   \   00006C   ........     CALLA   #?Subroutine27
   \                     ??CrossCallReturnLabel_27:
   \   000070   31500E00     ADD.W   #0xe, SP
   \   000074   023C         JMP     ??zcl_SendConfigReportRspCmd_4
   1176            else
   1177            {
   1178              status = ZMemError;
   \                     ??zcl_SendConfigReportRspCmd_1:
   \   000076   7A401000     MOV.B   #0x10, R10
   1179            }
   1180          
   1181            return ( status );
   \                     ??zcl_SendConfigReportRspCmd_4:
   \   00007A                REQUIRE ?Subroutine1
   \   00007A                // Fall through to label ?Subroutine1
   1182          }
   1183          
   1184          /*********************************************************************
   1185           * @fn      zcl_SendReadReportCfgCmd
   1186           *
   1187           * @brief   Send a Read Reporting Configuration command
   1188           *
   1189           * @param   dstAddr - destination address
   1190           * @param   clusterID - cluster ID
   1191           * @param   readReportCfgCmd - read reporting configuration command to be sent
   1192           * @param   direction - direction of the command
   1193           * @param   seqNum - transaction sequence number
   1194           *
   1195           * @return  ZSuccess if OK
   1196           */

   \                                 In  segment CODE, align 2, keep-with-next
   1197          ZStatus_t zcl_SendReadReportCfgCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgCmd:
   1198                            uint16 clusterID, zclReadReportCfgCmd_t *readReportCfgCmd,
   1199                            uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1200          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   ........     CALLA   #?Subroutine19
   1201            uint16 dataLen;
   1202            uint8 *buf;
   1203            ZStatus_t status;
   1204          
   1205            dataLen = readReportCfgCmd->numAttr * ( 1 + 2 ); // Direction + Atrribute ID
   1206          
   1207            buf = osal_mem_alloc( dataLen );
   1208            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_13:
   \   000006   1924         JEQ     ??zcl_SendReadReportCfgCmd_1
   1209            {
   1210              // Load the buffer - serially
   1211              uint8 *pBuf = buf;
   \   000008   0F4C         MOV.W   R12, R15
   1212              for ( uint8 i = 0; i < readReportCfgCmd->numAttr; i++ )
   \   00000A   4E43         MOV.B   #0x0, R14
   \   00000C   023C         JMP     ??zcl_SendReadReportCfgCmd_2
   1213              {
   1214                *pBuf++ = readReportCfgCmd->attrList[i].direction;
   \                     ??zcl_SendReadReportCfgCmd_0:
   \   00000E   ........     CALLA   #?Subroutine33
   1215                *pBuf++ = LO_UINT16( readReportCfgCmd->attrList[i].attrID );
   1216                *pBuf++ = HI_UINT16( readReportCfgCmd->attrList[i].attrID );
   1217              }
   \                     ??zcl_SendReadReportCfgCmd_2:
   \   000012   6E96         CMP.B   @R6, R14
   \   000014   FC2B         JNC     ??zcl_SendReadReportCfgCmd_0
   1218          
   1219              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_READ_REPORT_CFG, FALSE,
   1220                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000016   0912         PUSH.W  R9
   \   000018   0712         PUSH.W  R7
   \   00001A   51121A00     PUSH.B  0x1a(SP)
   \   00001E   0312         PUSH.W  #0x0
   \   000020   51121C00     PUSH.B  0x1c(SP)
   \   000024   51121C00     PUSH.B  0x1c(SP)
   \   000028   4312         PUSH.B  #0x0
   \   00002A   7F42         MOV.B   #0x8, R15
   \   00002C   ........     CALLA   #?Subroutine32
   1221              osal_mem_free( buf );
   1222            }
   \                     ??CrossCallReturnLabel_71:
   \   000030   ........     CALLA   #?Subroutine34
   \                     ??CrossCallReturnLabel_78:
   \   000034   31500E00     ADD.W   #0xe, SP
   \   000038   023C         JMP     ??zcl_SendReadReportCfgCmd_3
   1223            else
   1224            {
   1225              status = ZMemError;
   \                     ??zcl_SendReadReportCfgCmd_1:
   \   00003A   7A401000     MOV.B   #0x10, R10
   1226            }
   1227          
   1228            return ( status );
   \                     ??zcl_SendReadReportCfgCmd_3:
   \   00003E   ....         JMP     ?Subroutine1
   \   000040   0343         NOP
   1229          }
   1230          
   1231          /*********************************************************************
   1232           * @fn      zcl_SendReadReportCfgRspCmd
   1233           *
   1234           * @brief   Send a Read Reporting Configuration Response command
   1235           *
   1236           * @param   dstAddr - destination address
   1237           * @param   clusterID - cluster ID
   1238           * @param   readReportCfgRspCmd - read reporting configuration response command to be sent
   1239           * @param   direction - direction of the command
   1240           * @param   seqNum - transaction sequence number
   1241           *
   1242           * @return  ZSuccess if OK
   1243           */

   \                                 In  segment CODE, align 2, keep-with-next
   1244          ZStatus_t zcl_SendReadReportCfgRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReadReportCfgRspCmd:
   1245                       uint16 clusterID, zclReadReportCfgRspCmd_t *readReportCfgRspCmd,
   1246                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1247          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   ........     CALLA   #?Subroutine24
   1248            uint8 *buf;
   1249            uint16 dataLen = 0;
   1250            ZStatus_t status;
   1251          
   1252            // Find out the data length
   1253            for ( uint8 i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_19:
   \   000006   023C         JMP     ??zcl_SendReadReportCfgRspCmd_4
   1254            {
   1255              zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1256          
   1257              dataLen += 1 + 1 + 2 ; // Status, Direction and Atrribute ID
   1258          
   1259              if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1260              {
   1261                if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1262                {
   1263                  dataLen += 1 + 2 + 2; // Data Type + Min + Max Reporting Intervals
   1264          
   1265                  // Find out the size of the Reportable Change field (for Analog data types)
   1266                  if ( zclAnalogDataType( reportRspRec->dataType ) )
   1267                  {
   1268                    dataLen += zclGetDataTypeLength( reportRspRec->dataType );
   1269                  }
   1270                }
   1271                else
   1272                {
   1273                  dataLen += 2; // Timeout Period
   \                     ??zcl_SendReadReportCfgRspCmd_1:
   \   000008   2753         ADD.W   #0x2, R7
   1274                }
   \                     ??zcl_SendReadReportCfgRspCmd_0:
   \   00000A   5E53         ADD.B   #0x1, R14
   \                     ??zcl_SendReadReportCfgRspCmd_4:
   \   00000C   6E96         CMP.B   @R6, R14
   \   00000E   102C         JC      ??zcl_SendReadReportCfgRspCmd_5
   \   000010   ........     CALLA   #?Subroutine43
   \                     ??CrossCallReturnLabel_45:
   \   000014   2752         ADD.W   #0x4, R7
   \   000016   CF930000     CMP.B   #0x0, 0(R15)
   \   00001A   F723         JNE     ??zcl_SendReadReportCfgRspCmd_0
   \   00001C   CF930100     CMP.B   #0x0, 0x1(R15)
   \   000020   F323         JNE     ??zcl_SendReadReportCfgRspCmd_1
   \   000022   ........     CALLA   #?Subroutine46
   \                     ??CrossCallReturnLabel_50:
   \   000026   4C93         CMP.B   #0x0, R12
   \   000028   F027         JEQ     ??zcl_SendReadReportCfgRspCmd_0
   \   00002A   ........     CALLA   #?Subroutine49
   1275              }
   1276            }
   \                     ??CrossCallReturnLabel_53:
   \   00002E   ED3F         JMP     ??zcl_SendReadReportCfgRspCmd_0
   1277          
   1278            buf = osal_mem_alloc( dataLen );
   \                     ??zcl_SendReadReportCfgRspCmd_5:
   \   000030   ........     CALLA   #?Subroutine29
   1279            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_30:
   \   000034   2E24         JEQ     ??zcl_SendReadReportCfgRspCmd_6
   1280            {
   1281              // Load the buffer - serially
   1282              uint8 *pBuf = buf;
   \   000036   0E4C         MOV.W   R12, R14
   1283              for ( uint8 i = 0; i < readReportCfgRspCmd->numAttr; i++ )
   \   000038   4443         MOV.B   #0x0, R4
   \   00003A   033C         JMP     ??zcl_SendReadReportCfgRspCmd_7
   1284              {
   1285                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   1286          
   1287                *pBuf++ = reportRspRec->status;
   1288                *pBuf++ = reportRspRec->direction;
   1289                *pBuf++ = LO_UINT16( reportRspRec->attrID );
   1290                *pBuf++ = HI_UINT16( reportRspRec->attrID );
   1291          
   1292                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   1293                {
   1294                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   1295                  {
   1296                    *pBuf++ = reportRspRec->dataType;
   1297                    *pBuf++ = LO_UINT16( reportRspRec->minReportInt );
   1298                    *pBuf++ = HI_UINT16( reportRspRec->minReportInt );
   1299                    *pBuf++ = LO_UINT16( reportRspRec->maxReportInt );
   1300                    *pBuf++ = HI_UINT16( reportRspRec->maxReportInt );
   1301          
   1302                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   1303                    {
   1304                      pBuf = zclSerializeData( reportRspRec->dataType,
   1305                                               reportRspRec->reportableChange, pBuf );
   1306                    }
   1307                  }
   1308                  else
   1309                  {
   1310                    *pBuf++ = LO_UINT16( reportRspRec->timeoutPeriod );
   \                     ??zcl_SendReadReportCfgRspCmd_3:
   \   00003C   ........     CALLA   #?Subroutine48
   1311                    *pBuf++ = HI_UINT16( reportRspRec->timeoutPeriod );
   1312                  }
   \                     ??zcl_SendReadReportCfgRspCmd_2:
   \   000040   5453         ADD.B   #0x1, R4
   \                     ??zcl_SendReadReportCfgRspCmd_7:
   \   000042   6496         CMP.B   @R6, R4
   \   000044   132C         JC      ??zcl_SendReadReportCfgRspCmd_8
   \   000046   ........     CALLA   #?Subroutine39
   \                     ??CrossCallReturnLabel_59:
   \   00004A   DE4F01000000 MOV.B   0x1(R15), 0(R14)
   \   000050   1E53         ADD.W   #0x1, R14
   \   000052   ........     CALLA   #?Subroutine42
   \                     ??CrossCallReturnLabel_43:
   \   000056   F423         JNE     ??zcl_SendReadReportCfgRspCmd_2
   \   000058   CF930100     CMP.B   #0x0, 0x1(R15)
   \   00005C   EF23         JNE     ??zcl_SendReadReportCfgRspCmd_3
   \   00005E   ........     CALLA   #?Subroutine40
   \                     ??CrossCallReturnLabel_62:
   \   000062   EE27         JEQ     ??zcl_SendReadReportCfgRspCmd_2
   \   000064   ........     CALLA   #?Subroutine44
   1313                }
   1314              }
   \                     ??CrossCallReturnLabel_48:
   \   000068   0E4C         MOV.W   R12, R14
   \   00006A   EA3F         JMP     ??zcl_SendReadReportCfgRspCmd_2
   1315          
   1316              status = zcl_SendCommand( srcEP, dstAddr, clusterID,
   1317                                        ZCL_CMD_READ_REPORT_CFG_RSP, FALSE,
   1318                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \                     ??zcl_SendReadReportCfgRspCmd_8:
   \   00006C   0B12         PUSH.W  R11
   \   00006E   0712         PUSH.W  R7
   \   000070   51121E00     PUSH.B  0x1e(SP)
   \   000074   0312         PUSH.W  #0x0
   \   000076   51122000     PUSH.B  0x20(SP)
   \   00007A   51122000     PUSH.B  0x20(SP)
   \   00007E   4312         PUSH.B  #0x0
   \   000080   7F400900     MOV.B   #0x9, R15
   \   000084   ........     CALLA   #?Subroutine26
   1319              osal_mem_free( buf );
   1320            }
   \                     ??CrossCallReturnLabel_75:
   \   000088   ........     CALLA   #?Subroutine25
   \                     ??CrossCallReturnLabel_24:
   \   00008C   31500E00     ADD.W   #0xe, SP
   \   000090   023C         JMP     ??zcl_SendReadReportCfgRspCmd_9
   1321            else
   1322            {
   1323              status = ZMemError;
   \                     ??zcl_SendReadReportCfgRspCmd_6:
   \   000092   7A401000     MOV.B   #0x10, R10
   1324            }
   1325          
   1326            return ( status );
   \                     ??zcl_SendReadReportCfgRspCmd_9:
   \   000096   ....         JMP     ?Subroutine5
   \   000098   0343         NOP
   1327          }
   1328          
   1329          /*********************************************************************
   1330           * @fn      zcl_SendReportCmd
   1331           *
   1332           * @brief   Send a Report command
   1333           *
   1334           * @param   dstAddr - destination address
   1335           * @param   clusterID - cluster ID
   1336           * @param   reportCmd - report command to be sent
   1337           * @param   direction - direction of the command
   1338           * @param   seqNum - transaction sequence number
   1339           *
   1340           * @return  ZSuccess if OK
   1341           */

   \                                 In  segment CODE, align 2, keep-with-next
   1342          ZStatus_t zcl_SendReportCmd( uint8 srcEP, afAddrType_t *dstAddr,
   \                     zcl_SendReportCmd:
   1343                                       uint16 clusterID, zclReportCmd_t *reportCmd,
   1344                                       uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1345          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   ........     CALLA   #?Subroutine24
   1346            uint16 dataLen = 0;
   1347            uint8 *buf;
   1348            ZStatus_t status;
   1349          
   1350            // calculate the size of the command
   1351            for ( uint8 i = 0; i < reportCmd->numAttr; i++ )
   \                     ??CrossCallReturnLabel_18:
   \   000006   023C         JMP     ??zcl_SendReportCmd_2
   1352            {
   1353              zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_0:
   \   000008   ........     CALLA   #?Subroutine9
   1354          
   1355              dataLen += 2 + 1; // Attribute ID + data type
   1356          
   1357              // Attribute Data
   1358              dataLen += zclGetAttrDataLength( reportRec->dataType, reportRec->attrData );
   1359            }
   \                     ??zcl_SendReportCmd_2:
   \   00000C   6E96         CMP.B   @R6, R14
   \   00000E   FC2B         JNC     ??zcl_SendReportCmd_0
   1360          
   1361            buf = osal_mem_alloc( dataLen );
   \   000010   ........     CALLA   #?Subroutine29
   1362            if ( buf != NULL )
   \                     ??CrossCallReturnLabel_29:
   \   000014   1A24         JEQ     ??zcl_SendReportCmd_3
   1363            {
   1364              // Load the buffer - serially
   1365              uint8 *pBuf = buf;
   \   000016   0E4C         MOV.W   R12, R14
   1366              for ( uint8 i = 0; i < reportCmd->numAttr; i++ )
   \   000018   4443         MOV.B   #0x0, R4
   \   00001A   023C         JMP     ??zcl_SendReportCmd_4
   1367              {
   1368                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   \                     ??zcl_SendReportCmd_1:
   \   00001C   ........     CALLA   #?Subroutine8
   1369          
   1370                *pBuf++ = LO_UINT16( reportRec->attrID );
   1371                *pBuf++ = HI_UINT16( reportRec->attrID );
   1372                *pBuf++ = reportRec->dataType;
   1373          
   1374                pBuf = zclSerializeData( reportRec->dataType, reportRec->attrData, pBuf );
   1375              }
   \                     ??zcl_SendReportCmd_4:
   \   000020   6496         CMP.B   @R6, R4
   \   000022   FC2B         JNC     ??zcl_SendReportCmd_1
   1376          
   1377              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_REPORT, FALSE,
   1378                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   \   000024   0B12         PUSH.W  R11
   \   000026   0712         PUSH.W  R7
   \   000028   51121E00     PUSH.B  0x1e(SP)
   \   00002C   0312         PUSH.W  #0x0
   \   00002E   51122000     PUSH.B  0x20(SP)
   \   000032   51122000     PUSH.B  0x20(SP)
   \   000036   4312         PUSH.B  #0x0
   \   000038   7F400A00     MOV.B   #0xa, R15
   \   00003C   ........     CALLA   #?Subroutine26
   1379              osal_mem_free( buf );
   1380            }
   \                     ??CrossCallReturnLabel_76:
   \   000040   ........     CALLA   #?Subroutine25
   \                     ??CrossCallReturnLabel_25:
   \   000044   31500E00     ADD.W   #0xe, SP
   \   000048   023C         JMP     ??zcl_SendReportCmd_5
   1381            else
   1382            {
   1383              status = ZMemError;
   \                     ??zcl_SendReportCmd_3:
   \   00004A   7A401000     MOV.B   #0x10, R10
   1384            }
   1385          
   1386            return ( status );
   \                     ??zcl_SendReportCmd_5:
   \   00004E   ....         JMP     ?Subroutine5
   \   000050   0343         NOP
   1387          }
   1388          #endif // ZCL_REPORT
   1389          
   1390          /*********************************************************************
   1391           * @fn      zcl_SendDefaultRspCmd
   1392           *
   1393           * @brief   Send a Default Response command
   1394           *
   1395           *          Note: The manufacturer code field should be set if this
   1396           *          command is being sent in response to a manufacturer specific
   1397           *          command.
   1398           *
   1399           * @param   dstAddr - destination address
   1400           * @param   clusterID - cluster ID
   1401           * @param   defaultRspCmd - default response command to be sent
   1402           * @param   direction - direction of the command
   1403           * @param   manuCode - manufacturer code for proprietary extensions to a profile
   1404           * @param   seqNum - transaction sequence number
   1405           *
   1406           * @return  ZSuccess if OK
   1407           */

   \                                 In  segment CODE, align 2, keep-with-next
   1408          ZStatus_t zcl_SendDefaultRspCmd( uint8 srcEP, afAddrType_t *dstAddr, uint16 clusterID,
   \                     zcl_SendDefaultRspCmd:
   1409                                           zclDefaultRspCmd_t *defaultRspCmd, uint8 direction,
   1410                                           uint8 disableDefaultRsp, uint16 manuCode, uint8 seqNum )
   1411          {
   \   000000   2183         SUB.W   #0x2, SP
   1412            uint8 buf[2]; // Command ID and Status;
   1413          
   1414            // Load the buffer - serially
   1415            buf[0] = defaultRspCmd->commandID;
   \   000002   E14F0000     MOV.B   @R15, 0(SP)
   1416            buf[1] = defaultRspCmd->statusCode;
   \   000006   D14F01000100 MOV.B   0x1(R15), 0x1(SP)
   1417          
   1418            return ( zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DEFAULT_RSP, FALSE,
   1419                                      direction, disableDefaultRsp, manuCode, seqNum, 2, buf ) );
   \   00000C   0F41         MOV.W   SP, R15
   \   00000E   0F12         PUSH.W  R15
   \   000010   2312         PUSH.W  #0x2
   \   000012   51121200     PUSH.B  0x12(SP)
   \   000016   11121200     PUSH.W  0x12(SP)
   \   00001A   51121200     PUSH.B  0x12(SP)
   \   00001E   51121200     PUSH.B  0x12(SP)
   \   000022   4312         PUSH.B  #0x0
   \   000024   7F400B00     MOV.B   #0xb, R15
   \   000028   ........     CALLA   #zcl_SendCommand
   \   00002C   31501000     ADD.W   #0x10, SP
   \   000030   1001         RETA
   1420          }
   1421          
   1422          #ifdef ZCL_DISCOVER
   1423          /*********************************************************************
   1424           * @fn      zcl_SendDiscoverCmd
   1425           *
   1426           * @brief   Send a Discover command
   1427           *
   1428           * @param   dstAddr - destination address
   1429           * @param   clusterID - cluster ID
   1430           * @param   discoverCmd - discover command to be sent
   1431           * @param   direction - direction of the command
   1432           * @param   seqNum - transaction sequence number
   1433           *
   1434           * @return  ZSuccess if OK
   1435           */
   1436          ZStatus_t zcl_SendDiscoverCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1437                                      uint16 clusterID, zclDiscoverCmd_t *discoverCmd,
   1438                                      uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1439          {
   1440            uint16 dataLen = 2 + 1; // Start Attribute ID and Max Attribute IDs
   1441            uint8 *buf;
   1442            ZStatus_t status;
   1443          
   1444            buf = osal_mem_alloc( dataLen );
   1445            if ( buf != NULL )
   1446            {
   1447              // Load the buffer - serially
   1448              uint8 *pBuf = buf;
   1449              *pBuf++ = LO_UINT16(discoverCmd->startAttr);
   1450              *pBuf++ = HI_UINT16(discoverCmd->startAttr);
   1451              *pBuf++ = discoverCmd->maxAttrIDs;
   1452          
   1453              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER, FALSE,
   1454                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1455              osal_mem_free( buf );
   1456            }
   1457            else
   1458            {
   1459              status = ZMemError;
   1460            }
   1461          
   1462            return ( status );
   1463          }
   1464          
   1465          /*********************************************************************
   1466           * @fn      zcl_SendDiscoverRspCmd
   1467           *
   1468           * @brief   Send a Discover Response command
   1469           *
   1470           * @param   dstAddr - destination address
   1471           * @param   clusterID - cluster ID
   1472           * @param   reportRspCmd - report response command to be sent
   1473           * @param   direction - direction of the command
   1474           * @param   seqNum - transaction sequence number
   1475           *
   1476           * @return  ZSuccess if OK
   1477           */
   1478          ZStatus_t zcl_SendDiscoverRspCmd( uint8 srcEP, afAddrType_t *dstAddr,
   1479                                uint16 clusterID, zclDiscoverRspCmd_t *discoverRspCmd,
   1480                                uint8 direction, uint8 disableDefaultRsp, uint8 seqNum )
   1481          {
   1482            uint16 dataLen = 1; // Discovery complete
   1483            uint8 *buf;
   1484            ZStatus_t status;
   1485          
   1486            // calculate the size of the command
   1487            dataLen += discoverRspCmd->numAttr * (2 + 1); // Attribute ID and Data Type
   1488          
   1489            buf = osal_mem_alloc( dataLen );
   1490            if ( buf != NULL )
   1491            {
   1492              // Load the buffer - serially
   1493              uint8 *pBuf = buf;
   1494              *pBuf++ = discoverRspCmd->discComplete;
   1495              for ( uint8 i = 0; i < discoverRspCmd->numAttr; i++ )
   1496              {
   1497                *pBuf++ = LO_UINT16(discoverRspCmd->attrList[i].attrID);
   1498                *pBuf++ = HI_UINT16(discoverRspCmd->attrList[i].attrID);
   1499                *pBuf++ = discoverRspCmd->attrList[i].dataType;
   1500              }
   1501          
   1502              status = zcl_SendCommand( srcEP, dstAddr, clusterID, ZCL_CMD_DISCOVER_RSP, FALSE,
   1503                                        direction, disableDefaultRsp, 0, seqNum, dataLen, buf );
   1504              osal_mem_free( buf );
   1505            }
   1506            else
   1507            {
   1508              status = ZMemError;
   1509            }
   1510          
   1511            return ( status );
   1512          }
   1513          #endif // ZCL_DISCOVER
   1514          
   1515          /*********************************************************************
   1516           * PRIVATE FUNCTIONS
   1517           *********************************************************************/
   1518          
   1519          /*********************************************************************
   1520           * @fn      zclProcessMessageMSG
   1521           *
   1522           * @brief   Data message processor callback.  This function processes
   1523           *          any incoming data - probably from other devices.  So, based
   1524           *          on cluster ID, perform the intended action.
   1525           *
   1526           * @param   pkt - incoming message
   1527           *
   1528           * @return  none
   1529           */

   \                                 In  segment CODE, align 2, keep-with-next
   1530          void zclProcessMessageMSG( afIncomingMSGPacket_t *pkt )
   \                     zclProcessMessageMSG:
   1531          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31801600     SUB.W   #0x16, SP
   \   000006   0A4C         MOV.W   R12, R10
   1532            endPointDesc_t *epDesc;
   1533            zclIncoming_t inMsg;
   1534            zclLibPlugin_t *pInPlugin;
   1535            zclDefaultRspCmd_t defautlRspCmd;
   1536            uint8 options;
   1537            uint8 securityEnable;
   1538            uint8 interPanMsg;
   1539            ZStatus_t status = ZFailure;
   1540          
   1541            if ( pkt->cmd.DataLength == 0 )
   \   000008   8C932200     CMP.W   #0x0, 0x22(R12)
   \   00000C   2525         JEQ     ??zclProcessMessageMSG_1
   1542            {
   1543              return;   // Error, ignore the message
   1544            }
   1545          
   1546            // Initialize
   1547            inMsg.msg = pkt;
   \   00000E   814C0200     MOV.W   R12, 0x2(SP)
   1548            inMsg.attrCmd = NULL;
   \   000012   81430E00     MOV.W   #0x0, 0xe(SP)
   1549            inMsg.pData = NULL;
   \   000016   81430A00     MOV.W   #0x0, 0xa(SP)
   1550            inMsg.pDataLen = 0;
   \   00001A   81430C00     MOV.W   #0x0, 0xc(SP)
   1551          
   1552            inMsg.pData = zclParseHdr( &(inMsg.hdr), pkt->cmd.Data );
   \   00001E   0B41         MOV.W   SP, R11
   \   000020   2B53         ADD.W   #0x2, R11
   \   000022   1D4C2400     MOV.W   0x24(R12), R13
   \   000026   0C4B         MOV.W   R11, R12
   \   000028   2C53         ADD.W   #0x2, R12
   \   00002A   ........     CALLA   #zclParseHdr
   \   00002E   814C0A00     MOV.W   R12, 0xa(SP)
   1553            inMsg.pDataLen = pkt->cmd.DataLength;
   1554            inMsg.pDataLen -= (uint16)(inMsg.pData - pkt->cmd.Data);
   \   000032   1F4A2200     MOV.W   0x22(R10), R15
   \   000036   0F8C         SUB.W   R12, R15
   \   000038   1F5A2400     ADD.W   0x24(R10), R15
   \   00003C   814F0C00     MOV.W   R15, 0xc(SP)
   1555          
   1556            // Find the wanted endpoint
   1557            epDesc = afFindEndPointDesc( pkt->endPoint );
   \   000040   084A         MOV.W   R10, R8
   \   000042   38501400     ADD.W   #0x14, R8
   \   000046   6C48         MOV.B   @R8, R12
   \   000048   ........     CALLA   #afFindEndPointDesc
   1558            if ( epDesc == NULL )
   \   00004C   0C93         CMP.W   #0x0, R12
   \   00004E   0425         JEQ     ??zclProcessMessageMSG_1
   1559            {
   1560              return;   // Error, ignore the message
   1561            }
   1562          
   1563            if ( ( epDesc->simpleDesc == NULL ) ||
   1564                 ( zcl_DeviceOperational( pkt->endPoint, pkt->clusterId, inMsg.hdr.fc.type,
   1565                                          inMsg.hdr.commandID, epDesc->simpleDesc->AppProfId ) == FALSE ) )
   \   000050   1F4C0400     MOV.W   0x4(R12), R15
   \   000054   0F93         CMP.W   #0x0, R15
   \   000056   0025         JEQ     ??zclProcessMessageMSG_1
   \   000058   094A         MOV.W   R10, R9
   \   00005A   2952         ADD.W   #0x4, R9
   \   00005C   76400300     MOV.B   #0x3, R6
   \   000060   1F120200     PUSH.W  0x2(R15)
   \   000064   5F410B00     MOV.B   0xb(SP), R15
   \   000068   4E46         MOV.B   R6, R14
   \   00006A   5EF10600     AND.B   0x6(SP), R14
   \   00006E   2D49         MOV.W   @R9, R13
   \   000070   6C48         MOV.B   @R8, R12
   \   000072   ........     CALLA   #zcl_DeviceOperational
   \   000076   2153         ADD.W   #0x2, SP
   \   000078   4C93         CMP.B   #0x0, R12
   \   00007A   EE24         JEQ     ??zclProcessMessageMSG_1
   1566            {
   1567              return; // Error, ignore the message
   1568            }
   1569          
   1570          #if defined ( INTER_PAN )
   1571            if ( StubAPS_InterPan( pkt->srcAddr.panId, pkt->srcAddr.endPoint ) )
   \   00007C   5D4A0F00     MOV.B   0xf(R10), R13
   \   000080   1C4A1000     MOV.W   0x10(R10), R12
   \   000084   ........     CALLA   #StubAPS_InterPan
   \   000088   4C93         CMP.B   #0x0, R12
   \   00008A   0A24         JEQ     ??zclProcessMessageMSG_2
   1572            {
   1573              // No foundation command is supported thru Inter-PAN communication.
   1574              // But the Smart Light cluster uses a different Frame Control format
   1575              // for it's Inter-PAN messages, where the messages could be confused
   1576              // with the foundation commands.
   1577              if ( !ZCL_CLUSTER_ID_SL( pkt->clusterId ) && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \   00008C   BA9000100400 CMP.W   #0x1000, 0x4(R10)
   \   000092   0324         JEQ     ??zclProcessMessageMSG_3
   \   000094   C1B60400     BIT.B   R6, 0x4(SP)
   \   000098   DF24         JEQ     ??zclProcessMessageMSG_1
   1578              {
   1579                return;
   1580              }
   1581          
   1582              interPanMsg = TRUE;
   \                     ??zclProcessMessageMSG_3:
   \   00009A   5443         MOV.B   #0x1, R4
   1583              options = AF_TX_OPTIONS_NONE;
   \   00009C   4C43         MOV.B   #0x0, R12
   \   00009E   053C         JMP     ??zclProcessMessageMSG_4
   1584            }
   1585            else
   1586          #endif
   1587            {
   1588              interPanMsg = FALSE;
   \                     ??zclProcessMessageMSG_2:
   \   0000A0   4443         MOV.B   #0x0, R4
   1589              options = zclGetClusterOption( pkt->endPoint, pkt->clusterId );
   \   0000A2   2D49         MOV.W   @R9, R13
   \   0000A4   6C48         MOV.B   @R8, R12
   \   0000A6   ........     CALLA   #zclGetClusterOption
   \                     ??zclProcessMessageMSG_4:
   \   0000AA   2F49         MOV.W   @R9, R15
   1590            }
   1591          
   1592            // Find the appropriate plugin
   1593            pInPlugin = zclFindPlugin( pkt->clusterId, epDesc->simpleDesc->AppProfId );
   \   0000AC   1E42....     MOV.W   &plugins, R14
   \   0000B0   013C         JMP     ??zclProcessMessageMSG_5
   \                     ??zclProcessMessageMSG_0:
   \   0000B2   2E4E         MOV.W   @R14, R14
   \                     ??zclProcessMessageMSG_5:
   \   0000B4   0E93         CMP.W   #0x0, R14
   \   0000B6   0724         JEQ     ??zclProcessMessageMSG_6
   \   0000B8   1F9E0200     CMP.W   0x2(R14), R15
   \   0000BC   FA2B         JNC     ??zclProcessMessageMSG_0
   \   0000BE   8E9F0400     CMP.W   R15, 0x4(R14)
   \   0000C2   F72B         JNC     ??zclProcessMessageMSG_0
   \   0000C4   013C         JMP     ??zclProcessMessageMSG_7
   \                     ??zclProcessMessageMSG_6:
   \   0000C6   0E43         MOV.W   #0x0, R14
   1594          
   1595            // Local and remote Security options must match except for Default Response command
   1596            if ( ( pInPlugin != NULL ) && !zcl_DefaultRspCmd( inMsg.hdr ) )
   \                     ??zclProcessMessageMSG_7:
   \   0000C8   0E93         CMP.W   #0x0, R14
   \   0000CA   3424         JEQ     ??zclProcessMessageMSG_8
   \   0000CC   F1B007000400 BIT.B   #0x7, 0x4(SP)
   \   0000D2   0420         JNE     ??zclProcessMessageMSG_9
   \   0000D4   F1900B000900 CMP.B   #0xb, 0x9(SP)
   \   0000DA   2C24         JEQ     ??zclProcessMessageMSG_8
   1597            {
   1598              securityEnable = ( options & AF_EN_SECURITY ) ? TRUE : FALSE;
   \                     ??zclProcessMessageMSG_9:
   \   0000DC   7CB04000     BIT.B   #0x40, R12
   \   0000E0   4777         SUBC.B  R7, R7
   \   0000E2   5753         ADD.B   #0x1, R7
   1599              if ( pkt->SecurityUse != securityEnable )
   \   0000E4   CA971900     CMP.B   R7, 0x19(R10)
   \   0000E8   2524         JEQ     ??zclProcessMessageMSG_8
   1600              {
   1601                if ( UNICAST_MSG( inMsg.msg ) )
   \   0000EA   1F410200     MOV.W   0x2(SP), R15
   \   0000EE   CF931500     CMP.B   #0x0, 0x15(R15)
   \   0000F2   B220         JNE     ??zclProcessMessageMSG_1
   \   0000F4   8F930200     CMP.W   #0x0, 0x2(R15)
   \   0000F8   AF20         JNE     ??zclProcessMessageMSG_1
   1602                {
   1603                  // Send a Default Response command back with no Application Link Key security
   1604                  if ( securityEnable )
   \   0000FA   57B3         BIT.B   #0x1, R7
   \   0000FC   0528         JNC     ??zclProcessMessageMSG_10
   1605                  {
   1606                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, FALSE );
   \   0000FE   4E43         MOV.B   #0x0, R14
   \   000100   2D49         MOV.W   @R9, R13
   \   000102   6C48         MOV.B   @R8, R12
   \   000104   ........     CALLA   #zclSetSecurityOption
   1607                  }
   1608          
   1609                  defautlRspCmd.statusCode = status;
   \                     ??zclProcessMessageMSG_10:
   \   000108   D1430100     MOV.B   #0x1, 0x1(SP)
   1610                  defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   00010C   D14109000000 MOV.B   0x9(SP), 0(SP)
   1611                  zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1612                                         inMsg.msg->clusterId, &defautlRspCmd,
   1613                                         ZCL_FRAME_SERVER_CLIENT_DIR, true,
   1614                                         inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   000112   51120A00     PUSH.B  0xa(SP)
   \   000116   11120A00     PUSH.W  0xa(SP)
   \   00011A   5312         PUSH.B  #0x1
   \   00011C   5312         PUSH.B  #0x1
   \   00011E   ........     CALLA   #?Subroutine10
   1615                  if ( securityEnable )
   \                     ??CrossCallReturnLabel_5:
   \   000122   3152         ADD.W   #0x8, SP
   \   000124   57B3         BIT.B   #0x1, R7
   \   000126   9828         JNC     ??zclProcessMessageMSG_1
   1616                  {
   1617                    zclSetSecurityOption( pkt->endPoint, pkt->clusterId, TRUE );
   \   000128   5E43         MOV.B   #0x1, R14
   \   00012A   2D49         MOV.W   @R9, R13
   \   00012C   6C48         MOV.B   @R8, R12
   \   00012E   ........     CALLA   #zclSetSecurityOption
   \   000132   923C         JMP     ??zclProcessMessageMSG_1
   1618                  }
   1619                }
   1620          
   1621                return;   // Error, ignore the message
   1622              }
   1623            }
   1624          
   1625            // Is this a foundation type message
   1626            if ( !interPanMsg && zcl_ProfileCmd( inMsg.hdr.fc.type ) )
   \                     ??zclProcessMessageMSG_8:
   \   000134   54B3         BIT.B   #0x1, R4
   \   000136   5A2C         JC      ??zclProcessMessageMSG_11
   \   000138   C1B60400     BIT.B   R6, 0x4(SP)
   \   00013C   5720         JNE     ??zclProcessMessageMSG_11
   1627            {
   1628              if ( inMsg.hdr.fc.manuSpecific )
   \   00013E   A1B20400     BIT.W   #0x4, 0x4(SP)
   \   000142   0328         JNC     ??zclProcessMessageMSG_12
   1629              {
   1630                // We don't support any manufacturer specific command
   1631                status = ZCL_STATUS_UNSUP_MANU_GENERAL_COMMAND;
   \   000144   7C408400     MOV.B   #0x84, R12
   \   000148   6D3C         JMP     ??zclProcessMessageMSG_13
   1632              }
   1633              else if ( ( inMsg.hdr.commandID <= ZCL_CMD_MAX ) &&
   1634                        ( zclCmdTable[inMsg.hdr.commandID].pfnParseInProfile != NULL ) )
   \                     ??zclProcessMessageMSG_12:
   \   00014A   5F410900     MOV.B   0x9(SP), R15
   \   00014E   7F900E00     CMP.B   #0xe, R15
   \   000152   492C         JC      ??zclProcessMessageMSG_14
   \   000154   5F0A         RLAM.W  #0x3, R15
   \   000156   174F....     MOV.W   zclCmdTable(R15), R7
   \   00015A   17DF....     BIS.W   zclCmdTable + 2(R15), R7
   \   00015E   0793         CMP.W   #0x0, R7
   \   000160   4224         JEQ     ??zclProcessMessageMSG_14
   1635              {
   1636                zclParseCmd_t parseCmd;
   1637          
   1638                parseCmd.endpoint = pkt->endPoint;
   \   000162   E1481000     MOV.B   @R8, 0x10(SP)
   1639                parseCmd.dataLen = inMsg.pDataLen;
   \   000166   91410C001200 MOV.W   0xc(SP), 0x12(SP)
   1640                parseCmd.pData = inMsg.pData;
   \   00016C   91410A001400 MOV.W   0xa(SP), 0x14(SP)
   1641          
   1642                // Parse the command, remember that the return value is a pointer to allocated memory
   1643                inMsg.attrCmd = zclParseCmd( inMsg.hdr.commandID, &parseCmd );
   \   000172   0C41         MOV.W   SP, R12
   \   000174   3C501000     ADD.W   #0x10, R12
   \   000178   5F410900     MOV.B   0x9(SP), R15
   \   00017C   5F0A         RLAM.W  #0x3, R15
   \   00017E   1E4F....     MOV.W   zclCmdTable(R15), R14
   \   000182   1F4F....     MOV.W   zclCmdTable + 2(R15), R15
   \   000186   ........     CALLA   #?IndCallR15
   \   00018A   814C0E00     MOV.W   R12, 0xe(SP)
   1644                if ( (inMsg.attrCmd != NULL) && (zclCmdTable[inMsg.hdr.commandID].pfnProcessInProfile != NULL) )
   \   00018E   0C93         CMP.W   #0x0, R12
   \   000190   1524         JEQ     ??zclProcessMessageMSG_15
   \   000192   5F410900     MOV.B   0x9(SP), R15
   \   000196   5F0A         RLAM.W  #0x3, R15
   \   000198   1E4F....     MOV.W   zclCmdTable + 4(R15), R14
   \   00019C   1F4F....     MOV.W   zclCmdTable + 6(R15), R15
   \   0001A0   074E         MOV.W   R14, R7
   \   0001A2   07DF         BIS.W   R15, R7
   \   0001A4   0793         CMP.W   #0x0, R7
   \   0001A6   0624         JEQ     ??zclProcessMessageMSG_16
   1645                {
   1646                  // Process the command
   1647                  if ( zclProcessCmd( inMsg.hdr.commandID, &inMsg ) == FALSE )
   \   0001A8   0C4B         MOV.W   R11, R12
   \   0001AA   ........     CALLA   #?IndCallR15
   1648                  {
   1649                    // Couldn't find attribute in the table.
   1650                  }
   1651                }
   1652          
   1653                // Free the buffer
   1654                if ( inMsg.attrCmd )
   \   0001AE   81930E00     CMP.W   #0x0, 0xe(SP)
   \   0001B2   0424         JEQ     ??zclProcessMessageMSG_15
   1655                {
   1656                  osal_mem_free( inMsg.attrCmd );
   \                     ??zclProcessMessageMSG_16:
   \   0001B4   1C410E00     MOV.W   0xe(SP), R12
   \   0001B8   ........     CALLA   #osal_mem_free
   1657                }
   1658          
   1659                if ( CMD_HAS_RSP( inMsg.hdr.commandID ) )
   \                     ??zclProcessMessageMSG_15:
   \   0001BC   5E410900     MOV.B   0x9(SP), R14
   \   0001C0   4E93         CMP.B   #0x0, R14
   \   0001C2   4A24         JEQ     ??zclProcessMessageMSG_1
   \   0001C4   6E93         CMP.B   #0x2, R14
   \   0001C6   4824         JEQ     ??zclProcessMessageMSG_1
   \   0001C8   4E96         CMP.B   R6, R14
   \   0001CA   4624         JEQ     ??zclProcessMessageMSG_1
   \   0001CC   7E900600     CMP.B   #0x6, R14
   \   0001D0   4324         JEQ     ??zclProcessMessageMSG_1
   \   0001D2   7E92         CMP.B   #0x8, R14
   \   0001D4   4124         JEQ     ??zclProcessMessageMSG_1
   \   0001D6   7E900C00     CMP.B   #0xc, R14
   \   0001DA   3E24         JEQ     ??zclProcessMessageMSG_1
   \   0001DC   7E900B00     CMP.B   #0xb, R14
   \   0001E0   3B24         JEQ     ??zclProcessMessageMSG_1
   1660                {
   1661                  return; // We're done
   1662                }
   1663          
   1664                status = ZSuccess;
   \   0001E2   4C43         MOV.B   #0x0, R12
   \   0001E4   1F3C         JMP     ??zclProcessMessageMSG_13
   1665              }
   1666              else
   1667              {
   1668                // Unsupported message
   1669                status = ZCL_STATUS_UNSUP_GENERAL_COMMAND;
   \                     ??zclProcessMessageMSG_14:
   \   0001E6   7C408200     MOV.B   #0x82, R12
   \   0001EA   1C3C         JMP     ??zclProcessMessageMSG_13
   1670              }
   1671            }
   1672            else  // Not a foundation type message, so it must be specific to the cluster ID.
   1673            {
   1674              if ( pInPlugin && pInPlugin->pfnIncomingHdlr )
   \                     ??zclProcessMessageMSG_11:
   \   0001EC   0E93         CMP.W   #0x0, R14
   \   0001EE   1424         JEQ     ??zclProcessMessageMSG_17
   \   0001F0   0F4E         MOV.W   R14, R15
   \   0001F2   1E4F0600     MOV.W   0x6(R15), R14
   \   0001F6   1F4F0800     MOV.W   0x8(R15), R15
   \   0001FA   074E         MOV.W   R14, R7
   \   0001FC   07DF         BIS.W   R15, R7
   \   0001FE   0793         CMP.W   #0x0, R7
   \   000200   0B24         JEQ     ??zclProcessMessageMSG_17
   1675              {
   1676                // The return value of the plugin function will be
   1677                //  ZSuccess - Supported and need default response
   1678                //  ZFailure - Unsupported
   1679                //  ZCL_STATUS_CMD_HAS_RSP - Supported and do not need default rsp
   1680                //  ZCL_STATUS_INVALID_FIELD - Supported, but the incoming msg is wrong formatted
   1681                //  ZCL_STATUS_INVALID_VALUE - Supported, but the request not achievable by the h/w
   1682                //  ZCL_STATUS_SOFTWARE_FAILURE - Supported but ZStack memory allocation fails
   1683                status = pInPlugin->pfnIncomingHdlr( &inMsg );
   \   000202   0C4B         MOV.W   R11, R12
   \   000204   ........     CALLA   #?IndCallR15
   1684                if ( status == ZCL_STATUS_CMD_HAS_RSP || ( interPanMsg && status == ZSuccess ) )
   \   000208   7C93         CMP.B   #0xff, R12
   \   00020A   2624         JEQ     ??zclProcessMessageMSG_1
   \   00020C   54B3         BIT.B   #0x1, R4
   \   00020E   0228         JNC     ??zclProcessMessageMSG_18
   \   000210   4C93         CMP.B   #0x0, R12
   \   000212   2224         JEQ     ??zclProcessMessageMSG_1
   1685                {
   1686                  return; // We're done
   1687                }
   1688              }
   1689          
   1690              if ( status == ZFailure )
   \                     ??zclProcessMessageMSG_18:
   \   000214   5C93         CMP.B   #0x1, R12
   \   000216   0620         JNE     ??zclProcessMessageMSG_13
   1691              {
   1692                // Unsupported message
   1693                if ( inMsg.hdr.fc.manuSpecific )
   \                     ??zclProcessMessageMSG_17:
   \   000218   A1B20400     BIT.W   #0x4, 0x4(SP)
   \   00021C   4C7C         SUBC.B  R12, R12
   \   00021E   4C5C         RLA.B   R12
   \   000220   7C508300     ADD.B   #0x83, R12
   1694                {
   1695                  status = ZCL_STATUS_UNSUP_MANU_CLUSTER_COMMAND;
   1696                }
   1697                else
   1698                {
   1699                  status = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
   1700                }
   1701              }
   1702            }
   1703          
   1704            if ( UNICAST_MSG( inMsg.msg ) && inMsg.hdr.fc.disableDefaultRsp == 0 )
   \                     ??zclProcessMessageMSG_13:
   \   000224   1F410200     MOV.W   0x2(SP), R15
   \   000228   CF931500     CMP.B   #0x0, 0x15(R15)
   \   00022C   1520         JNE     ??zclProcessMessageMSG_1
   \   00022E   8F930200     CMP.W   #0x0, 0x2(R15)
   \   000232   1220         JNE     ??zclProcessMessageMSG_1
   \   000234   B1B010000400 BIT.W   #0x10, 0x4(SP)
   \   00023A   0E2C         JC      ??zclProcessMessageMSG_1
   1705            {
   1706              // Send a Default Response command back
   1707              defautlRspCmd.statusCode = status;
   \   00023C   C14C0100     MOV.B   R12, 0x1(SP)
   1708              defautlRspCmd.commandID = inMsg.hdr.commandID;
   \   000240   D14109000000 MOV.B   0x9(SP), 0(SP)
   1709              zcl_SendDefaultRspCmd( inMsg.msg->endPoint, &(inMsg.msg->srcAddr),
   1710                                     inMsg.msg->clusterId, &defautlRspCmd,
   1711                                     ZCL_FRAME_SERVER_CLIENT_DIR, true,
   1712                                     inMsg.hdr.manuCode, inMsg.hdr.transSeqNum );
   \   000246   51120A00     PUSH.B  0xa(SP)
   \   00024A   11120A00     PUSH.W  0xa(SP)
   \   00024E   5312         PUSH.B  #0x1
   \   000250   5312         PUSH.B  #0x1
   \   000252   ........     CALLA   #?Subroutine10
   1713            }
   \                     ??CrossCallReturnLabel_4:
   \   000256   3152         ADD.W   #0x8, SP
   \                     ??zclProcessMessageMSG_1:
   \   000258   31501600     ADD.W   #0x16, SP
   \   00025C   7417         POPM.W  #0x8, R11
   \   00025E   1001         RETA
   1714          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine10:
   \   000000   0F41         MOV.W   SP, R15
   \   000002   3F500C00     ADD.W   #0xc, R15
   \   000006   1B410E00     MOV.W   0xe(SP), R11
   \   00000A   ........     CALLA   #?Subroutine53
   \                     ??CrossCallReturnLabel_58:
   \   00000E   ........     BRA     #zcl_SendDefaultRspCmd

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine53:
   \   000000   1E4B0400     MOV.W   0x4(R11), R14
   \   000004   0D4B         MOV.W   R11, R13
   \   000006   3D500600     ADD.W   #0x6, R13
   \   00000A   5C4B1400     MOV.B   0x14(R11), R12
   \   00000E   1001         RETA
   1715          
   1716          /*********************************************************************
   1717           * @fn      zclParseHdr
   1718           *
   1719           * @brief   Parse header of the ZCL format
   1720           *
   1721           * @param   hdr - place to put the frame control information
   1722           * @param   pData - incoming buffer to parse
   1723           *
   1724           * @return  pointer past the header
   1725           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine50_0:
   \   000000                RPT     #0x8
   \   000000   47180F5F     RLAX.W  R15
   \   000004   0E5F         ADD.W   R15, R14
   \   000006   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   1726          uint8 *zclParseHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclParseHdr:
   1727          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   1728            // Clear the header
   1729            osal_memset( (uint8 *)hdr, 0, sizeof ( zclFrameHdr_t ) );
   \   000006   3E400600     MOV.W   #0x6, R14
   \   00000A   4D43         MOV.B   #0x0, R13
   \   00000C   ........     CALLA   #osal_memset
   1730          
   1731            // Parse the Frame Control
   1732            hdr->fc.type = zcl_FCType( *pData );
   \   000010   6F4B         MOV.B   @R11, R15
   \   000012   3FF00300     AND.W   #0x3, R15
   \   000016   2E4A         MOV.W   @R10, R14
   \   000018   3EF0FCFF     AND.W   #0xfffc, R14
   \   00001C   0EDF         BIS.W   R15, R14
   \   00001E   8A4E0000     MOV.W   R14, 0(R10)
   1733            hdr->fc.manuSpecific = zcl_FCManuSpecific( *pData ) ? 1 : 0;
   \   000022   EBB20000     BIT.B   #0x4, 0(R11)
   \   000026   4E7E         SUBC.B  R14, R14
   \   000028   5E53         ADD.B   #0x1, R14
   \   00002A   5EB3         BIT.B   #0x1, R14
   \   00002C   032C         JC      ??zclParseHdr_0
   \   00002E   AAC20000     BIC.W   #0x4, 0(R10)
   \   000032   023C         JMP     ??zclParseHdr_1
   \                     ??zclParseHdr_0:
   \   000034   AAD20000     BIS.W   #0x4, 0(R10)
   1734            if ( zcl_FCDirection( *pData ) )
   \                     ??zclParseHdr_1:
   \   000038   FBB20000     BIT.B   #0x8, 0(R11)
   \   00003C   0328         JNC     ??zclParseHdr_2
   1735            {
   1736              hdr->fc.direction = ZCL_FRAME_SERVER_CLIENT_DIR;
   \   00003E   BAD20000     BIS.W   #0x8, 0(R10)
   \   000042   023C         JMP     ??zclParseHdr_3
   1737            }
   1738            else
   1739            {
   1740              hdr->fc.direction = ZCL_FRAME_CLIENT_SERVER_DIR;
   \                     ??zclParseHdr_2:
   \   000044   BAC20000     BIC.W   #0x8, 0(R10)
   1741            }
   1742          
   1743            hdr->fc.disableDefaultRsp = zcl_FCDisableDefaultRsp( *pData ) ? 1 : 0;
   \                     ??zclParseHdr_3:
   \   000048   FBB010000000 BIT.B   #0x10, 0(R11)
   \   00004E   4E7E         SUBC.B  R14, R14
   \   000050   5E53         ADD.B   #0x1, R14
   \   000052   5EB3         BIT.B   #0x1, R14
   \   000054   042C         JC      ??zclParseHdr_4
   \   000056   BAC010000000 BIC.W   #0x10, 0(R10)
   \   00005C   033C         JMP     ??zclParseHdr_5
   \                     ??zclParseHdr_4:
   \   00005E   BAD010000000 BIS.W   #0x10, 0(R10)
   1744            pData++;  // move past the frame control field
   \                     ??zclParseHdr_5:
   \   000064   1B53         ADD.W   #0x1, R11
   1745          
   1746            // parse the manfacturer code
   1747            if ( hdr->fc.manuSpecific )
   \   000066   AAB20000     BIT.W   #0x4, 0(R10)
   \   00006A   0828         JNC     ??zclParseHdr_6
   1748            {
   1749              hdr->manuCode = BUILD_UINT16( pData[0], pData[1] );
   \   00006C   6E4B         MOV.B   @R11, R14
   \   00006E   5F4B0100     MOV.B   0x1(R11), R15
   \   000072   ........     CALLA   #??Subroutine50_0
   \                     ??CrossCallReturnLabel_100:
   \   000076   8A4E0200     MOV.W   R14, 0x2(R10)
   1750              pData += 2;
   \   00007A   2B53         ADD.W   #0x2, R11
   1751            }
   1752          
   1753            // parse the Transaction Sequence Number
   1754            hdr->transSeqNum = *pData++;
   \                     ??zclParseHdr_6:
   \   00007C   FA4B0400     MOV.B   @R11+, 0x4(R10)
   1755          
   1756            // parse the Cluster's command ID
   1757            hdr->commandID = *pData++;
   \   000080   FA4B0500     MOV.B   @R11+, 0x5(R10)
   1758          
   1759            // Should point to the frame payload
   1760            return ( pData );
   \   000084   0C4B         MOV.W   R11, R12
   \   000086   1A17         POPM.W  #0x2, R11
   \   000088   1001         RETA
   1761          }
   1762          
   1763          /*********************************************************************
   1764           * @fn      zclBuildHdr
   1765           *
   1766           * @brief   Build header of the ZCL format
   1767           *
   1768           * @param   hdr - outgoing header information
   1769           * @param   pData - outgoing header space
   1770           *
   1771           * @return  pointer past the header
   1772           */

   \                                 In  segment CODE, align 2
   1773          static uint8 *zclBuildHdr( zclFrameHdr_t *hdr, uint8 *pData )
   \                     zclBuildHdr:
   1774          {
   1775            // Build the Frame Control byte
   1776            *pData = hdr->fc.type;
   \   000000   6E4C         MOV.B   @R12, R14
   \   000002   7EF00300     AND.B   #0x3, R14
   \   000006   CD4E0000     MOV.B   R14, 0(R13)
   1777            *pData |= hdr->fc.manuSpecific << 2;
   \   00000A   6E4C         MOV.B   @R12, R14
   \   00000C   6EF2         AND.B   #0x4, R14
   \   00000E   CDDE0000     BIS.B   R14, 0(R13)
   1778            *pData |= hdr->fc.direction << 3;
   \   000012   6E4C         MOV.B   @R12, R14
   \   000014   7EF2         AND.B   #0x8, R14
   \   000016   CDDE0000     BIS.B   R14, 0(R13)
   1779            *pData |= hdr->fc.disableDefaultRsp << 4;
   \   00001A   6E4C         MOV.B   @R12, R14
   \   00001C   7EF01000     AND.B   #0x10, R14
   \   000020   CDDE0000     BIS.B   R14, 0(R13)
   1780            pData++;  // move past the frame control field
   \   000024   1D53         ADD.W   #0x1, R13
   1781          
   1782            // Add the manfacturer code
   1783            if ( hdr->fc.manuSpecific )
   \   000026   ACB20000     BIT.W   #0x4, 0(R12)
   \   00002A   0828         JNC     ??zclBuildHdr_0
   1784            {
   1785              *pData++ = LO_UINT16( hdr->manuCode );
   \   00002C   DD4C02000000 MOV.B   0x2(R12), 0(R13)
   \   000032   1D53         ADD.W   #0x1, R13
   1786              *pData++ = HI_UINT16( hdr->manuCode );
   \   000034   DD4C03000000 MOV.B   0x3(R12), 0(R13)
   \   00003A   1D53         ADD.W   #0x1, R13
   1787            }
   1788          
   1789            // Add the Transaction Sequence Number
   1790            *pData++ = hdr->transSeqNum;
   \                     ??zclBuildHdr_0:
   \   00003C   DD4C04000000 MOV.B   0x4(R12), 0(R13)
   \   000042   1D53         ADD.W   #0x1, R13
   1791          
   1792            // Add the Cluster's command ID
   1793            *pData++ = hdr->commandID;
   \   000044   DD4C05000000 MOV.B   0x5(R12), 0(R13)
   \   00004A   1D53         ADD.W   #0x1, R13
   1794          
   1795            // Should point to the frame payload
   1796            return ( pData );
   \   00004C   0C4D         MOV.W   R13, R12
   \   00004E   1001         RETA
   1797          }
   1798          
   1799          /*********************************************************************
   1800           * @fn      zclCalcHdrSize
   1801           *
   1802           * @brief   Calculate the number of bytes needed for an outgoing
   1803           *          ZCL header.
   1804           *
   1805           * @param   hdr - outgoing header information
   1806           *
   1807           * @return  returns the number of bytes needed
   1808           */
   1809          static uint8 zclCalcHdrSize( zclFrameHdr_t *hdr )
   1810          {
   1811            uint8 needed = (1 + 1 + 1); // frame control + transaction seq num + cmd ID
   1812          
   1813            // Add the manfacturer code
   1814            if ( hdr->fc.manuSpecific )
   1815            {
   1816              needed += 2;
   1817            }
   1818          
   1819            return ( needed );
   1820          }
   1821          
   1822          /*********************************************************************
   1823           * @fn      zclFindPlugin
   1824           *
   1825           * @brief   Find the right plugin for a cluster ID
   1826           *
   1827           * @param   clusterID - cluster ID to look for
   1828           * @param   profileID - profile ID
   1829           *
   1830           * @return  pointer to plugin, NULL if not found
   1831           */
   1832          static zclLibPlugin_t *zclFindPlugin( uint16 clusterID, uint16 profileID )
   1833          {
   1834            (void)profileID;  // Intentionally unreferenced parameter
   1835          
   1836            zclLibPlugin_t *pLoop = plugins;
   1837          
   1838            while ( pLoop != NULL )
   1839            {
   1840              if ( ( clusterID >= pLoop->startClusterID ) && ( clusterID <= pLoop->endClusterID ) )
   1841              {
   1842                return ( pLoop );
   1843              }
   1844          
   1845              pLoop = pLoop->next;
   1846            }
   1847          
   1848            return ( (zclLibPlugin_t *)NULL );
   1849          }
   1850          
   1851          /*********************************************************************
   1852           * @fn      zclFindAttrRecsList
   1853           *
   1854           * @brief   Find the right attribute record list for an endpoint
   1855           *
   1856           * @param   clusterID - endpointto look for
   1857           *
   1858           * @return  pointer to record list, NULL if not found
   1859           */

   \                                 In  segment CODE, align 2
   1860          static zclAttrRecsList *zclFindAttrRecsList( uint8 endpoint )
   \                     zclFindAttrRecsList:
   1861          {
   1862            zclAttrRecsList *pLoop = attrList;
   \   000000   1F42....     MOV.W   &attrList, R15
   \   000004   013C         JMP     ??zclFindAttrRecsList_1
   1863          
   1864            while ( pLoop != NULL )
   1865            {
   1866              if ( pLoop->endpoint == endpoint )
   1867              {
   1868                return ( pLoop );
   1869              }
   1870          
   1871              pLoop = pLoop->next;
   \                     ??zclFindAttrRecsList_0:
   \   000006   2F4F         MOV.W   @R15, R15
   \                     ??zclFindAttrRecsList_1:
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   0524         JEQ     ??zclFindAttrRecsList_2
   \   00000C   CF9C0200     CMP.B   R12, 0x2(R15)
   \   000010   FA23         JNE     ??zclFindAttrRecsList_0
   \   000012   0C4F         MOV.W   R15, R12
   \   000014   1001         RETA
   1872            }
   1873          
   1874            return ( NULL );
   \                     ??zclFindAttrRecsList_2:
   \   000016   0C43         MOV.W   #0x0, R12
   \   000018   1001         RETA
   1875          }
   1876          
   1877          /*********************************************************************
   1878           * @fn      zclFindAttrRec
   1879           *
   1880           * @brief   Find the attribute record that matchs the parameters
   1881           *
   1882           * @param   endpoint - Application's endpoint
   1883           * @param   clusterID - cluster ID
   1884           * @param   attrId - attribute looking for
   1885           * @param   pAttr - attribute record to be returned
   1886           *
   1887           * @return  TRUE if record found. FALSE, otherwise.
   1888           */

   \                                 In  segment CODE, align 2
   1889          uint8 zclFindAttrRec( uint8 endpoint, uint16 clusterID, uint16 attrId, zclAttrRec_t *pAttr )
   \                     zclFindAttrRec:
   1890          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4F         MOV.W   R15, R10
   1891            uint8 x;
   1892            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000004   ........     CALLA   #zclFindAttrRecsList
   1893          
   1894            if ( pRec != NULL )
   \   000008   0C93         CMP.W   #0x0, R12
   \   00000A   1B24         JEQ     ??zclFindAttrRec_1
   1895            {
   1896              for ( x = 0; x < pRec->numAttributes; x++ )
   \   00000C   4F43         MOV.B   #0x0, R15
   \   00000E   013C         JMP     ??zclFindAttrRec_2
   \                     ??zclFindAttrRec_0:
   \   000010   5F53         ADD.B   #0x1, R15
   \                     ??zclFindAttrRec_2:
   \   000012   5F9C0C00     CMP.B   0xc(R12), R15
   \   000016   152C         JC      ??zclFindAttrRec_1
   1897              {
   1898                if ( pRec->attrs[x].clusterID == clusterID && pRec->attrs[x].attr.attrId == attrId )
   \   000018   1B4C0E00     MOV.W   0xe(R12), R11
   \   00001C   484F         MOV.B   R15, R8
   \   00001E   580A         RLAM.W  #0x3, R8
   \   000020   0B58         ADD.W   R8, R11
   \   000022   8B9D0000     CMP.W   R13, 0(R11)
   \   000026   F423         JNE     ??zclFindAttrRec_0
   \   000028   8B9E0200     CMP.W   R14, 0x2(R11)
   \   00002C   F123         JNE     ??zclFindAttrRec_0
   1899                {
   1900                  *pAttr = pRec->attrs[x];
   \   00002E   BA4B0000     MOV.W   @R11+, 0(R10)
   \   000032   BA4B0200     MOV.W   @R11+, 0x2(R10)
   \   000036   BA4B0400     MOV.W   @R11+, 0x4(R10)
   \   00003A   BA4B0600     MOV.W   @R11+, 0x6(R10)
   1901          
   1902                  return ( TRUE ); // EMBEDDED RETURN
   \   00003E   5C43         MOV.B   #0x1, R12
   \   000040   013C         JMP     ??zclFindAttrRec_3
   1903                }
   1904              }
   1905            }
   1906          
   1907            return ( FALSE );
   \                     ??zclFindAttrRec_1:
   \   000042   4C43         MOV.B   #0x0, R12
   \                     ??zclFindAttrRec_3:
   \   000044   3817         POPM.W  #0x4, R11
   \   000046   1001         RETA
   1908          }
   1909          
   1910          #if defined ( ZCL_READ ) || defined ( ZCL_WRITE )
   1911          /*********************************************************************
   1912           * @fn      zclGetReadWriteCB
   1913           *
   1914           * @brief   Get the Read/Write callback function pointer for a given endpoint.
   1915           *
   1916           * @param   endpoint - Application's endpoint
   1917           *
   1918           * @return  Read/Write CB, NULL if not found
   1919           */

   \                                 In  segment CODE, align 2, keep-with-next
   1920          static zclReadWriteCB_t zclGetReadWriteCB( uint8 endpoint )
   \                     zclGetReadWriteCB:
   1921          {
   1922            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000000   ........     CALLA   #zclFindAttrRecsList
   1923          
   1924            if ( pRec != NULL )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0624         JEQ     ??zclGetReadWriteCB_0
   1925            {
   1926              return ( pRec->pfnReadWriteCB );
   \   000008   0D4C         MOV.W   R12, R13
   \   00000A   1C4D0400     MOV.W   0x4(R13), R12
   \   00000E   1D4D0600     MOV.W   0x6(R13), R13
   \   000012   1001         RETA
   1927            }
   1928          
   1929            return ( NULL );
   \                     ??zclGetReadWriteCB_0:
   \   000014                REQUIRE ?Subroutine2
   \   000014                // Fall through to label ?Subroutine2
   1930          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   0C43         MOV.W   #0x0, R12
   \   000002   0D43         MOV.W   #0x0, R13
   \   000004   1001         RETA
   1931          
   1932          /*********************************************************************
   1933           * @fn      zclGetAuthorizeCB
   1934           *
   1935           * @brief   Get the Read/Write Authorization callback function pointer
   1936           *          for a given endpoint.
   1937           *
   1938           * @param   endpoint - Application's endpoint
   1939           *
   1940           * @return  Authorization CB, NULL if not found
   1941           */

   \                                 In  segment CODE, align 2, keep-with-next
   1942          static zclAuthorizeCB_t zclGetAuthorizeCB( uint8 endpoint )
   \                     zclGetAuthorizeCB:
   1943          {
   1944            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   \   000000   ........     CALLA   #zclFindAttrRecsList
   1945          
   1946            if ( pRec != NULL )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0624         JEQ     ??zclGetAuthorizeCB_0
   1947            {
   1948              return ( pRec->pfnAuthorizeCB );
   \   000008   0D4C         MOV.W   R12, R13
   \   00000A   1C4D0800     MOV.W   0x8(R13), R12
   \   00000E   1D4D0A00     MOV.W   0xa(R13), R13
   \   000012   1001         RETA
   1949            }
   1950          
   1951            return ( NULL );
   \                     ??zclGetAuthorizeCB_0:
   \   000014   ....         JMP     ?Subroutine2
   \   000016   0343         NOP
   1952          }
   1953          #endif // ZCL_READ || ZCL_WRITE
   1954          
   1955          /*********************************************************************
   1956           * @fn      zclFindClusterOption
   1957           *
   1958           * @brief   Find the option record that matchs the cluster id
   1959           *
   1960           * @param   endpoint - Application's endpoint
   1961           * @param   clusterID - cluster ID looking for
   1962           *
   1963           * @return  pointer to clutser option, NULL if not found
   1964           */

   \                                 In  segment CODE, align 2
   1965          static zclOptionRec_t *zclFindClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclFindClusterOption:
   1966          {
   \   000000   1B15         PUSHM.W #0x2, R11
   1967            zclClusterOptionList *pLoop;
   1968          
   1969            pLoop = clusterOptionList;
   \   000002   1A42....     MOV.W   &clusterOptionList, R10
   \   000006   013C         JMP     ??zclFindClusterOption_2
   1970            while ( pLoop != NULL )
   1971            {
   1972              if ( pLoop->endpoint == endpoint )
   1973              {
   1974                for ( uint8 x = 0; x < pLoop->numOptions; x++ )
   1975                {
   1976                  if ( pLoop->options[x].clusterID == clusterID )
   1977                  {
   1978                    return ( &(pLoop->options[x]) ); // EMBEDDED RETURN
   1979                  }
   1980                }
   1981              }
   1982          
   1983              pLoop = pLoop->next;
   \                     ??zclFindClusterOption_0:
   \   000008   2A4A         MOV.W   @R10, R10
   \                     ??zclFindClusterOption_2:
   \   00000A   0A93         CMP.W   #0x0, R10
   \   00000C   1324         JEQ     ??zclFindClusterOption_3
   \   00000E   CA9C0200     CMP.B   R12, 0x2(R10)
   \   000012   FA23         JNE     ??zclFindClusterOption_0
   \   000014   4E43         MOV.B   #0x0, R14
   \   000016   013C         JMP     ??zclFindClusterOption_4
   \                     ??zclFindClusterOption_1:
   \   000018   5E53         ADD.B   #0x1, R14
   \                     ??zclFindClusterOption_4:
   \   00001A   5E9A0300     CMP.B   0x3(R10), R14
   \   00001E   F42F         JC      ??zclFindClusterOption_0
   \   000020   1F4A0400     MOV.W   0x4(R10), R15
   \   000024   4B4E         MOV.B   R14, R11
   \   000026   5B06         RLAM.W  #0x2, R11
   \   000028   0F5B         ADD.W   R11, R15
   \   00002A   8F9D0000     CMP.W   R13, 0(R15)
   \   00002E   F423         JNE     ??zclFindClusterOption_1
   \   000030   0C4F         MOV.W   R15, R12
   \   000032   013C         JMP     ??zclFindClusterOption_5
   1984            }
   1985          
   1986            return ( NULL );
   \                     ??zclFindClusterOption_3:
   \   000034   0C43         MOV.W   #0x0, R12
   \                     ??zclFindClusterOption_5:
   \   000036   1A17         POPM.W  #0x2, R11
   \   000038   1001         RETA
   1987          }
   1988          
   1989          /*********************************************************************
   1990           * @fn      zclGetClusterOption
   1991           *
   1992           * @brief   Get the option record that matchs the cluster id
   1993           *
   1994           * @param   endpoint - Application's endpoint
   1995           * @param   clusterID - cluster ID looking for
   1996           *
   1997           * @return  clutser option, AF_TX_OPTIONS_NONE if not found
   1998           */

   \                                 In  segment CODE, align 2
   1999          static uint8 zclGetClusterOption( uint8 endpoint, uint16 clusterID )
   \                     zclGetClusterOption:
   2000          {
   2001            uint8 option;
   2002            zclOptionRec_t *pOption;
   2003          
   2004            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000000   ........     CALLA   #zclFindClusterOption
   2005            if ( pOption != NULL )
   \   000004   0C93         CMP.W   #0x0, R12
   \   000006   0524         JEQ     ??zclGetClusterOption_0
   2006            {
   2007              option = pOption->option;
   2008              if ( !ZG_SECURE_ENABLED )
   2009              {
   2010                option &= (AF_EN_SECURITY ^ 0xFF); // make sure Application Link Key security is off
   2011              }
   2012          
   2013              return ( option ); // EMBEDDED RETURN
   \   000008   5C4C0200     MOV.B   0x2(R12), R12
   \   00000C   7CF0BF00     AND.B   #0xbf, R12
   \   000010   1001         RETA
   2014            }
   2015          
   2016            return ( AF_TX_OPTIONS_NONE );
   \                     ??zclGetClusterOption_0:
   \   000012   4C43         MOV.B   #0x0, R12
   \   000014   1001         RETA
   2017          }
   2018          
   2019          /*********************************************************************
   2020           * @fn      zclSetSecurityOption
   2021           *
   2022           * @brief   Set the security option for the cluster id
   2023           *
   2024           * @param   endpoint - Application's endpoint
   2025           * @param   clusterID - cluster ID looking for
   2026           * @param   enable - whether to enable (TRUE) or disable (FALSE) security option
   2027           *
   2028           * @return  none
   2029           */

   \                                 In  segment CODE, align 2, keep-with-next
   2030          static void zclSetSecurityOption( uint8 endpoint, uint16 clusterID, uint8 enable )
   \                     zclSetSecurityOption:
   2031          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4E         MOV.B   R14, R10
   2032            zclOptionRec_t *pOption;
   2033          
   2034            pOption = zclFindClusterOption( endpoint, clusterID );
   \   000004   ........     CALLA   #zclFindClusterOption
   2035            if ( pOption != NULL )
   \   000008   5E4C0200     MOV.B   0x2(R12), R14
   \   00000C   0C93         CMP.W   #0x0, R12
   \   00000E   0724         JEQ     ??zclSetSecurityOption_0
   2036            {
   2037              if ( enable )
   \   000010   4A93         CMP.B   #0x0, R10
   \   000012   0324         JEQ     ??zclSetSecurityOption_1
   2038              {
   2039                pOption->option |= AF_EN_SECURITY;
   \   000014   7ED04000     BIS.B   #0x40, R14
   \   000018   023C         JMP     ??zclSetSecurityOption_0
   2040              }
   2041              else
   2042              {
   2043                pOption->option &= (AF_EN_SECURITY ^ 0xFF);
   \                     ??zclSetSecurityOption_1:
   \   00001A   7EC04000     BIC.B   #0x40, R14
   \                     ??zclSetSecurityOption_0:
   \   00001E   CC4E0200     MOV.B   R14, 0x2(R12)
   2044              }
   2045            }
   2046          }
   \   000022   3A41         POP.W   R10
   \   000024   1001         RETA
   2047          
   2048          #ifdef ZCL_DISCOVER
   2049          /*********************************************************************
   2050           * @fn      zclFindNextAttrRec
   2051           *
   2052           * @brief   Find the attribute (or next) record that matchs the parameters
   2053           *
   2054           * @param   endpoint - Application's endpoint
   2055           * @param   clusterID - cluster ID
   2056           * @param   attr - attribute looking for
   2057           *
   2058           * @return  pointer to attribute record, NULL if not found
   2059           */
   2060          static uint8 zclFindNextAttrRec( uint8 endpoint, uint16 clusterID,
   2061                                           uint16 *attrId, zclAttrRec_t *pAttr )
   2062          {
   2063            zclAttrRecsList *pRec = zclFindAttrRecsList( endpoint );
   2064          
   2065            if ( pRec != NULL )
   2066            {
   2067              for ( uint16 x = 0; x < pRec->numAttributes; x++ )
   2068              {
   2069                if ( ( pRec->attrs[x].clusterID == clusterID ) && 
   2070                     ( pRec->attrs[x].attr.attrId >= *attrId ) )
   2071                {
   2072                  *pAttr = pRec->attrs[x];
   2073          
   2074                  // Update attribute ID
   2075                  *attrId = pAttr->attr.attrId;
   2076          
   2077                  return ( TRUE ); // EMBEDDED RETURN
   2078                }
   2079              }
   2080            }
   2081          
   2082            return ( FALSE );
   2083          }
   2084          #endif // ZCL_DISCOVER
   2085          
   2086          /*********************************************************************
   2087           * @fn      zclSerializeData
   2088           *
   2089           * @brief   Builds a buffer from the attribute data to sent out over
   2090           *          the air.
   2091           *
   2092           * @param   dataType - data types defined in zcl.h
   2093           * @param   attrData - pointer to the attribute data
   2094           * @param   buf - where to put the serialized data
   2095           *
   2096           * @return  pointer to end of destination buffer
   2097           */

   \                                 In  segment CODE, align 2, keep-with-next
   2098          uint8 *zclSerializeData( uint8 dataType, void *attrData, uint8 *buf )
   \                     zclSerializeData:
   2099          {
   \   000000   4F4C         MOV.B   R12, R15
   \   000002   0C4E         MOV.W   R14, R12
   2100            uint8 *pStr;
   2101            uint16 len;
   2102          
   2103            switch ( dataType )
   \   000004   7F82         SUB.B   #0x8, R15
   \   000006   4B24         JEQ     ??zclSerializeData_0
   \   000008   5F83         SUB.B   #0x1, R15
   \   00000A   4D24         JEQ     ??zclSerializeData_1
   \   00000C   5F83         SUB.B   #0x1, R15
   \   00000E   4D24         JEQ     ??zclSerializeData_2
   \   000010   5F83         SUB.B   #0x1, R15
   \   000012   5324         JEQ     ??zclSerializeData_3
   \   000014   7F800500     SUB.B   #0x5, R15
   \   000018   4224         JEQ     ??zclSerializeData_0
   \   00001A   7F82         SUB.B   #0x8, R15
   \   00001C   4024         JEQ     ??zclSerializeData_0
   \   00001E   5F83         SUB.B   #0x1, R15
   \   000020   4224         JEQ     ??zclSerializeData_1
   \   000022   5F83         SUB.B   #0x1, R15
   \   000024   4224         JEQ     ??zclSerializeData_2
   \   000026   5F83         SUB.B   #0x1, R15
   \   000028   4824         JEQ     ??zclSerializeData_3
   \   00002A   7F800500     SUB.B   #0x5, R15
   \   00002E   3724         JEQ     ??zclSerializeData_0
   \   000030   5F83         SUB.B   #0x1, R15
   \   000032   3924         JEQ     ??zclSerializeData_1
   \   000034   5F83         SUB.B   #0x1, R15
   \   000036   3924         JEQ     ??zclSerializeData_2
   \   000038   5F83         SUB.B   #0x1, R15
   \   00003A   3F24         JEQ     ??zclSerializeData_3
   \   00003C   5F83         SUB.B   #0x1, R15
   \   00003E   4124         JEQ     ??zclSerializeData_4
   \   000040   5F83         SUB.B   #0x1, R15
   \   000042   4324         JEQ     ??zclSerializeData_5
   \   000044   7F800300     SUB.B   #0x3, R15
   \   000048   2A24         JEQ     ??zclSerializeData_0
   \   00004A   5F83         SUB.B   #0x1, R15
   \   00004C   2C24         JEQ     ??zclSerializeData_1
   \   00004E   5F83         SUB.B   #0x1, R15
   \   000050   2C24         JEQ     ??zclSerializeData_2
   \   000052   5F83         SUB.B   #0x1, R15
   \   000054   3224         JEQ     ??zclSerializeData_3
   \   000056   7F800500     SUB.B   #0x5, R15
   \   00005A   2124         JEQ     ??zclSerializeData_0
   \   00005C   5F83         SUB.B   #0x1, R15
   \   00005E   2324         JEQ     ??zclSerializeData_1
   \   000060   7F800700     SUB.B   #0x7, R15
   \   000064   2024         JEQ     ??zclSerializeData_1
   \   000066   5F83         SUB.B   #0x1, R15
   \   000068   2824         JEQ     ??zclSerializeData_3
   \   00006A   7F82         SUB.B   #0x8, R15
   \   00006C   3524         JEQ     ??zclSerializeData_6
   \   00006E   5F83         SUB.B   #0x1, R15
   \   000070   3324         JEQ     ??zclSerializeData_6
   \   000072   5F83         SUB.B   #0x1, R15
   \   000074   3524         JEQ     ??zclSerializeData_7
   \   000076   5F83         SUB.B   #0x1, R15
   \   000078   3324         JEQ     ??zclSerializeData_7
   \   00007A   7F809C00     SUB.B   #0x9c, R15
   \   00007E   1D24         JEQ     ??zclSerializeData_3
   \   000080   5F83         SUB.B   #0x1, R15
   \   000082   1B24         JEQ     ??zclSerializeData_3
   \   000084   5F83         SUB.B   #0x1, R15
   \   000086   1924         JEQ     ??zclSerializeData_3
   \   000088   7F800600     SUB.B   #0x6, R15
   \   00008C   0C24         JEQ     ??zclSerializeData_1
   \   00008E   5F83         SUB.B   #0x1, R15
   \   000090   0A24         JEQ     ??zclSerializeData_1
   \   000092   5F83         SUB.B   #0x1, R15
   \   000094   1224         JEQ     ??zclSerializeData_3
   \   000096   7F800600     SUB.B   #0x6, R15
   \   00009A   1B24         JEQ     ??zclSerializeData_8
   \   00009C   1001         RETA
   2104            {
   2105              case ZCL_DATATYPE_DATA8:
   2106              case ZCL_DATATYPE_BOOLEAN:
   2107              case ZCL_DATATYPE_BITMAP8:
   2108              case ZCL_DATATYPE_INT8:
   2109              case ZCL_DATATYPE_UINT8:
   2110              case ZCL_DATATYPE_ENUM8:
   2111                *buf++ = *((uint8 *)attrData);
   \                     ??zclSerializeData_0:
   \   00009E   EE4D0000     MOV.B   @R13, 0(R14)
   \   0000A2   1C53         ADD.W   #0x1, R12
   2112                 break;
   \   0000A4   1001         RETA
   2113          
   2114              case ZCL_DATATYPE_DATA16:
   2115              case ZCL_DATATYPE_BITMAP16:
   2116              case ZCL_DATATYPE_UINT16:
   2117              case ZCL_DATATYPE_INT16:
   2118              case ZCL_DATATYPE_ENUM16:
   2119              case ZCL_DATATYPE_SEMI_PREC:
   2120              case ZCL_DATATYPE_CLUSTER_ID:
   2121              case ZCL_DATATYPE_ATTR_ID:
   2122                *buf++ = LO_UINT16( *((uint16*)attrData) );
   \                     ??zclSerializeData_1:
   \   0000A6   ........     BRA     #?Subroutine41
   2123                *buf++ = HI_UINT16( *((uint16*)attrData) );
   2124                break;
   2125          
   2126              case ZCL_DATATYPE_DATA24:
   2127              case ZCL_DATATYPE_BITMAP24:
   2128              case ZCL_DATATYPE_UINT24:
   2129              case ZCL_DATATYPE_INT24:
   2130                *buf++ = BREAK_UINT32( *((uint32*)attrData), 0 );
   \                     ??zclSerializeData_2:
   \   0000AA   ........     CALLA   #?Subroutine41
   2131                *buf++ = BREAK_UINT32( *((uint32*)attrData), 1 );
   2132                *buf++ = BREAK_UINT32( *((uint32*)attrData), 2 );
   \                     ??CrossCallReturnLabel_42:
   \   0000AE   3E4D         MOV.W   @R13+, R14
   \   0000B0   3F4D         MOV.W   @R13+, R15
   \   0000B2   CC4F0000     MOV.B   R15, 0(R12)
   \   0000B6   1C53         ADD.W   #0x1, R12
   2133                break;
   \   0000B8   1001         RETA
   2134          
   2135              case ZCL_DATATYPE_DATA32:
   2136              case ZCL_DATATYPE_BITMAP32:
   2137              case ZCL_DATATYPE_UINT32:
   2138              case ZCL_DATATYPE_INT32:
   2139              case ZCL_DATATYPE_SINGLE_PREC:
   2140              case ZCL_DATATYPE_TOD:
   2141              case ZCL_DATATYPE_DATE:
   2142              case ZCL_DATATYPE_UTC:
   2143              case ZCL_DATATYPE_BAC_OID:
   2144                buf = osal_buffer_uint32( buf, *((uint32*)attrData) );
   \                     ??zclSerializeData_3:
   \   0000BA   3E4D         MOV.W   @R13+, R14
   \   0000BC   3F4D         MOV.W   @R13+, R15
   \   0000BE   ........     BRA     #osal_buffer_uint32
   2145                break;
   2146          
   2147              case ZCL_DATATYPE_UINT40:
   2148                pStr = (uint8*)attrData;
   2149                buf = osal_memcpy( buf, pStr, 5 );
   \                     ??zclSerializeData_4:
   \   0000C2   3E400500     MOV.W   #0x5, R14
   \   0000C6   ........     BRA     #osal_memcpy
   2150                break;
   2151          
   2152              case ZCL_DATATYPE_UINT48:
   2153                pStr = (uint8*)attrData;
   2154                buf = osal_memcpy( buf, pStr, 6 );
   \                     ??zclSerializeData_5:
   \   0000CA   3E400600     MOV.W   #0x6, R14
   \   0000CE   ........     BRA     #osal_memcpy
   2155                break;
   2156          
   2157              case ZCL_DATATYPE_IEEE_ADDR:
   2158                pStr = (uint8*)attrData;
   2159                buf = osal_memcpy( buf, pStr, 8 );
   \                     ??zclSerializeData_8:
   \   0000D2   3E42         MOV.W   #0x8, R14
   \   0000D4   ........     BRA     #osal_memcpy
   2160                break;
   2161          
   2162              case ZCL_DATATYPE_CHAR_STR:
   2163              case ZCL_DATATYPE_OCTET_STR:
   2164                pStr = (uint8*)attrData;
   2165                len = *pStr;
   2166                buf = osal_memcpy( buf, pStr, len+1 ); // Including length field
   \                     ??zclSerializeData_6:
   \   0000D8   6E4D         MOV.B   @R13, R14
   \   0000DA   1E53         ADD.W   #0x1, R14
   \   0000DC   ........     BRA     #osal_memcpy
   2167                break;
   2168          
   2169              case ZCL_DATATYPE_LONG_CHAR_STR:
   2170              case ZCL_DATATYPE_LONG_OCTET_STR:
   2171                pStr = (uint8*)attrData;
   2172                len = BUILD_UINT16( pStr[0], pStr[1] );
   2173                buf = osal_memcpy( buf, pStr, len+2 ); // Including length field
   \                     ??zclSerializeData_7:
   \   0000E0   6E4D         MOV.B   @R13, R14
   \   0000E2   5F4D0100     MOV.B   0x1(R13), R15
   \   0000E6   ........     CALLA   #??Subroutine50_0
   2174                break;
   2175          
   2176              case ZCL_DATATYPE_NO_DATA:
   2177              case ZCL_DATATYPE_UNKNOWN:
   2178                // Fall through
   2179          
   2180              default:
   2181                break;
   2182            }
   \                     ??CrossCallReturnLabel_98:
   \   0000EA   2E53         ADD.W   #0x2, R14
   \   0000EC   ........     BRA     #osal_memcpy
   2183          
   2184            return ( buf );
   2185          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine41:
   \   000000   EE4D0000     MOV.B   @R13, 0(R14)
   \   000004   1C53         ADD.W   #0x1, R12
   \   000006   DC4D01000000 MOV.B   0x1(R13), 0(R12)
   \   00000C   1C53         ADD.W   #0x1, R12
   \   00000E   1001         RETA
   2186          
   2187          #ifdef ZCL_REPORT
   2188          /*********************************************************************
   2189           * @fn      zclAnalogDataType
   2190           *
   2191           * @brief   Checks to see if Data Type is Analog
   2192           *
   2193           * @param   dataType - data type
   2194           *
   2195           * @return  TRUE if data type is analog
   2196           */

   \                                 In  segment CODE, align 2, keep-with-next
   2197          uint8 zclAnalogDataType( uint8 dataType )
   \                     zclAnalogDataType:
   2198          {
   2199            uint8 analog;
   2200          
   2201            switch ( dataType )
   \   000000   7C802000     SUB.B   #0x20, R12
   \   000004   2C24         JEQ     ??zclAnalogDataType_0
   \   000006   5C83         SUB.B   #0x1, R12
   \   000008   2A24         JEQ     ??zclAnalogDataType_0
   \   00000A   5C83         SUB.B   #0x1, R12
   \   00000C   2824         JEQ     ??zclAnalogDataType_0
   \   00000E   5C83         SUB.B   #0x1, R12
   \   000010   2624         JEQ     ??zclAnalogDataType_0
   \   000012   5C83         SUB.B   #0x1, R12
   \   000014   2424         JEQ     ??zclAnalogDataType_0
   \   000016   5C83         SUB.B   #0x1, R12
   \   000018   2224         JEQ     ??zclAnalogDataType_0
   \   00001A   5C83         SUB.B   #0x1, R12
   \   00001C   2024         JEQ     ??zclAnalogDataType_0
   \   00001E   5C83         SUB.B   #0x1, R12
   \   000020   1E24         JEQ     ??zclAnalogDataType_0
   \   000022   5C83         SUB.B   #0x1, R12
   \   000024   1C24         JEQ     ??zclAnalogDataType_0
   \   000026   5C83         SUB.B   #0x1, R12
   \   000028   1A24         JEQ     ??zclAnalogDataType_0
   \   00002A   5C83         SUB.B   #0x1, R12
   \   00002C   1824         JEQ     ??zclAnalogDataType_0
   \   00002E   5C83         SUB.B   #0x1, R12
   \   000030   1624         JEQ     ??zclAnalogDataType_0
   \   000032   5C83         SUB.B   #0x1, R12
   \   000034   1424         JEQ     ??zclAnalogDataType_0
   \   000036   5C83         SUB.B   #0x1, R12
   \   000038   1224         JEQ     ??zclAnalogDataType_0
   \   00003A   5C83         SUB.B   #0x1, R12
   \   00003C   1024         JEQ     ??zclAnalogDataType_0
   \   00003E   5C83         SUB.B   #0x1, R12
   \   000040   0E24         JEQ     ??zclAnalogDataType_0
   \   000042   7C800900     SUB.B   #0x9, R12
   \   000046   0B24         JEQ     ??zclAnalogDataType_0
   \   000048   5C83         SUB.B   #0x1, R12
   \   00004A   0924         JEQ     ??zclAnalogDataType_0
   \   00004C   5C83         SUB.B   #0x1, R12
   \   00004E   0724         JEQ     ??zclAnalogDataType_0
   \   000050   7C80A600     SUB.B   #0xa6, R12
   \   000054   0424         JEQ     ??zclAnalogDataType_0
   \   000056   5C83         SUB.B   #0x1, R12
   \   000058   0224         JEQ     ??zclAnalogDataType_0
   \   00005A   5C83         SUB.B   #0x1, R12
   \   00005C   0220         JNE     ??zclAnalogDataType_1
   2202            {
   2203              case ZCL_DATATYPE_UINT8:
   2204              case ZCL_DATATYPE_UINT16:
   2205              case ZCL_DATATYPE_UINT24:
   2206              case ZCL_DATATYPE_UINT32:
   2207              case ZCL_DATATYPE_UINT40:
   2208              case ZCL_DATATYPE_UINT48:
   2209              case ZCL_DATATYPE_UINT56:
   2210              case ZCL_DATATYPE_UINT64:
   2211              case ZCL_DATATYPE_INT8:
   2212              case ZCL_DATATYPE_INT16:
   2213              case ZCL_DATATYPE_INT24:
   2214              case ZCL_DATATYPE_INT32:
   2215              case ZCL_DATATYPE_INT40:
   2216              case ZCL_DATATYPE_INT48:
   2217              case ZCL_DATATYPE_INT56:
   2218              case ZCL_DATATYPE_INT64:
   2219              case ZCL_DATATYPE_SEMI_PREC:
   2220              case ZCL_DATATYPE_SINGLE_PREC:
   2221              case ZCL_DATATYPE_DOUBLE_PREC:
   2222              case ZCL_DATATYPE_TOD:
   2223              case ZCL_DATATYPE_DATE:
   2224              case ZCL_DATATYPE_UTC:
   2225                analog = TRUE;
   \                     ??zclAnalogDataType_0:
   \   00005E   5C43         MOV.B   #0x1, R12
   2226                break;
   \   000060   1001         RETA
   2227          
   2228              default:
   2229                analog = FALSE;
   \                     ??zclAnalogDataType_1:
   \   000062   4C43         MOV.B   #0x0, R12
   2230                break;
   2231            }
   2232          
   2233            return ( analog );
   \   000064   1001         RETA
   2234          }
   2235          
   2236          /*********************************************************************
   2237           * @fn      zcl_BuildAnalogData
   2238           *
   2239           * @brief   Build an analog arribute out of sequential bytes.
   2240           *
   2241           * @param   dataType - type of data
   2242           * @param   pData - pointer to data
   2243           * @param   pBuf - where to put the data
   2244           *
   2245           * @return  none
   2246           */

   \                                 In  segment CODE, align 2, keep-with-next
   2247          static void zcl_BuildAnalogData( uint8 dataType, uint8 *pData, uint8 *pBuf)
   \                     zcl_BuildAnalogData:
   2248          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4D         MOV.W   R13, R10
   2249            switch ( dataType )
   \   000004   7C802000     SUB.B   #0x20, R12
   \   000008   1C24         JEQ     ??zcl_BuildAnalogData_0
   \   00000A   5C83         SUB.B   #0x1, R12
   \   00000C   1D24         JEQ     ??zcl_BuildAnalogData_1
   \   00000E   5C83         SUB.B   #0x1, R12
   \   000010   2424         JEQ     ??zcl_BuildAnalogData_2
   \   000012   5C83         SUB.B   #0x1, R12
   \   000014   2524         JEQ     ??zcl_BuildAnalogData_3
   \   000016   7C800500     SUB.B   #0x5, R12
   \   00001A   1324         JEQ     ??zcl_BuildAnalogData_0
   \   00001C   5C83         SUB.B   #0x1, R12
   \   00001E   1424         JEQ     ??zcl_BuildAnalogData_1
   \   000020   5C83         SUB.B   #0x1, R12
   \   000022   1B24         JEQ     ??zcl_BuildAnalogData_2
   \   000024   5C83         SUB.B   #0x1, R12
   \   000026   1C24         JEQ     ??zcl_BuildAnalogData_3
   \   000028   7C800D00     SUB.B   #0xd, R12
   \   00002C   0D24         JEQ     ??zcl_BuildAnalogData_1
   \   00002E   5C83         SUB.B   #0x1, R12
   \   000030   1724         JEQ     ??zcl_BuildAnalogData_3
   \   000032   7C80A700     SUB.B   #0xa7, R12
   \   000036   1424         JEQ     ??zcl_BuildAnalogData_3
   \   000038   5C83         SUB.B   #0x1, R12
   \   00003A   1224         JEQ     ??zcl_BuildAnalogData_3
   \   00003C   5C83         SUB.B   #0x1, R12
   \   00003E   1024         JEQ     ??zcl_BuildAnalogData_3
   \   000040   183C         JMP     ??zcl_BuildAnalogData_4
   2250            {
   2251              case ZCL_DATATYPE_UINT8:
   2252              case ZCL_DATATYPE_INT8:
   2253                *pData = *pBuf;
   \                     ??zcl_BuildAnalogData_0:
   \   000042   ED4E0000     MOV.B   @R14, 0(R13)
   2254                break;
   \   000046   173C         JMP     ??zcl_BuildAnalogData_5
   2255          
   2256              case ZCL_DATATYPE_UINT16:
   2257              case ZCL_DATATYPE_INT16:
   2258              case ZCL_DATATYPE_SEMI_PREC:
   2259                *((uint16*)pData) = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zcl_BuildAnalogData_1:
   \   000048   6D4E         MOV.B   @R14, R13
   \   00004A   5F4E0100     MOV.B   0x1(R14), R15
   \   00004E                RPT     #0x8
   \   00004E   47180F5F     RLAX.W  R15
   \   000052   0D5F         ADD.W   R15, R13
   \   000054   8A4D0000     MOV.W   R13, 0(R10)
   2260                break;
   \   000058   0E3C         JMP     ??zcl_BuildAnalogData_5
   2261          
   2262              case ZCL_DATATYPE_UINT24:
   2263              case ZCL_DATATYPE_INT24:
   2264                *((uint32*)pData) = osal_build_uint32( pBuf, 3 );
   \                     ??zcl_BuildAnalogData_2:
   \   00005A   7D400300     MOV.B   #0x3, R13
   \   00005E   013C         JMP     ??zcl_BuildAnalogData_6
   2265                break;
   2266          
   2267              case ZCL_DATATYPE_UINT32:
   2268              case ZCL_DATATYPE_INT32:
   2269              case ZCL_DATATYPE_SINGLE_PREC:
   2270              case ZCL_DATATYPE_TOD:
   2271              case ZCL_DATATYPE_DATE:
   2272              case ZCL_DATATYPE_UTC:
   2273                *((uint32*)pData) = osal_build_uint32( pBuf, 4 );
   \                     ??zcl_BuildAnalogData_3:
   \   000060   6D42         MOV.B   #0x4, R13
   \                     ??zcl_BuildAnalogData_6:
   \   000062   0C4E         MOV.W   R14, R12
   \   000064   ........     CALLA   #osal_build_uint32
   \   000068   8A4C0000     MOV.W   R12, 0(R10)
   \   00006C   8A4D0200     MOV.W   R13, 0x2(R10)
   2274                break;
   \   000070   023C         JMP     ??zcl_BuildAnalogData_5
   2275          
   2276              case ZCL_DATATYPE_UINT40:
   2277              case ZCL_DATATYPE_UINT48:
   2278              case ZCL_DATATYPE_UINT56:
   2279              case ZCL_DATATYPE_UINT64:
   2280              case ZCL_DATATYPE_INT40:
   2281              case ZCL_DATATYPE_INT48:
   2282              case ZCL_DATATYPE_INT56:
   2283              case ZCL_DATATYPE_INT64:
   2284              case ZCL_DATATYPE_DOUBLE_PREC:
   2285                *pData = 0;
   2286                break;
   2287          
   2288              default:
   2289                *pData = 0;
   \                     ??zcl_BuildAnalogData_4:
   \   000072   CD430000     MOV.B   #0x0, 0(R13)
   2290                break;
   2291            }
   2292          }
   \                     ??zcl_BuildAnalogData_5:
   \   000076   3A41         POP.W   R10
   \   000078   1001         RETA
   2293          #endif // ZCL_REPORT
   2294          
   2295          /*********************************************************************
   2296           * @fn      zclGetDataTypeLength
   2297           *
   2298           * @brief   Return the length of the datatype in octet.
   2299           *
   2300           *          NOTE: Should not be called for ZCL_DATATYPE_OCTECT_STR or 
   2301           *                ZCL_DATATYPE_CHAR_STR data types.
   2302           *
   2303           * @param   dataType - data type
   2304           *
   2305           * @return  length of data
   2306           */

   \                                 In  segment CODE, align 2
   2307          uint8 zclGetDataTypeLength( uint8 dataType )
   \                     zclGetDataTypeLength:
   2308          {
   2309            uint8 len;
   2310          
   2311            switch ( dataType )
   \   000000   7C82         SUB.B   #0x8, R12
   \   000002   5124         JEQ     ??zclGetDataTypeLength_0
   \   000004   5C83         SUB.B   #0x1, R12
   \   000006   5124         JEQ     ??zclGetDataTypeLength_1
   \   000008   5C83         SUB.B   #0x1, R12
   \   00000A   5124         JEQ     ??zclGetDataTypeLength_2
   \   00000C   5C83         SUB.B   #0x1, R12
   \   00000E   5224         JEQ     ??zclGetDataTypeLength_3
   \   000010   7C800500     SUB.B   #0x5, R12
   \   000014   4824         JEQ     ??zclGetDataTypeLength_0
   \   000016   7C82         SUB.B   #0x8, R12
   \   000018   4624         JEQ     ??zclGetDataTypeLength_0
   \   00001A   5C83         SUB.B   #0x1, R12
   \   00001C   4624         JEQ     ??zclGetDataTypeLength_1
   \   00001E   5C83         SUB.B   #0x1, R12
   \   000020   4624         JEQ     ??zclGetDataTypeLength_2
   \   000022   5C83         SUB.B   #0x1, R12
   \   000024   4724         JEQ     ??zclGetDataTypeLength_3
   \   000026   7C800500     SUB.B   #0x5, R12
   \   00002A   3D24         JEQ     ??zclGetDataTypeLength_0
   \   00002C   5C83         SUB.B   #0x1, R12
   \   00002E   3D24         JEQ     ??zclGetDataTypeLength_1
   \   000030   5C83         SUB.B   #0x1, R12
   \   000032   3D24         JEQ     ??zclGetDataTypeLength_2
   \   000034   5C83         SUB.B   #0x1, R12
   \   000036   3E24         JEQ     ??zclGetDataTypeLength_3
   \   000038   5C83         SUB.B   #0x1, R12
   \   00003A   3E24         JEQ     ??zclGetDataTypeLength_4
   \   00003C   5C83         SUB.B   #0x1, R12
   \   00003E   3F24         JEQ     ??zclGetDataTypeLength_5
   \   000040   5C83         SUB.B   #0x1, R12
   \   000042   4024         JEQ     ??zclGetDataTypeLength_6
   \   000044   5C83         SUB.B   #0x1, R12
   \   000046   4124         JEQ     ??zclGetDataTypeLength_7
   \   000048   5C83         SUB.B   #0x1, R12
   \   00004A   2D24         JEQ     ??zclGetDataTypeLength_0
   \   00004C   5C83         SUB.B   #0x1, R12
   \   00004E   2D24         JEQ     ??zclGetDataTypeLength_1
   \   000050   5C83         SUB.B   #0x1, R12
   \   000052   2D24         JEQ     ??zclGetDataTypeLength_2
   \   000054   5C83         SUB.B   #0x1, R12
   \   000056   2E24         JEQ     ??zclGetDataTypeLength_3
   \   000058   5C83         SUB.B   #0x1, R12
   \   00005A   2E24         JEQ     ??zclGetDataTypeLength_4
   \   00005C   5C83         SUB.B   #0x1, R12
   \   00005E   2F24         JEQ     ??zclGetDataTypeLength_5
   \   000060   5C83         SUB.B   #0x1, R12
   \   000062   3024         JEQ     ??zclGetDataTypeLength_6
   \   000064   5C83         SUB.B   #0x1, R12
   \   000066   3124         JEQ     ??zclGetDataTypeLength_7
   \   000068   5C83         SUB.B   #0x1, R12
   \   00006A   1D24         JEQ     ??zclGetDataTypeLength_0
   \   00006C   5C83         SUB.B   #0x1, R12
   \   00006E   1D24         JEQ     ??zclGetDataTypeLength_1
   \   000070   7C800700     SUB.B   #0x7, R12
   \   000074   1A24         JEQ     ??zclGetDataTypeLength_1
   \   000076   5C83         SUB.B   #0x1, R12
   \   000078   1D24         JEQ     ??zclGetDataTypeLength_3
   \   00007A   5C83         SUB.B   #0x1, R12
   \   00007C   2624         JEQ     ??zclGetDataTypeLength_7
   \   00007E   7C80A600     SUB.B   #0xa6, R12
   \   000082   1824         JEQ     ??zclGetDataTypeLength_3
   \   000084   5C83         SUB.B   #0x1, R12
   \   000086   1624         JEQ     ??zclGetDataTypeLength_3
   \   000088   5C83         SUB.B   #0x1, R12
   \   00008A   1424         JEQ     ??zclGetDataTypeLength_3
   \   00008C   7C800600     SUB.B   #0x6, R12
   \   000090   0C24         JEQ     ??zclGetDataTypeLength_1
   \   000092   5C83         SUB.B   #0x1, R12
   \   000094   0A24         JEQ     ??zclGetDataTypeLength_1
   \   000096   5C83         SUB.B   #0x1, R12
   \   000098   0D24         JEQ     ??zclGetDataTypeLength_3
   \   00009A   7C800600     SUB.B   #0x6, R12
   \   00009E   1524         JEQ     ??zclGetDataTypeLength_7
   \   0000A0   5C83         SUB.B   #0x1, R12
   \   0000A2   1524         JEQ     ??zclGetDataTypeLength_8
   \   0000A4   173C         JMP     ??zclGetDataTypeLength_9
   2312            {
   2313              case ZCL_DATATYPE_DATA8:
   2314              case ZCL_DATATYPE_BOOLEAN:
   2315              case ZCL_DATATYPE_BITMAP8:
   2316              case ZCL_DATATYPE_INT8:
   2317              case ZCL_DATATYPE_UINT8:
   2318              case ZCL_DATATYPE_ENUM8:
   2319                len = 1;
   \                     ??zclGetDataTypeLength_0:
   \   0000A6   5C43         MOV.B   #0x1, R12
   2320                break;
   \   0000A8   1001         RETA
   2321          
   2322              case ZCL_DATATYPE_DATA16:
   2323              case ZCL_DATATYPE_BITMAP16:
   2324              case ZCL_DATATYPE_UINT16:
   2325              case ZCL_DATATYPE_INT16:
   2326              case ZCL_DATATYPE_ENUM16:
   2327              case ZCL_DATATYPE_SEMI_PREC:
   2328              case ZCL_DATATYPE_CLUSTER_ID:
   2329              case ZCL_DATATYPE_ATTR_ID:
   2330                len = 2;
   \                     ??zclGetDataTypeLength_1:
   \   0000AA   6C43         MOV.B   #0x2, R12
   2331                break;
   \   0000AC   1001         RETA
   2332          
   2333              case ZCL_DATATYPE_DATA24:
   2334              case ZCL_DATATYPE_BITMAP24:
   2335              case ZCL_DATATYPE_UINT24:
   2336              case ZCL_DATATYPE_INT24:
   2337                len = 3;
   \                     ??zclGetDataTypeLength_2:
   \   0000AE   7C400300     MOV.B   #0x3, R12
   2338                break;
   \   0000B2   1001         RETA
   2339          
   2340              case ZCL_DATATYPE_DATA32:
   2341              case ZCL_DATATYPE_BITMAP32:
   2342              case ZCL_DATATYPE_UINT32:
   2343              case ZCL_DATATYPE_INT32:
   2344              case ZCL_DATATYPE_SINGLE_PREC:
   2345              case ZCL_DATATYPE_TOD:
   2346              case ZCL_DATATYPE_DATE:
   2347              case ZCL_DATATYPE_UTC:
   2348              case ZCL_DATATYPE_BAC_OID:
   2349                len = 4;
   \                     ??zclGetDataTypeLength_3:
   \   0000B4   6C42         MOV.B   #0x4, R12
   2350                break;
   \   0000B6   1001         RETA
   2351          
   2352             case ZCL_DATATYPE_UINT40:
   2353             case ZCL_DATATYPE_INT40:
   2354                 len = 5;
   \                     ??zclGetDataTypeLength_4:
   \   0000B8   7C400500     MOV.B   #0x5, R12
   2355                 break;
   \   0000BC   1001         RETA
   2356          
   2357             case ZCL_DATATYPE_UINT48:
   2358             case ZCL_DATATYPE_INT48:
   2359                 len = 6;
   \                     ??zclGetDataTypeLength_5:
   \   0000BE   7C400600     MOV.B   #0x6, R12
   2360                 break;
   \   0000C2   1001         RETA
   2361          
   2362             case ZCL_DATATYPE_UINT56:
   2363             case ZCL_DATATYPE_INT56:
   2364                 len = 7;
   \                     ??zclGetDataTypeLength_6:
   \   0000C4   7C400700     MOV.B   #0x7, R12
   2365                 break;
   \   0000C8   1001         RETA
   2366          
   2367             case ZCL_DATATYPE_DOUBLE_PREC:
   2368             case ZCL_DATATYPE_IEEE_ADDR:
   2369             case ZCL_DATATYPE_UINT64:
   2370             case ZCL_DATATYPE_INT64:
   2371               len = 8;
   \                     ??zclGetDataTypeLength_7:
   \   0000CA   7C42         MOV.B   #0x8, R12
   2372               break;
   \   0000CC   1001         RETA
   2373          
   2374              case ZCL_DATATYPE_128_BIT_SEC_KEY:
   2375               len = 16;
   \                     ??zclGetDataTypeLength_8:
   \   0000CE   7C401000     MOV.B   #0x10, R12
   2376               break;
   \   0000D2   1001         RETA
   2377          
   2378              case ZCL_DATATYPE_NO_DATA:
   2379              case ZCL_DATATYPE_UNKNOWN:
   2380                // Fall through
   2381          
   2382              default:
   2383                len = 0;
   \                     ??zclGetDataTypeLength_9:
   \   0000D4   4C43         MOV.B   #0x0, R12
   2384                break;
   2385            }
   2386          
   2387            return ( len );
   \   0000D6   1001         RETA
   2388          }
   2389          
   2390          /*********************************************************************
   2391           * @fn      zclGetAttrDataLength
   2392           *
   2393           * @brief   Return the length of the attribute.
   2394           *
   2395           * @param   dataType - data type
   2396           * @param   pData - pointer to data
   2397           *
   2398           * @return  returns atrribute length
   2399           */

   \                                 In  segment CODE, align 2
   2400          uint16 zclGetAttrDataLength( uint8 dataType, uint8 *pData )
   \                     zclGetAttrDataLength:
   2401          {
   2402            uint16 dataLen = 0;
   2403          
   2404            if ( dataType == ZCL_DATATYPE_LONG_CHAR_STR || dataType == ZCL_DATATYPE_LONG_OCTET_STR )
   \   000000   7C904400     CMP.B   #0x44, R12
   \   000004   0324         JEQ     ??zclGetAttrDataLength_0
   \   000006   7C904300     CMP.B   #0x43, R12
   \   00000A   0820         JNE     ??zclGetAttrDataLength_1
   2405            {
   2406              dataLen = BUILD_UINT16( pData[0], pData[1] ) + 2; // long string length + 2 for length field
   \                     ??zclGetAttrDataLength_0:
   \   00000C   6C4D         MOV.B   @R13, R12
   \   00000E   5F4D0100     MOV.B   0x1(R13), R15
   \   000012                RPT     #0x8
   \   000012   47180F5F     RLAX.W  R15
   \   000016   0C5F         ADD.W   R15, R12
   \   000018   2C53         ADD.W   #0x2, R12
   \   00001A   1001         RETA
   2407            }
   2408            else if ( dataType == ZCL_DATATYPE_CHAR_STR || dataType == ZCL_DATATYPE_OCTET_STR )
   \                     ??zclGetAttrDataLength_1:
   \   00001C   7C904200     CMP.B   #0x42, R12
   \   000020   0324         JEQ     ??zclGetAttrDataLength_2
   \   000022   7C904100     CMP.B   #0x41, R12
   \   000026   0320         JNE     ??zclGetAttrDataLength_3
   2409            {
   2410              dataLen = *pData + 1; // string length + 1 for length field
   \                     ??zclGetAttrDataLength_2:
   \   000028   6C4D         MOV.B   @R13, R12
   \   00002A   1C53         ADD.W   #0x1, R12
   \   00002C   1001         RETA
   2411            }
   2412            else
   2413            {
   2414              dataLen = zclGetDataTypeLength( dataType );
   \                     ??zclGetAttrDataLength_3:
   \   00002E   ........     CALLA   #zclGetDataTypeLength
   \   000032   4C4C         MOV.B   R12, R12
   2415            }
   2416          
   2417            return ( dataLen );
   \   000034   1001         RETA
   2418          }
   2419          
   2420          /*********************************************************************
   2421           * @fn      zclReadAttrData
   2422           *
   2423           * @brief   Read the attribute's current value into pAttrData.
   2424           *
   2425           * @param   pAttrData - where to put attribute data
   2426           * @param   pAttr - pointer to attribute
   2427           * @param   pDataLen - where to put attribute data length
   2428           *
   2429           * @return Success
   2430           */

   \                                 In  segment CODE, align 2
   2431          uint8 zclReadAttrData( uint8 *pAttrData, zclAttrRec_t *pAttr, uint16 *pDataLen )
   \                     zclReadAttrData:
   2432          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4C         MOV.W   R12, R10
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   084E         MOV.W   R14, R8
   2433            uint16 dataLen;
   2434          
   2435            dataLen = zclGetAttrDataLength( pAttr->attr.dataType, (uint8*)(pAttr->attr.dataPtr) );
   \   000008   1D4B0600     MOV.W   0x6(R11), R13
   \   00000C   5C4B0400     MOV.B   0x4(R11), R12
   \   000010   ........     CALLA   #zclGetAttrDataLength
   \   000014   094C         MOV.W   R12, R9
   2436            osal_memcpy( pAttrData, pAttr->attr.dataPtr, dataLen );
   \   000016   0E4C         MOV.W   R12, R14
   \   000018   1D4B0600     MOV.W   0x6(R11), R13
   \   00001C   0C4A         MOV.W   R10, R12
   \   00001E   ........     CALLA   #osal_memcpy
   2437          
   2438            if ( pDataLen != NULL )
   \   000022   0893         CMP.W   #0x0, R8
   \   000024   0224         JEQ     ??zclReadAttrData_0
   2439            {
   2440              *pDataLen = dataLen;
   \   000026   88490000     MOV.W   R9, 0(R8)
   2441            }
   2442          
   2443            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclReadAttrData_0:
   \   00002A   4C43         MOV.B   #0x0, R12
   \   00002C   3817         POPM.W  #0x4, R11
   \   00002E   1001         RETA
   2444          }
   2445          
   2446          #ifdef ZCL_READ
   2447          /*********************************************************************
   2448           * @fn      zclGetAttrDataLengthUsingCB
   2449           *
   2450           * @brief   Use application's callback to get the length of the attribute's
   2451           *          current value stored in the database.
   2452           *
   2453           * @param   endpoint - application's endpoint
   2454           * @param   clusterId - cluster that attribute belongs to
   2455           * @param   attrId - attribute id
   2456           *
   2457           * @return  returns attribute length
   2458           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine6_0:
   \   000000   0A4C         MOV.W   R12, R10
   \   000002   0B4D         MOV.W   R13, R11
   \   000004   0F4C         MOV.W   R12, R15
   \   000006   0FDD         BIS.W   R13, R15
   \   000008   0F93         CMP.W   #0x0, R15
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2459          static uint16 zclGetAttrDataLengthUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId )
   \                     zclGetAttrDataLengthUsingCB:
   2460          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   2183         SUB.W   #0x2, SP
   \   000004   094D         MOV.W   R13, R9
   \   000006   084E         MOV.W   R14, R8
   2461            uint16 dataLen = 0;
   \   000008   81430000     MOV.W   #0x0, 0(SP)
   2462            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000C   ........     CALLA   #zclGetReadWriteCB
   \   000010   ........     CALLA   #??Subroutine6_0
   2463          
   2464            if ( pfnReadWriteCB != NULL )
   \                     ??CrossCallReturnLabel_83:
   \   000014   0924         JEQ     ??zclGetAttrDataLengthUsingCB_0
   2465            {
   2466              // Only get the attribute length
   2467              (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_LEN, NULL, &dataLen );
   \   000016   0F41         MOV.W   SP, R15
   \   000018   0F12         PUSH.W  R15
   \   00001A   0F43         MOV.W   #0x0, R15
   \   00001C   4E43         MOV.B   #0x0, R14
   \   00001E   0D48         MOV.W   R8, R13
   \   000020   0C49         MOV.W   R9, R12
   \   000022   ........     CALLA   #?IndCallR11
   \   000026   2153         ADD.W   #0x2, SP
   2468            }
   2469          
   2470            return ( dataLen );
   \                     ??zclGetAttrDataLengthUsingCB_0:
   \   000028   2C41         MOV.W   @SP, R12
   \   00002A   2153         ADD.W   #0x2, SP
   \   00002C   3817         POPM.W  #0x4, R11
   \   00002E   1001         RETA
   2471          }
   2472          
   2473          /*********************************************************************
   2474           * @fn      zclReadAttrDataUsingCB
   2475           *
   2476           * @brief   Use application's callback to read the attribute's current
   2477           *          value stored in the database.
   2478           *
   2479           * @param   endpoint - application's endpoint
   2480           * @param   clusterId - cluster that attribute belongs to
   2481           * @param   attrId - attribute id
   2482           * @param   pAttrData - where to put attribute data
   2483           * @param   pDataLen - where to put attribute data length
   2484           *
   2485           * @return  Successful if data was read
   2486           */

   \                                 In  segment CODE, align 2, keep-with-next
   2487          static ZStatus_t zclReadAttrDataUsingCB( uint8 endpoint, uint16 clusterId, uint16 attrId,
   \                     zclReadAttrDataUsingCB:
   2488                                                   uint8 *pAttrData, uint16 *pDataLen )
   2489          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   094D         MOV.W   R13, R9
   \   000004   084E         MOV.W   R14, R8
   \   000006   0E4F         MOV.W   R15, R14
   \   000008   16411000     MOV.W   0x10(SP), R6
   2490            zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   00000C   ........     CALLA   #zclGetReadWriteCB
   \   000010   0A4C         MOV.W   R12, R10
   \   000012   0B4D         MOV.W   R13, R11
   2491          
   2492            if ( pDataLen != NULL )
   \   000014   0693         CMP.W   #0x0, R6
   \   000016   0224         JEQ     ??zclReadAttrDataUsingCB_0
   2493            {
   2494              *pDataLen = 0; // Always initialize it to 0
   \   000018   86430000     MOV.W   #0x0, 0(R6)
   2495            }
   2496          
   2497            if ( pfnReadWriteCB != NULL )
   \                     ??zclReadAttrDataUsingCB_0:
   \   00001C   0F4C         MOV.W   R12, R15
   \   00001E   0FDD         BIS.W   R13, R15
   \   000020   0F93         CMP.W   #0x0, R15
   \   000022   0924         JEQ     ??zclReadAttrDataUsingCB_1
   2498            {
   2499              // Read the attribute value and its length
   2500              return ( (*pfnReadWriteCB)( clusterId, attrId, ZCL_OPER_READ, pAttrData, pDataLen ) );
   \   000024   0612         PUSH.W  R6
   \   000026   0F4E         MOV.W   R14, R15
   \   000028   5E43         MOV.B   #0x1, R14
   \   00002A   0D48         MOV.W   R8, R13
   \   00002C   0C49         MOV.W   R9, R12
   \   00002E   ........     CALLA   #?IndCallR11
   \   000032   2153         ADD.W   #0x2, SP
   \   000034   023C         JMP     ??zclReadAttrDataUsingCB_2
   2501            }
   2502          
   2503            return ( ZCL_STATUS_SOFTWARE_FAILURE );
   \                     ??zclReadAttrDataUsingCB_1:
   \   000036   7C40C100     MOV.B   #0xc1, R12
   \                     ??zclReadAttrDataUsingCB_2:
   \   00003A   5617         POPM.W  #0x6, R11
   \   00003C   1001         RETA
   2504          }
   2505          
   2506          /*********************************************************************
   2507           * @fn      zclAuthorizeRead
   2508           *
   2509           * @brief   Use application's callback to authorize a Read operation
   2510           *          on a given attribute.
   2511           *
   2512           * @param   endpoint - application's endpoint
   2513           * @param   srcAddr - source Address
   2514           * @param   pAttr - pointer to attribute
   2515           *
   2516           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   2517           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   2518           */
   2519          static ZStatus_t zclAuthorizeRead( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   2520          {
   2521            if ( zcl_AccessCtrlAuthRead( pAttr->attr.accessControl ) )
   2522            {
   2523              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   2524            
   2525              if ( pfnAuthorizeCB != NULL )
   2526              {
   2527                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_READ ) );
   2528              }
   2529            }
   2530          
   2531            return ( ZCL_STATUS_SUCCESS );
   2532          }
   2533          #endif // ZCL_READ
   2534          
   2535          #ifdef ZCL_WRITE
   2536          /*********************************************************************
   2537           * @fn      zclWriteAttrData
   2538           *
   2539           * @brief   Write the received data.
   2540           *
   2541           * @param   endpoint - application's endpoint
   2542           * @param   pAttr - where to write data to
   2543           * @param   pWriteRec - data to be written
   2544           *
   2545           * @return  Successful if data was written
   2546           */

   \                                 In  segment CODE, align 2, keep-with-next
   2547          static ZStatus_t zclWriteAttrData( uint8 endpoint, afAddrType_t *srcAddr, 
   \                     zclWriteAttrData:
   2548                                             zclAttrRec_t *pAttr, zclWriteRec_t *pWriteRec )
   2549          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0A4E         MOV.W   R14, R10
   \   000004   0B4F         MOV.W   R15, R11
   2550            uint8 status;
   2551          
   2552            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000006   EEB30500     BIT.B   #0x2, 0x5(R14)
   \   00000A   2228         JNC     ??zclWriteAttrData_0
   2553            {
   2554              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   00000C   ........     CALLA   #zclAuthorizeWrite
   \   000010   484C         MOV.B   R12, R8
   2555              if ( status == ZCL_STATUS_SUCCESS )
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   1F20         JNE     ??zclWriteAttrData_1
   2556              {
   2557                if ( ( zcl_ValidateAttrDataCB == NULL ) || zcl_ValidateAttrDataCB( pAttr, pWriteRec ) )
   \   000016   1F42....     MOV.W   &zcl_ValidateAttrDataCB, R15
   \   00001A   1FD2....     BIS.W   &zcl_ValidateAttrDataCB + 2, R15
   \   00001E   0F93         CMP.W   #0x0, R15
   \   000020   0624         JEQ     ??zclWriteAttrData_2
   \   000022   0D4B         MOV.W   R11, R13
   \   000024   0C4A         MOV.W   R10, R12
   \   000026   ........     CALLA   &zcl_ValidateAttrDataCB
   \   00002A   4C93         CMP.B   #0x0, R12
   \   00002C   0E24         JEQ     ??zclWriteAttrData_3
   2558                {
   2559                  // Write the attribute value
   2560                  uint16 len = zclGetAttrDataLength( pAttr->attr.dataType, pWriteRec->attrData );
   \                     ??zclWriteAttrData_2:
   \   00002E   1D4B0400     MOV.W   0x4(R11), R13
   \   000032   5C4A0400     MOV.B   0x4(R10), R12
   \   000036   ........     CALLA   #zclGetAttrDataLength
   \   00003A   0E4C         MOV.W   R12, R14
   2561                  osal_memcpy( pAttr->attr.dataPtr, pWriteRec->attrData, len );
   \   00003C   1D4B0400     MOV.W   0x4(R11), R13
   \   000040   1C4A0600     MOV.W   0x6(R10), R12
   \   000044   ........     CALLA   #osal_memcpy
   2562          
   2563                  status = ZCL_STATUS_SUCCESS;
   \   000048   053C         JMP     ??zclWriteAttrData_1
   2564                }
   2565                else
   2566                {
   2567                  status = ZCL_STATUS_INVALID_VALUE;
   \                     ??zclWriteAttrData_3:
   \   00004A   78408700     MOV.B   #0x87, R8
   \   00004E   023C         JMP     ??zclWriteAttrData_1
   2568                }
   2569              }
   2570            }
   2571            else
   2572            {
   2573              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrData_0:
   \   000050   78408800     MOV.B   #0x88, R8
   2574            }
   2575          
   2576            return ( status );
   \                     ??zclWriteAttrData_1:
   \   000054   4C48         MOV.B   R8, R12
   \   000056   3817         POPM.W  #0x4, R11
   \   000058   1001         RETA
   2577          }
   2578          
   2579          /*********************************************************************
   2580           * @fn      zclWriteAttrDataUsingCB
   2581           *
   2582           * @brief   Use application's callback to write the attribute's current
   2583           *          value stored in the database.
   2584           *
   2585           * @param   endpoint - application's endpoint
   2586           * @param   pAttr - where to write data to
   2587           * @param   pAttrData - data to be written
   2588           *
   2589           * @return  Successful if data was written
   2590           */

   \                                 In  segment CODE, align 2, keep-with-next
   2591          static ZStatus_t zclWriteAttrDataUsingCB( uint8 endpoint, afAddrType_t *srcAddr, 
   \                     zclWriteAttrDataUsingCB:
   2592                                                    zclAttrRec_t *pAttr, uint8 *pAttrData )
   2593          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   4A4C         MOV.B   R12, R10
   \   000004   084E         MOV.W   R14, R8
   \   000006   094F         MOV.W   R15, R9
   2594            uint8 status;
   2595          
   2596            if ( zcl_AccessCtrlWrite( pAttr->attr.accessControl ) )
   \   000008   EEB30500     BIT.B   #0x2, 0x5(R14)
   \   00000C   1728         JNC     ??zclWriteAttrDataUsingCB_0
   2597            {
   2598              status = zclAuthorizeWrite( endpoint, srcAddr, pAttr );
   \   00000E   ........     CALLA   #zclAuthorizeWrite
   2599              if ( status == ZCL_STATUS_SUCCESS )
   \   000012   4C93         CMP.B   #0x0, R12
   \   000014   1520         JNE     ??zclWriteAttrDataUsingCB_1
   2600              {
   2601                zclReadWriteCB_t pfnReadWriteCB = zclGetReadWriteCB( endpoint );
   \   000016   4C4A         MOV.B   R10, R12
   \   000018   ........     CALLA   #zclGetReadWriteCB
   \   00001C   ........     CALLA   #??Subroutine6_0
   2602                if ( pfnReadWriteCB != NULL )
   \                     ??CrossCallReturnLabel_82:
   \   000020   0A24         JEQ     ??zclWriteAttrDataUsingCB_2
   2603                {
   2604                  // Write the attribute value
   2605                  status = (*pfnReadWriteCB)( pAttr->clusterID, pAttr->attr.attrId, 
   2606                                              ZCL_OPER_WRITE, pAttrData, NULL );
   \   000022   0312         PUSH.W  #0x0
   \   000024   0F49         MOV.W   R9, R15
   \   000026   6E43         MOV.B   #0x2, R14
   \   000028   1D480200     MOV.W   0x2(R8), R13
   \   00002C   2C48         MOV.W   @R8, R12
   \   00002E   ........     CALLA   #?IndCallR11
   \   000032   2153         ADD.W   #0x2, SP
   \   000034   053C         JMP     ??zclWriteAttrDataUsingCB_1
   2607                }
   2608                else
   2609                {
   2610                  status = ZCL_STATUS_SOFTWARE_FAILURE;
   \                     ??zclWriteAttrDataUsingCB_2:
   \   000036   7C40C100     MOV.B   #0xc1, R12
   \   00003A   023C         JMP     ??zclWriteAttrDataUsingCB_1
   2611                }
   2612              }
   2613            }
   2614            else
   2615            {
   2616              status = ZCL_STATUS_READ_ONLY;
   \                     ??zclWriteAttrDataUsingCB_0:
   \   00003C   7C408800     MOV.B   #0x88, R12
   2617            }
   2618          
   2619            return ( status );
   \                     ??zclWriteAttrDataUsingCB_1:
   \   000040   3817         POPM.W  #0x4, R11
   \   000042   1001         RETA
   2620          }
   2621          
   2622          /*********************************************************************
   2623           * @fn      zclAuthorizeWrite
   2624           *
   2625           * @brief   Use application's callback to authorize a Write operation
   2626           *          on a given attribute.
   2627           *
   2628           * @param   endpoint - application's endpoint
   2629           * @param   srcAddr - source Address
   2630           * @param   pAttr - pointer to attribute
   2631           *
   2632           * @return  ZCL_STATUS_SUCCESS: Operation authorized
   2633           *          ZCL_STATUS_NOT_AUTHORIZED: Operation not authorized
   2634           */

   \                                 In  segment CODE, align 2, keep-with-next
   2635          static ZStatus_t zclAuthorizeWrite( uint8 endpoint, afAddrType_t *srcAddr, zclAttrRec_t *pAttr )
   \                     zclAuthorizeWrite:
   2636          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   094D         MOV.W   R13, R9
   \   000004   084E         MOV.W   R14, R8
   2637            if ( zcl_AccessCtrlAuthWrite( pAttr->attr.accessControl ) )
   \   000006   FEB020000500 BIT.B   #0x20, 0x5(R14)
   \   00000C   0928         JNC     ??zclAuthorizeWrite_0
   2638            {
   2639              zclAuthorizeCB_t pfnAuthorizeCB = zclGetAuthorizeCB( endpoint );
   \   00000E   ........     CALLA   #?Subroutine6
   2640            
   2641              if ( pfnAuthorizeCB != NULL )
   \                     ??CrossCallReturnLabel_80:
   \   000012   0624         JEQ     ??zclAuthorizeWrite_0
   2642              {
   2643                return ( (*pfnAuthorizeCB)( srcAddr, pAttr, ZCL_OPER_WRITE ) );
   \   000014   6E43         MOV.B   #0x2, R14
   \   000016   0D48         MOV.W   R8, R13
   \   000018   0C49         MOV.W   R9, R12
   \   00001A   ........     CALLA   #?IndCallR11
   \   00001E   013C         JMP     ??zclAuthorizeWrite_1
   2644              }
   2645            }
   2646          
   2647            return ( ZCL_STATUS_SUCCESS );
   \                     ??zclAuthorizeWrite_0:
   \   000020   4C43         MOV.B   #0x0, R12
   \                     ??zclAuthorizeWrite_1:
   \   000022   3817         POPM.W  #0x4, R11
   \   000024   1001         RETA
   2648          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine6:
   \   000000   ........     CALLA   #zclGetAuthorizeCB
   \   000004                REQUIRE ??Subroutine6_0
   \   000004                // Fall through to label ??Subroutine6_0
   2649          #endif // ZCL_WRITE
   2650          
   2651          #ifdef ZCL_READ
   2652          /*********************************************************************
   2653           * @fn      zclParseInReadCmd
   2654           *
   2655           * @brief   Parse the "Profile" Read Commands
   2656           *
   2657           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2658           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2659           *
   2660           * @param   pCmd - pointer to incoming data to parse
   2661           *
   2662           * @return  pointer to the parsed command structure
   2663           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine14_0:
   \   000000   2C53         ADD.W   #0x2, R12
   \   000002                REQUIRE ?Subroutine52
   \   000002                // Fall through to label ?Subroutine52

   \                                 In  segment CODE, align 2, keep-with-next
   2664          void *zclParseInReadCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadCmd:
   2665          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0B4C         MOV.W   R12, R11
   2666            zclReadCmd_t *readCmd;
   2667            uint8 *pBuf = pCmd->pData;
   \   000004   1A4C0400     MOV.W   0x4(R12), R10
   2668          
   2669            readCmd = (zclReadCmd_t *)osal_mem_alloc( sizeof ( zclReadCmd_t ) + pCmd->dataLen );
   \   000008   1C4B0200     MOV.W   0x2(R11), R12
   \   00000C   ........     CALLA   #??Subroutine14_0
   2670            if ( readCmd != NULL )
   \                     ??CrossCallReturnLabel_91:
   \   000010   1724         JEQ     ??zclParseInReadCmd_1
   2671            {
   2672              readCmd->numAttr = pCmd->dataLen / 2; // Atrribute ID
   \   000012   1E4B0200     MOV.W   0x2(R11), R14
   \   000016   5E03         RRUM.W  #0x1, R14
   \   000018   CC4E0000     MOV.B   R14, 0(R12)
   2673              for ( uint8 i = 0; i < readCmd->numAttr; i++ )
   \   00001C   4E43         MOV.B   #0x0, R14
   \   00001E   0E3C         JMP     ??zclParseInReadCmd_2
   2674              {
   2675                readCmd->attrID[i] = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadCmd_0:
   \   000020   6D4A         MOV.B   @R10, R13
   \   000022   5F4A0100     MOV.B   0x1(R10), R15
   \   000026                RPT     #0x8
   \   000026   47180F5F     RLAX.W  R15
   \   00002A   0D5F         ADD.W   R15, R13
   \   00002C   4F4E         MOV.B   R14, R15
   \   00002E   0F5F         RLA.W   R15
   \   000030   0B4C         MOV.W   R12, R11
   \   000032   0B5F         ADD.W   R15, R11
   \   000034   8B4D0200     MOV.W   R13, 0x2(R11)
   2676                pBuf += 2;
   \   000038   2A53         ADD.W   #0x2, R10
   2677              }
   \   00003A   5E53         ADD.B   #0x1, R14
   \                     ??zclParseInReadCmd_2:
   \   00003C   6E9C         CMP.B   @R12, R14
   \   00003E   F02B         JNC     ??zclParseInReadCmd_0
   2678            }
   2679          
   2680            return ( (void *)readCmd );
   \                     ??zclParseInReadCmd_1:
   \   000040   1A17         POPM.W  #0x2, R11
   \   000042   1001         RETA
   2681          }
   2682          
   2683          /*********************************************************************
   2684           * @fn      zclParseInReadRspCmd
   2685           *
   2686           * @brief   Parse the "Profile" Read Response Commands
   2687           *
   2688           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2689           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2690           *
   2691           * @param   pCmd - pointer to incoming data to parse
   2692           *
   2693           * @return  pointer to the parsed command structure
   2694           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   ........     CALLA   #?Subroutine36
   \                     ??CrossCallReturnLabel_36:
   \   000006   0E43         MOV.W   #0x0, R14
   \   000008   043C         JMP     ??Subroutine0_3
   \                     ??zclParseInReportCmd_0:
   \   00000A   5B53         ADD.B   #0x1, R11
   \   00000C   2953         ADD.W   #0x2, R9
   \   00000E   ........     CALLA   #?Subroutine22
   \                     ??Subroutine0_3:
   \   000012   1F470400     MOV.W   0x4(R7), R15
   \   000016   1F570200     ADD.W   0x2(R7), R15
   \   00001A   099F         CMP.W   R15, R9
   \   00001C   F62B         JNC     ??zclParseInReportCmd_0
   \   00001E   ........     CALLA   #?Subroutine28
   \                     ??CrossCallReturnLabel_105:
   \   000022   0D24         JEQ     ??Subroutine0_0
   \   000024   ........     CALLA   #?Subroutine7
   \                     ??CrossCallReturnLabel_0:
   \   000028   083C         JMP     ??Subroutine0_4
   \                     ??zclParseInReportCmd_1:
   \   00002A   ........     CALLA   #?Subroutine13
   \                     ??CrossCallReturnLabel_7:
   \   00002E   0D49         MOV.W   R9, R13
   \   000030   5C470200     MOV.B   0x2(R7), R12
   \   000034   ........     CALLA   #?Subroutine18
   \                     ??CrossCallReturnLabel_11:
   \   000038   5653         ADD.B   #0x1, R6
   \                     ??Subroutine0_4:
   \   00003A   469B         CMP.B   R11, R6
   \   00003C   F62B         JNC     ??zclParseInReportCmd_1
   \                     ??Subroutine0_0:
   \   00003E   0C48         MOV.W   R8, R12
   \   000040   7417         POPM.W  #0x8, R11
   \   000042   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine36:
   \   000000   074C         MOV.W   R12, R7
   \   000002   194C0400     MOV.W   0x4(R12), R9
   \   000006   4B43         MOV.B   #0x0, R11
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine50:
   \   000000   6E49         MOV.B   @R9, R14
   \   000002   5F490100     MOV.B   0x1(R9), R15
   \   000006                REQUIRE ??Subroutine50_0
   \   000006                // Fall through to label ??Subroutine50_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine7:
   \   000000   19470400     MOV.W   0x4(R7), R9
   \   000004   4F4A         MOV.B   R10, R15
   \   000006   0A4C         MOV.W   R12, R10
   \   000008   0A5F         ADD.W   R15, R10
   \   00000A   CC4B0000     MOV.B   R11, 0(R12)
   \   00000E   4643         MOV.B   #0x0, R6
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2695          static void *zclParseInReadRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadRspCmd:
   2696          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   ........     CALLA   #?Subroutine36
   2697            zclReadRspCmd_t *readRspCmd;
   2698            uint8 *pBuf = pCmd->pData;
   2699            uint8 *dataPtr;
   2700            uint8 numAttr = 0;
   2701            uint8 hdrLen;
   2702            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_39:
   \   000006   0E43         MOV.W   #0x0, R14
   \   000008   073C         JMP     ??zclParseInReadRspCmd_4
   2703            uint16 attrDataLen;
   2704            
   2705            // find out the number of attributes and the length of attribute data
   2706            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2707            {
   2708              uint8 status;
   2709          
   2710              numAttr++;
   \                     ??zclParseInReadRspCmd_0:
   \   00000A   5B53         ADD.B   #0x1, R11
   2711              pBuf += 2; // move pass attribute id
   \   00000C   2953         ADD.W   #0x2, R9
   2712          
   2713              status = *pBuf++;  
   \   00000E   7F49         MOV.B   @R9+, R15
   2714              if ( status == ZCL_STATUS_SUCCESS )
   \   000010   4F93         CMP.B   #0x0, R15
   \   000012   0220         JNE     ??zclParseInReadRspCmd_4
   2715              {
   2716                uint8 dataType = *pBuf++;
   \   000014   ........     CALLA   #?Subroutine22
   2717          
   2718                attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2719                pBuf += attrDataLen; // move pass attribute data
   2720          
   2721                // add padding if needed
   2722                if ( PADDING_NEEDED( attrDataLen ) )
   2723                {
   2724                  attrDataLen++;
   2725                }
   2726          
   2727                dataLen += attrDataLen;
   2728              }
   2729            }
   \                     ??zclParseInReadRspCmd_4:
   \   000018   1F470400     MOV.W   0x4(R7), R15
   \   00001C   1F570200     ADD.W   0x2(R7), R15
   \   000020   099F         CMP.W   R15, R9
   \   000022   F32B         JNC     ??zclParseInReadRspCmd_0
   2730          
   2731            // calculate the length of the response header
   2732            hdrLen = sizeof( zclReadRspCmd_t ) + ( numAttr * sizeof( zclReadRspStatus_t ) );
   \   000024   ........     CALLA   #?Subroutine28
   2733          
   2734            readRspCmd = (zclReadRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2735            if ( readRspCmd != NULL )
   \                     ??CrossCallReturnLabel_106:
   \   000028   1224         JEQ     ??zclParseInReadRspCmd_5
   2736            {
   2737              pBuf = pCmd->pData;
   \   00002A   ........     CALLA   #?Subroutine7
   2738              dataPtr = (uint8 *)( (uint8 *)readRspCmd + hdrLen );
   2739          
   2740              readRspCmd->numAttr = numAttr;
   2741              for ( uint8 i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_3:
   \   00002E   0D3C         JMP     ??zclParseInReadRspCmd_6
   2742              {
   2743                zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   \                     ??zclParseInReadRspCmd_1:
   \   000030   ........     CALLA   #?Subroutine13
   2744          
   2745                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2746                pBuf += 2;
   2747          
   2748                statusRec->status = *pBuf++;
   2749                if ( statusRec->status == ZCL_STATUS_SUCCESS )
   \                     ??CrossCallReturnLabel_8:
   \   000034   C7930200     CMP.B   #0x0, 0x2(R7)
   \   000038   0720         JNE     ??zclParseInReadRspCmd_7
   2750                {
   2751                  statusRec->dataType = *pBuf++;
   \   00003A   F7490300     MOV.B   @R9+, 0x3(R7)
   2752          
   2753                  attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   \   00003E   0D49         MOV.W   R9, R13
   \   000040   5C470300     MOV.B   0x3(R7), R12
   \   000044   ........     CALLA   #?Subroutine18
   2754                  osal_memcpy( dataPtr, pBuf, attrDataLen);
   2755                  statusRec->data = dataPtr;
   2756          
   2757                  pBuf += attrDataLen; // move pass attribute data
   2758          
   2759                  // advance attribute data pointer
   2760                  if ( PADDING_NEEDED( attrDataLen ) )
   2761                  {
   2762                    attrDataLen++;
   2763                  }
   2764          
   2765                  dataPtr += attrDataLen;
   2766                }
   2767              }
   \                     ??zclParseInReadRspCmd_7:
   \   000048   5653         ADD.B   #0x1, R6
   \                     ??zclParseInReadRspCmd_6:
   \   00004A   469B         CMP.B   R11, R6
   \   00004C   F12B         JNC     ??zclParseInReadRspCmd_1
   2768            }
   2769          
   2770            return ( (void *)readRspCmd );
   \                     ??zclParseInReadRspCmd_5:
   \   00004E   ....         JMP     ??Subroutine0_0
   \   000050   0343         NOP
   2771          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine22:
   \   000000   7C49         MOV.B   @R9+, R12
   \   000002   0D49         MOV.W   R9, R13
   \   000004   ........     CALLA   #zclGetAttrDataLength
   \   000008   044C         MOV.W   R12, R4
   \   00000A   095C         ADD.W   R12, R9
   \   00000C   1CB3         BIT.W   #0x1, R12
   \   00000E   0128         JNC     ??Subroutine0_2
   \   000010   1453         ADD.W   #0x1, R4
   \                     ??Subroutine0_2:
   \   000012   0E54         ADD.W   R4, R14
   \   000014   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine18:
   \   000000   ........     CALLA   #zclGetAttrDataLength
   \   000004   044C         MOV.W   R12, R4
   \   000006   0E4C         MOV.W   R12, R14
   \   000008   0D49         MOV.W   R9, R13
   \   00000A   0C4A         MOV.W   R10, R12
   \   00000C   ........     CALLA   #osal_memcpy
   \   000010   874A0400     MOV.W   R10, 0x4(R7)
   \   000014   0954         ADD.W   R4, R9
   \   000016   14B3         BIT.W   #0x1, R4
   \   000018   0128         JNC     ??Subroutine0_1
   \   00001A   1453         ADD.W   #0x1, R4
   \                     ??Subroutine0_1:
   \   00001C   0A54         ADD.W   R4, R10
   \   00001E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine13:
   \   000000   0F46         MOV.W   R6, R15
   \   000002                RPT     #0x5
   \   000002   44180F56     ADDX.W  R6, R15
   \   000006   0748         MOV.W   R8, R7
   \   000008   075F         ADD.W   R15, R7
   \   00000A   2753         ADD.W   #0x2, R7
   \   00000C   ........     CALLA   #?Subroutine50
   \                     ??CrossCallReturnLabel_103:
   \   000010   874E0000     MOV.W   R14, 0(R7)
   \   000014   2953         ADD.W   #0x2, R9
   \   000016   F7490200     MOV.B   @R9+, 0x2(R7)
   \   00001A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine28:
   \   000000   6A43         MOV.B   #0x2, R10
   \   000002                RPT     #0x6
   \   000002   45184A5B     ADDX.B  R11, R10
   \   000006   4C4A         MOV.B   R10, R12
   \   000008   0C5E         ADD.W   R14, R12
   \   00000A                REQUIRE ??Subroutine28_0
   \   00000A                // Fall through to label ??Subroutine28_0
   2772          #endif // ZCL_READ
   2773          
   2774          #ifdef ZCL_WRITE
   2775          /*********************************************************************
   2776           * @fn      zclParseInWriteCmd
   2777           *
   2778           * @brief   Parse the "Profile" Write, Write Undivided and Write No
   2779           *          Response Commands
   2780           *
   2781           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2782           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2783           *
   2784           * @param   pCmd - pointer to incoming data to parse
   2785           *
   2786           * @return  pointer to the parsed command structure
   2787           */

   \                                 In  segment CODE, align 2, keep-with-next
   2788          void *zclParseInWriteCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteCmd:
   \   000000   ....         JMP     ?Subroutine0
   \   000002   0343         NOP
   2789          {
   2790            zclWriteCmd_t *writeCmd;
   2791            uint8 *pBuf = pCmd->pData;
   2792            uint16 attrDataLen;
   2793            uint8 *dataPtr;
   2794            uint8 numAttr = 0;
   2795            uint8 hdrLen;
   2796            uint16 dataLen = 0;
   2797          
   2798            // find out the number of attributes and the length of attribute data
   2799            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2800            {
   2801              uint8 dataType;
   2802          
   2803              numAttr++;
   2804              pBuf += 2; // move pass attribute id
   2805          
   2806              dataType = *pBuf++;
   2807          
   2808              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   2809              pBuf += attrDataLen; // move pass attribute data
   2810          
   2811              // add padding if needed
   2812              if ( PADDING_NEEDED( attrDataLen ) )
   2813              {
   2814                attrDataLen++;
   2815              }
   2816          
   2817              dataLen += attrDataLen;
   2818            }
   2819          
   2820            // calculate the length of the response header
   2821            hdrLen = sizeof( zclWriteCmd_t ) + ( numAttr * sizeof( zclWriteRec_t ) );
   2822          
   2823            writeCmd = (zclWriteCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   2824            if ( writeCmd != NULL )
   2825            {
   2826              pBuf = pCmd->pData;
   2827              dataPtr = (uint8 *)( (uint8 *)writeCmd + hdrLen );
   2828          
   2829              writeCmd->numAttr = numAttr;
   2830              for ( uint8 i = 0; i < numAttr; i++ )
   2831              {
   2832                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   2833          
   2834                statusRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2835                pBuf += 2;
   2836                statusRec->dataType = *pBuf++;
   2837          
   2838                attrDataLen = zclGetAttrDataLength( statusRec->dataType, pBuf );
   2839                osal_memcpy( dataPtr, pBuf, attrDataLen);
   2840                statusRec->attrData = dataPtr;
   2841          
   2842                pBuf += attrDataLen; // move pass attribute data
   2843          
   2844                // advance attribute data pointer
   2845                if ( PADDING_NEEDED( attrDataLen ) )
   2846                {
   2847                  attrDataLen++;
   2848                }
   2849          
   2850                dataPtr += attrDataLen;
   2851              }
   2852            }
   2853          
   2854            return ( (void *)writeCmd );
   2855          }
   2856          
   2857          /*********************************************************************
   2858           * @fn      zclParseInWriteRspCmd
   2859           *
   2860           * @brief   Parse the "Profile" Write Response Commands
   2861           *
   2862           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2863           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2864           *
   2865           * @param   pCmd - pointer to incoming data to parse
   2866           *
   2867           * @return  pointer to the parsed command structure
   2868           */

   \                                 In  segment CODE, align 2, keep-with-next
   2869          static void *zclParseInWriteRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInWriteRspCmd:
   2870          {
   \   000000   3B15         PUSHM.W #0x4, R11
   \   000002   0B4C         MOV.W   R12, R11
   2871            zclWriteRspCmd_t *writeRspCmd;
   2872            uint8 *pBuf = pCmd->pData;
   \   000004   184C0400     MOV.W   0x4(R12), R8
   2873            uint8 i = 0;
   \   000008   4A43         MOV.B   #0x0, R10
   2874          
   2875            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof ( zclWriteRspCmd_t ) + pCmd->dataLen );
   \   00000A   1C4B0200     MOV.W   0x2(R11), R12
   \   00000E   ........     CALLA   #??Subroutine14_0
   2876            if ( writeRspCmd != NULL )
   \                     ??CrossCallReturnLabel_92:
   \   000012   1E24         JEQ     ??zclParseInWriteRspCmd_1
   2877            {
   2878              if ( pCmd->dataLen == 1 )
   \   000014   9B930200     CMP.W   #0x1, 0x2(R11)
   \   000018   1320         JNE     ??zclParseInWriteRspCmd_2
   2879              {
   2880                // special case when all writes were successfull
   2881                writeRspCmd->attrList[i++].status = *pBuf;
   \   00001A   EC480200     MOV.B   @R8, 0x2(R12)
   \   00001E   5A43         MOV.B   #0x1, R10
   \   000020   153C         JMP     ??zclParseInWriteRspCmd_3
   2882              }
   2883              else
   2884              {
   2885                while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2886                {
   2887                  writeRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInWriteRspCmd_0:
   \   000022   4F4A         MOV.B   R10, R15
   \   000024   5F06         RLAM.W  #0x2, R15
   \   000026   0D4C         MOV.W   R12, R13
   \   000028   0D5F         ADD.W   R15, R13
   \   00002A   FD480200     MOV.B   @R8+, 0x2(R13)
   2888                  writeRspCmd->attrList[i++].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   00002E   6E48         MOV.B   @R8, R14
   \   000030   5F480100     MOV.B   0x1(R8), R15
   \   000034   ........     CALLA   #??Subroutine50_0
   \                     ??CrossCallReturnLabel_99:
   \   000038   8D4E0400     MOV.W   R14, 0x4(R13)
   \   00003C   5A53         ADD.B   #0x1, R10
   2889                  pBuf += 2;
   \   00003E   2853         ADD.W   #0x2, R8
   2890                }
   \                     ??zclParseInWriteRspCmd_2:
   \   000040   1F4B0400     MOV.W   0x4(R11), R15
   \   000044   1F5B0200     ADD.W   0x2(R11), R15
   \   000048   089F         CMP.W   R15, R8
   \   00004A   EB2B         JNC     ??zclParseInWriteRspCmd_0
   2891              }
   2892          
   2893              writeRspCmd->numAttr = i;
   \                     ??zclParseInWriteRspCmd_3:
   \   00004C   CC4A0000     MOV.B   R10, 0(R12)
   2894            }
   2895          
   2896            return ( (void *)writeRspCmd );
   \                     ??zclParseInWriteRspCmd_1:
   \   000050   3817         POPM.W  #0x4, R11
   \   000052   1001         RETA
   2897          }
   2898          #endif // ZCL_WRITE
   2899          
   2900          #ifdef ZCL_REPORT
   2901          /*********************************************************************
   2902           * @fn      zclParseInConfigReportCmd
   2903           *
   2904           * @brief   Parse the "Profile" Configure Reporting Command
   2905           *
   2906           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   2907           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   2908           *
   2909           * @param   pCmd - pointer to incoming data to parse
   2910           *
   2911           * @return  pointer to the parsed command structure
   2912           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   0C48         MOV.W   R8, R12
   \   000002   5617         POPM.W  #0x6, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   2913          void *zclParseInConfigReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportCmd:
   2914          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   ........     CALLA   #?Subroutine36
   2915            zclCfgReportCmd_t *cfgReportCmd;
   2916            uint8 *pBuf = pCmd->pData;
   2917            uint8 *dataPtr;
   2918            uint8 numAttr = 0;
   2919            uint8 dataType;
   2920            uint8 hdrLen;
   2921            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_38:
   \   000006   0F43         MOV.W   #0x0, R15
   \   000008   013C         JMP     ??zclParseInConfigReportCmd_1
   2922            uint8 reportChangeLen; // length of Reportable Change field
   2923            
   2924            // Calculate the length of the Request command
   2925            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   2926            {
   2927              uint8 direction;
   2928          
   2929              numAttr++;
   2930              direction = *pBuf++;
   2931              pBuf += 2; // move pass the attribute ID
   2932          
   2933              // Is there a Reportable Change field?
   2934              if ( direction == ZCL_SEND_ATTR_REPORTS )
   2935              {
   2936                dataType = *pBuf++;
   2937                pBuf += 4; // move pass the Min and Max Reporting Intervals
   2938          
   2939                // For attributes of 'discrete' data types this field is omitted
   2940                if ( zclAnalogDataType( dataType ) )
   2941                {
   2942                  reportChangeLen = zclGetDataTypeLength( dataType );
   2943                  pBuf += reportChangeLen;
   2944          
   2945                  // add padding if needed
   2946                  if ( PADDING_NEEDED( reportChangeLen ) )
   2947                  {
   2948                    reportChangeLen++;
   2949                  }
   2950          
   2951                  dataLen += reportChangeLen;
   2952                }
   2953              }
   2954              else
   2955              {
   2956                pBuf += 2; // move pass the Timeout Period
   \                     ??zclParseInConfigReportCmd_0:
   \   00000A   2953         ADD.W   #0x2, R9
   2957              }
   \                     ??zclParseInConfigReportCmd_1:
   \   00000C   1E470400     MOV.W   0x4(R7), R14
   \   000010   1E570200     ADD.W   0x2(R7), R14
   \   000014   099E         CMP.W   R14, R9
   \   000016   0B2C         JC      ??zclParseInConfigReportCmd_6
   \   000018   5B53         ADD.B   #0x1, R11
   \   00001A   7E49         MOV.B   @R9+, R14
   \   00001C   2953         ADD.W   #0x2, R9
   \   00001E   4E93         CMP.B   #0x0, R14
   \   000020   F423         JNE     ??zclParseInConfigReportCmd_0
   \   000022   ........     CALLA   #?Subroutine45
   \                     ??CrossCallReturnLabel_67:
   \   000026   F227         JEQ     ??zclParseInConfigReportCmd_1
   \   000028   ........     CALLA   #?Subroutine20
   2958            } // while loop
   \                     ??CrossCallReturnLabel_15:
   \   00002C   EF3F         JMP     ??zclParseInConfigReportCmd_1
   2959          
   2960            hdrLen = sizeof( zclCfgReportCmd_t ) + ( numAttr * sizeof( zclCfgReportRec_t ) );
   \                     ??zclParseInConfigReportCmd_6:
   \   00002E   6A43         MOV.B   #0x2, R10
   \   000030                RPT     #0xe
   \   000030   4D184A5B     ADDX.B  R11, R10
   2961          
   2962            cfgReportCmd = (zclCfgReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   000034   4C4A         MOV.B   R10, R12
   \   000036   0C5F         ADD.W   R15, R12
   \   000038   ........     CALLA   #??Subroutine28_0
   2963            if ( cfgReportCmd != NULL )
   \                     ??CrossCallReturnLabel_110:
   \   00003C   1E24         JEQ     ??zclParseInConfigReportCmd_7
   2964            {
   2965              pBuf = pCmd->pData;
   \   00003E   ........     CALLA   #?Subroutine7
   2966              dataPtr = (uint8 *)( (uint8 *)cfgReportCmd + hdrLen );
   2967          
   2968              cfgReportCmd->numAttr = numAttr;
   2969              for ( uint8 i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_2:
   \   000042   033C         JMP     ??zclParseInConfigReportCmd_8
   2970              {
   2971                zclCfgReportRec_t *reportRec = &(cfgReportCmd->attrList[i]);
   2972          
   2973                osal_memset( reportRec, 0, sizeof( zclCfgReportRec_t ) );
   2974          
   2975                reportRec->direction = *pBuf++;
   2976                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   2977                pBuf += 2;
   2978                if ( reportRec->direction == ZCL_SEND_ATTR_REPORTS )
   2979                {
   2980                  // Attribute to be reported
   2981                  reportRec->dataType = *pBuf++;
   2982                  reportRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2983                  pBuf += 2;
   2984                  reportRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   2985                  pBuf += 2;
   2986          
   2987                  // For attributes of 'discrete' data types this field is omitted
   2988                  if ( zclAnalogDataType( reportRec->dataType ) )
   2989                  {
   2990                    zcl_BuildAnalogData( reportRec->dataType, dataPtr, pBuf);
   2991                    reportRec->reportableChange = dataPtr;
   2992          
   2993                    reportChangeLen = zclGetDataTypeLength( reportRec->dataType );
   2994                    pBuf += reportChangeLen;
   2995          
   2996                    // advance attribute data pointer
   2997                    if ( PADDING_NEEDED( reportChangeLen ) )
   2998                    {
   2999                      reportChangeLen++;
   3000                    }
   3001          
   3002                    dataPtr += reportChangeLen;
   3003                  }
   3004                }
   3005                else
   3006                {
   3007                  // Attribute reports to be received
   3008                  reportRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInConfigReportCmd_2:
   \   000044   ........     CALLA   #?Subroutine16
   3009                  pBuf += 2;
   3010                }
   \                     ??zclParseInConfigReportCmd_3:
   \   000048   5653         ADD.B   #0x1, R6
   \                     ??zclParseInConfigReportCmd_8:
   \   00004A   469B         CMP.B   R11, R6
   \   00004C   162C         JC      ??zclParseInConfigReportCmd_7
   \   00004E   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_41:
   \   000052   3E400E00     MOV.W   #0xe, R14
   \   000056   4D43         MOV.B   #0x0, R13
   \   000058   0C47         MOV.W   R7, R12
   \   00005A   ........     CALLA   #osal_memset
   \   00005E   F7490000     MOV.B   @R9+, 0(R7)
   \   000062   ........     CALLA   #?Subroutine17
   \                     ??CrossCallReturnLabel_10:
   \   000066   6C49         MOV.B   @R9, R12
   \   000068   C7930000     CMP.B   #0x0, 0(R7)
   \   00006C   EB23         JNE     ??zclParseInConfigReportCmd_2
   \   00006E   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_65:
   \   000072   EA27         JEQ     ??zclParseInConfigReportCmd_3
   \   000074   ........     CALLA   #?Subroutine21
   3011              } // while loop
   3012            }
   \                     ??CrossCallReturnLabel_17:
   \   000078   E73F         JMP     ??zclParseInConfigReportCmd_3
   3013          
   3014            return ( (void *)cfgReportCmd );
   \                     ??zclParseInConfigReportCmd_7:
   \   00007A   ....         JMP     ?Subroutine4
   \   00007C   0343         NOP
   3015          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine45:
   \   000000   7E49         MOV.B   @R9+, R14
   \   000002   2952         ADD.W   #0x4, R9
   \   000004   4C4E         MOV.B   R14, R12
   \   000006                REQUIRE ?Subroutine56
   \   000006                // Fall through to label ?Subroutine56

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine38:
   \   000000   0F46         MOV.W   R6, R15
   \   000002                RPT     #0xd
   \   000002   4C180F56     ADDX.W  R6, R15
   \   000006   0748         MOV.W   R8, R7
   \   000008   075F         ADD.W   R15, R7
   \   00000A   2753         ADD.W   #0x2, R7
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine21:
   \   000000   0E49         MOV.W   R9, R14
   \   000002   0D4A         MOV.W   R10, R13
   \   000004   5C470400     MOV.B   0x4(R7), R12
   \   000008   ........     CALLA   #zcl_BuildAnalogData
   \   00000C   874A0C00     MOV.W   R10, 0xc(R7)
   \   000010   5C470400     MOV.B   0x4(R7), R12
   \   000014   ........     CALLA   #?Subroutine51
   \                     ??CrossCallReturnLabel_55:
   \   000018   0A5C         ADD.W   R12, R10
   \   00001A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine20:
   \   000000   4C4E         MOV.B   R14, R12
   \   000002   ........     CALLA   #?Subroutine51
   \                     ??CrossCallReturnLabel_56:
   \   000006   0F5C         ADD.W   R12, R15
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine51:
   \   000000   ........     CALLA   #zclGetDataTypeLength
   \   000004   4C4C         MOV.B   R12, R12
   \   000006   095C         ADD.W   R12, R9
   \   000008   5CB3         BIT.B   #0x1, R12
   \   00000A   0128         JNC     ??zclParseInReadReportCfgRspCmd_5
   \   00000C   5C53         ADD.B   #0x1, R12
   \                     ??zclParseInReadReportCfgRspCmd_5:
   \   00000E   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine17:
   \   000000   ........     CALLA   #?Subroutine50
   \                     ??CrossCallReturnLabel_104:
   \   000004   874E0200     MOV.W   R14, 0x2(R7)
   \   000008   2953         ADD.W   #0x2, R9
   \   00000A   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine16:
   \   000000   5F490100     MOV.B   0x1(R9), R15
   \   000004                RPT     #0x8
   \   000004   47180F5F     RLAX.W  R15
   \   000008   0C5F         ADD.W   R15, R12
   \   00000A   874C0A00     MOV.W   R12, 0xa(R7)
   \   00000E   2953         ADD.W   #0x2, R9
   \   000010   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine12:
   \   000000   F7490400     MOV.B   @R9+, 0x4(R7)
   \   000004   ........     CALLA   #?Subroutine50
   \                     ??CrossCallReturnLabel_101:
   \   000008   874E0600     MOV.W   R14, 0x6(R7)
   \   00000C   2953         ADD.W   #0x2, R9
   \   00000E   ........     CALLA   #?Subroutine50
   \                     ??CrossCallReturnLabel_102:
   \   000012   874E0800     MOV.W   R14, 0x8(R7)
   \   000016   2953         ADD.W   #0x2, R9
   \   000018   ....         JMP     ?Subroutine56
   \   00001A   0343         NOP
   3016          
   3017          /*********************************************************************
   3018           * @fn      zclParseInConfigReportRspCmd
   3019           *
   3020           * @brief   Parse the "Profile" Configure Reporting Response Command
   3021           *
   3022           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3023           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3024           *
   3025           * @param   pCmd - pointer to incoming data to parse
   3026           *
   3027           * @return  pointer to the parsed command structure
   3028           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine14:
   \   000000   4C4A         MOV.B   R10, R12
   \   000002   5C06         RLAM.W  #0x2, R12
   \   000004                REQUIRE ?Subroutine52
   \   000004                REQUIRE ??Subroutine14_0
   \   000004                // Fall through to label ??Subroutine14_0

   \                                 In  segment CODE, align 2, keep-with-next
   3029          static void *zclParseInConfigReportRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInConfigReportRspCmd:
   3030          {
   \   000000   1B15         PUSHM.W #0x2, R11
   3031            zclCfgReportRspCmd_t *cfgReportRspCmd;
   3032            uint8 *pBuf = pCmd->pData;
   \   000002   1B4C0400     MOV.W   0x4(R12), R11
   3033            uint8 numAttr;
   3034            
   3035            numAttr = pCmd->dataLen / ( 1 + 1 + 2 ); // Status + Direction + Attribute ID
   \   000006   1A4C0200     MOV.W   0x2(R12), R10
   \   00000A   5A07         RRUM.W  #0x2, R10
   3036          
   3037            cfgReportRspCmd = (zclCfgReportRspCmd_t *)osal_mem_alloc( sizeof( zclCfgReportRspCmd_t )
   3038                                                      + ( numAttr * sizeof( zclCfgReportStatus_t ) ) );
   \   00000C   ........     CALLA   #?Subroutine14
   3039            if ( cfgReportRspCmd != NULL )
   \                     ??CrossCallReturnLabel_93:
   \   000010   0C24         JEQ     ??zclParseInConfigReportRspCmd_1
   3040            {
   3041              cfgReportRspCmd->numAttr = numAttr;
   \   000012   CC4A0000     MOV.B   R10, 0(R12)
   3042              for ( uint8 i = 0; i < cfgReportRspCmd->numAttr; i++ )
   \   000016   4E43         MOV.B   #0x0, R14
   \   000018   063C         JMP     ??zclParseInConfigReportRspCmd_2
   3043              {
   3044                cfgReportRspCmd->attrList[i].status = *pBuf++;
   \                     ??zclParseInConfigReportRspCmd_0:
   \   00001A   ........     CALLA   #?Subroutine47
   3045                cfgReportRspCmd->attrList[i].direction = *pBuf++;
   \                     ??CrossCallReturnLabel_52:
   \   00001E   FA4B0300     MOV.B   @R11+, 0x3(R10)
   3046                cfgReportRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \   000022   ........     CALLA   #?Subroutine15
   3047                pBuf += 2;
   3048              }
   \                     ??zclParseInConfigReportRspCmd_2:
   \   000026   6E9C         CMP.B   @R12, R14
   \   000028   F82B         JNC     ??zclParseInConfigReportRspCmd_0
   3049            }
   3050          
   3051            return ( (void *)cfgReportRspCmd );
   \                     ??zclParseInConfigReportRspCmd_1:
   \   00002A   1A17         POPM.W  #0x2, R11
   \   00002C   1001         RETA
   3052          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine47:
   \   000000   4F4E         MOV.B   R14, R15
   \   000002   5F06         RLAM.W  #0x2, R15
   \   000004   0A4C         MOV.W   R12, R10
   \   000006   0A5F         ADD.W   R15, R10
   \   000008   FA4B0200     MOV.B   @R11+, 0x2(R10)
   \   00000C   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine15:
   \   000000   6D4B         MOV.B   @R11, R13
   \   000002   5F4B0100     MOV.B   0x1(R11), R15
   \   000006                RPT     #0x8
   \   000006   47180F5F     RLAX.W  R15
   \   00000A   0D5F         ADD.W   R15, R13
   \   00000C   8A4D0400     MOV.W   R13, 0x4(R10)
   \   000010   2B53         ADD.W   #0x2, R11
   \   000012   5E53         ADD.B   #0x1, R14
   \   000014   1001         RETA
   3053          
   3054          /*********************************************************************
   3055           * @fn      zclParseInReadReportCfgCmd
   3056           *
   3057           * @brief   Parse the "Profile" Read Reporting Configuration Command
   3058           *
   3059           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3060           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3061           *
   3062           * @param   pCmd - pointer to incoming data to parse
   3063           *
   3064           * @return  pointer to the parsed command structure
   3065           */

   \                                 In  segment CODE, align 2, keep-with-next
   3066          void *zclParseInReadReportCfgCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgCmd:
   3067          {
   \   000000   1B15         PUSHM.W #0x2, R11
   3068            zclReadReportCfgCmd_t *readReportCfgCmd;
   3069            uint8 *pBuf = pCmd->pData;
   \   000002   1B4C0400     MOV.W   0x4(R12), R11
   3070            uint8 numAttr;
   3071            
   3072            numAttr = pCmd->dataLen / ( 1 + 2 ); // Direction + Attribute ID
   \   000006   1C4C0200     MOV.W   0x2(R12), R12
   \   00000A   3E400300     MOV.W   #0x3, R14
   \   00000E   ........     CALLA   #?DivMod16u
   \   000012   4A4C         MOV.B   R12, R10
   3073          
   3074            readReportCfgCmd = (zclReadReportCfgCmd_t *)osal_mem_alloc( sizeof( zclReadReportCfgCmd_t )
   3075                                                            + ( numAttr * sizeof( zclReadReportCfgRec_t ) ) );
   \   000014   ........     CALLA   #?Subroutine14
   3076            if ( readReportCfgCmd != NULL )
   \                     ??CrossCallReturnLabel_94:
   \   000018   0A24         JEQ     ??zclParseInReadReportCfgCmd_1
   3077            {
   3078              readReportCfgCmd->numAttr = numAttr;
   \   00001A   CC4A0000     MOV.B   R10, 0(R12)
   3079              for ( uint8 i = 0; i < readReportCfgCmd->numAttr; i++)
   \   00001E   4E43         MOV.B   #0x0, R14
   \   000020   043C         JMP     ??zclParseInReadReportCfgCmd_2
   3080              {
   3081                readReportCfgCmd->attrList[i].direction = *pBuf++;;
   \                     ??zclParseInReadReportCfgCmd_0:
   \   000022   ........     CALLA   #?Subroutine47
   3082                readReportCfgCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??CrossCallReturnLabel_51:
   \   000026   ........     CALLA   #?Subroutine15
   3083                pBuf += 2;
   3084              }
   \                     ??zclParseInReadReportCfgCmd_2:
   \   00002A   6E9C         CMP.B   @R12, R14
   \   00002C   FA2B         JNC     ??zclParseInReadReportCfgCmd_0
   3085            }
   3086          
   3087            return ( (void *)readReportCfgCmd );
   \                     ??zclParseInReadReportCfgCmd_1:
   \   00002E   1A17         POPM.W  #0x2, R11
   \   000030   1001         RETA
   3088          }
   3089          
   3090          /*********************************************************************
   3091           * @fn      zclParseInReadReportCfgRspCmd
   3092           *
   3093           * @brief   Parse the "Profile" Read Reporting Configuration Response Command
   3094           *
   3095           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3096           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3097           *
   3098           * @param   pCmd - pointer to incoming data to parse
   3099           *
   3100           * @return  pointer to the parsed command structure
   3101           */

   \                                 In  segment CODE, align 2, keep-with-next
   3102          static void *zclParseInReadReportCfgRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReadReportCfgRspCmd:
   3103          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   ........     CALLA   #?Subroutine36
   3104            zclReadReportCfgRspCmd_t *readReportCfgRspCmd;
   3105            uint8 reportChangeLen;
   3106            uint8 *pBuf = pCmd->pData;
   3107            uint8 *dataPtr;
   3108            uint8 numAttr = 0;
   3109            uint8 hdrLen;
   3110            uint16 dataLen = 0;
   \                     ??CrossCallReturnLabel_37:
   \   000006   0F43         MOV.W   #0x0, R15
   \   000008   013C         JMP     ??zclParseInReadReportCfgRspCmd_0
   3111            
   3112            // Calculate the length of the response command
   3113            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3114            {
   3115              uint8 status;
   3116              uint8 direction;
   3117          
   3118              numAttr++;
   3119              status = *pBuf++;
   3120              direction = *pBuf++;
   3121              pBuf += 2; // move pass the attribute ID
   3122          
   3123              if ( status == ZCL_STATUS_SUCCESS )
   3124              {
   3125                if ( direction == ZCL_SEND_ATTR_REPORTS )
   3126                {
   3127                  uint8 dataType = *pBuf++;
   3128                  pBuf += 4; // move pass the Min and Max Reporting Intervals
   3129          
   3130                  // For attributes of 'discrete' data types this field is omitted
   3131                  if ( zclAnalogDataType( dataType ) )
   3132                  {
   3133                    reportChangeLen = zclGetDataTypeLength( dataType );
   3134                    pBuf += reportChangeLen;
   3135          
   3136                    // add padding if needed
   3137                    if ( PADDING_NEEDED( reportChangeLen ) )
   3138                    {
   3139                      reportChangeLen++;
   3140                    }
   3141          
   3142                    dataLen += reportChangeLen;
   3143                  }
   3144                }
   3145                else
   3146                {
   3147                  pBuf += 2; // move pass the Timeout field
   \                     ??zclParseInReadReportCfgRspCmd_1:
   \   00000A   2953         ADD.W   #0x2, R9
   3148                }
   \                     ??zclParseInReadReportCfgRspCmd_0:
   \   00000C   1E470400     MOV.W   0x4(R7), R14
   \   000010   1E570200     ADD.W   0x2(R7), R14
   \   000014   099E         CMP.W   R14, R9
   \   000016   0E2C         JC      ??zclParseInReadReportCfgRspCmd_6
   \   000018   5B53         ADD.B   #0x1, R11
   \   00001A   7E49         MOV.B   @R9+, R14
   \   00001C   7D49         MOV.B   @R9+, R13
   \   00001E   2953         ADD.W   #0x2, R9
   \   000020   4E93         CMP.B   #0x0, R14
   \   000022   F423         JNE     ??zclParseInReadReportCfgRspCmd_0
   \   000024   4D93         CMP.B   #0x0, R13
   \   000026   F123         JNE     ??zclParseInReadReportCfgRspCmd_1
   \   000028   ........     CALLA   #?Subroutine45
   \                     ??CrossCallReturnLabel_66:
   \   00002C   EF27         JEQ     ??zclParseInReadReportCfgRspCmd_0
   \   00002E   ........     CALLA   #?Subroutine20
   3149              }
   3150            } // while loop
   \                     ??CrossCallReturnLabel_14:
   \   000032   EC3F         JMP     ??zclParseInReadReportCfgRspCmd_0
   3151          
   3152            hdrLen = sizeof( zclReadReportCfgRspCmd_t ) + ( numAttr * sizeof( zclReportCfgRspRec_t ) );
   \                     ??zclParseInReadReportCfgRspCmd_6:
   \   000034   6A43         MOV.B   #0x2, R10
   \   000036                RPT     #0xe
   \   000036   4D184A5B     ADDX.B  R11, R10
   3153          
   3154            readReportCfgRspCmd = (zclReadReportCfgRspCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   \   00003A   4C4A         MOV.B   R10, R12
   \   00003C   0C5F         ADD.W   R15, R12
   \   00003E   ........     CALLA   #??Subroutine28_0
   3155            if ( readReportCfgRspCmd != NULL )
   \                     ??CrossCallReturnLabel_109:
   \   000042   1D24         JEQ     ??zclParseInReadReportCfgRspCmd_7
   3156            {
   3157              pBuf = pCmd->pData;
   \   000044   ........     CALLA   #?Subroutine7
   3158              dataPtr = (uint8 *)( (uint8 *)readReportCfgRspCmd + hdrLen );
   3159          
   3160              readReportCfgRspCmd->numAttr = numAttr;
   3161              for ( uint8 i = 0; i < numAttr; i++ )
   \                     ??CrossCallReturnLabel_1:
   \   000048   033C         JMP     ??zclParseInReadReportCfgRspCmd_8
   3162              {
   3163                zclReportCfgRspRec_t *reportRspRec = &(readReportCfgRspCmd->attrList[i]);
   3164          
   3165                reportRspRec->status = *pBuf++;
   3166                reportRspRec->direction = *pBuf++;
   3167                reportRspRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3168                pBuf += 2;
   3169          
   3170                if ( reportRspRec->status == ZCL_STATUS_SUCCESS )
   3171                {
   3172                  if ( reportRspRec->direction == ZCL_SEND_ATTR_REPORTS )
   3173                  {
   3174                    reportRspRec->dataType = *pBuf++;
   3175                    reportRspRec->minReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3176                    pBuf += 2;
   3177                    reportRspRec->maxReportInt = BUILD_UINT16( pBuf[0], pBuf[1] );
   3178                    pBuf += 2;
   3179          
   3180                    if ( zclAnalogDataType( reportRspRec->dataType ) )
   3181                    {
   3182                      zcl_BuildAnalogData( reportRspRec->dataType, dataPtr, pBuf);
   3183                      reportRspRec->reportableChange = dataPtr;
   3184          
   3185                      reportChangeLen = zclGetDataTypeLength( reportRspRec->dataType );
   3186                      pBuf += reportChangeLen;
   3187          
   3188                      // advance attribute data pointer
   3189                      if ( PADDING_NEEDED( reportChangeLen ) )
   3190                      {
   3191                        reportChangeLen++;
   3192                      }
   3193          
   3194                      dataPtr += reportChangeLen;
   3195                    }
   3196                  }
   3197                  else
   3198                  {
   3199                    reportRspRec->timeoutPeriod = BUILD_UINT16( pBuf[0], pBuf[1] );
   \                     ??zclParseInReadReportCfgRspCmd_3:
   \   00004A   ........     CALLA   #?Subroutine16
   3200                    pBuf += 2;
   3201                  }
   \                     ??zclParseInReadReportCfgRspCmd_2:
   \   00004E   5653         ADD.B   #0x1, R6
   \                     ??zclParseInReadReportCfgRspCmd_8:
   \   000050   469B         CMP.B   R11, R6
   \   000052   152C         JC      ??zclParseInReadReportCfgRspCmd_7
   \   000054   ........     CALLA   #?Subroutine38
   \                     ??CrossCallReturnLabel_40:
   \   000058   F7490000     MOV.B   @R9+, 0(R7)
   \   00005C   F7490100     MOV.B   @R9+, 0x1(R7)
   \   000060   ........     CALLA   #?Subroutine17
   \                     ??CrossCallReturnLabel_9:
   \   000064   C7930000     CMP.B   #0x0, 0(R7)
   \   000068   F223         JNE     ??zclParseInReadReportCfgRspCmd_2
   \   00006A   6C49         MOV.B   @R9, R12
   \   00006C   C7930100     CMP.B   #0x0, 0x1(R7)
   \   000070   EC23         JNE     ??zclParseInReadReportCfgRspCmd_3
   \   000072   ........     CALLA   #?Subroutine12
   \                     ??CrossCallReturnLabel_64:
   \   000076   EB27         JEQ     ??zclParseInReadReportCfgRspCmd_2
   \   000078   ........     CALLA   #?Subroutine21
   3202                }
   3203              }
   3204            }
   \                     ??CrossCallReturnLabel_16:
   \   00007C   E83F         JMP     ??zclParseInReadReportCfgRspCmd_2
   3205          
   3206            return ( (void *)readReportCfgRspCmd );
   \                     ??zclParseInReadReportCfgRspCmd_7:
   \   00007E                REQUIRE ?Subroutine4
   \   00007E                // Fall through to label ?Subroutine4
   3207          }
   3208          
   3209          /*********************************************************************
   3210           * @fn      zclParseInReportCmd
   3211           *
   3212           * @brief   Parse the "Profile" Report Command
   3213           *
   3214           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3215           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3216           *
   3217           * @param   pCmd - pointer to incoming data to parse
   3218           *
   3219           * @return  pointer to the parsed command structure
   3220           */

   \                                 In  segment CODE, align 2, keep-with-next
   3221          void *zclParseInReportCmd( zclParseCmd_t *pCmd )
   \                     zclParseInReportCmd:
   \   000000                REQUIRE ?Subroutine0
   \   000000                // Fall through to label ?Subroutine0
   3222          {
   3223            zclReportCmd_t *reportCmd;
   3224            uint8 *pBuf = pCmd->pData;
   3225            uint16 attrDataLen;
   3226            uint8 *dataPtr;
   3227            uint8 numAttr = 0;
   3228            uint8 hdrLen;
   3229            uint16 dataLen = 0;
   3230          
   3231            // find out the number of attributes and the length of attribute data
   3232            while ( pBuf < ( pCmd->pData + pCmd->dataLen ) )
   3233            {
   3234              uint8 dataType;
   3235          
   3236              numAttr++;
   3237              pBuf += 2; // move pass attribute id
   3238          
   3239              dataType = *pBuf++;
   3240          
   3241              attrDataLen = zclGetAttrDataLength( dataType, pBuf );
   3242              pBuf += attrDataLen; // move pass attribute data
   3243          
   3244              // add padding if needed
   3245              if ( PADDING_NEEDED( attrDataLen ) )
   3246              {
   3247                attrDataLen++;
   3248              }
   3249          
   3250              dataLen += attrDataLen;
   3251            }
   3252          
   3253            hdrLen = sizeof( zclReportCmd_t ) + ( numAttr * sizeof( zclReport_t ) );
   3254          
   3255            reportCmd = (zclReportCmd_t *)osal_mem_alloc( hdrLen + dataLen );
   3256            if (reportCmd != NULL )
   3257            {
   3258              pBuf = pCmd->pData;
   3259              dataPtr = (uint8 *)( (uint8 *)reportCmd + hdrLen );
   3260          
   3261              reportCmd->numAttr = numAttr;
   3262              for ( uint8 i = 0; i < numAttr; i++ )
   3263              {
   3264                zclReport_t *reportRec = &(reportCmd->attrList[i]);
   3265          
   3266                reportRec->attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3267                pBuf += 2;
   3268                reportRec->dataType = *pBuf++;
   3269          
   3270                attrDataLen = zclGetAttrDataLength( reportRec->dataType, pBuf );
   3271                osal_memcpy( dataPtr, pBuf, attrDataLen );
   3272                reportRec->attrData = dataPtr;
   3273          
   3274                pBuf += attrDataLen; // move pass attribute data
   3275          
   3276                // advance attribute data pointer
   3277                if ( PADDING_NEEDED( attrDataLen ) )
   3278                {
   3279                  attrDataLen++;
   3280                }
   3281          
   3282                dataPtr += attrDataLen;
   3283              }
   3284            }
   3285          
   3286            return ( (void *)reportCmd );
   3287          }
   3288          #endif // ZCL_REPORT
   3289          
   3290          /*********************************************************************
   3291           * @fn      zclParseInDefaultRspCmd
   3292           *
   3293           * @brief   Parse the "Profile" Default Response Command
   3294           *
   3295           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3296           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3297           *
   3298           * @param   pCmd - pointer to incoming data to parse
   3299           *
   3300           * @return  pointer to the parsed command structure
   3301           */

   \                                 In  segment CODE, align 2, keep-with-next
   3302          static void *zclParseInDefaultRspCmd( zclParseCmd_t *pCmd )
   \                     zclParseInDefaultRspCmd:
   3303          {
   \   000000   0A12         PUSH.W  R10
   3304            zclDefaultRspCmd_t *defaultRspCmd;
   3305            uint8 *pBuf = pCmd->pData;
   \   000002   1A4C0400     MOV.W   0x4(R12), R10
   3306          
   3307            defaultRspCmd = (zclDefaultRspCmd_t *)osal_mem_alloc( sizeof ( zclDefaultRspCmd_t ) );
   \   000006   2C43         MOV.W   #0x2, R12
   \   000008   ........     CALLA   #?Subroutine52
   3308            if ( defaultRspCmd != NULL )
   \                     ??CrossCallReturnLabel_90:
   \   00000C   0424         JEQ     ??zclParseInDefaultRspCmd_0
   3309            {
   3310              defaultRspCmd->commandID = *pBuf++;
   \   00000E   FC4A0000     MOV.B   @R10+, 0(R12)
   3311              defaultRspCmd->statusCode = *pBuf;
   \   000012   EC4A0100     MOV.B   @R10, 0x1(R12)
   3312            }
   3313          
   3314            return ( (void *)defaultRspCmd );
   \                     ??zclParseInDefaultRspCmd_0:
   \   000016   3A41         POP.W   R10
   \   000018   1001         RETA
   3315          }
   3316          
   3317          #ifdef ZCL_DISCOVER
   3318          /*********************************************************************
   3319           * @fn      zclParseInDiscCmd
   3320           *
   3321           * @brief   Parse the "Profile" Discovery Commands
   3322           *
   3323           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3324           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3325           *
   3326           * @param   pCmd - pointer to incoming data to parse
   3327           *
   3328           * @return  pointer to the parsed command structure
   3329           */
   3330          void *zclParseInDiscCmd( zclParseCmd_t *pCmd )
   3331          {
   3332            zclDiscoverCmd_t *discoverCmd;
   3333            uint8 *pBuf = pCmd->pData;
   3334          
   3335            discoverCmd = (zclDiscoverCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverCmd_t ) );
   3336            if ( discoverCmd != NULL )
   3337            {
   3338              discoverCmd->startAttr = BUILD_UINT16( pBuf[0], pBuf[1] );
   3339              pBuf += 2;
   3340              discoverCmd->maxAttrIDs = *pBuf;
   3341            }
   3342          
   3343            return ( (void *)discoverCmd );
   3344          }
   3345          
   3346          /*********************************************************************
   3347           * @fn      zclParseInDiscRspCmd
   3348           *
   3349           * @brief   Parse the "Profile" Discovery Response Commands
   3350           *
   3351           *      NOTE: THIS FUNCTION ALLOCATES THE RETURN BUFFER, SO THE CALLING
   3352           *            FUNCTION IS RESPONSIBLE TO FREE THE MEMORY.
   3353           *
   3354           * @param   pCmd - pointer to incoming data to parse
   3355           *
   3356           * @return  pointer to the parsed command structure
   3357           */
   3358          #define ZCLDISCRSPCMD_DATALEN(a)  ((a)-1) // data len - Discovery Complete
   3359          static void *zclParseInDiscRspCmd( zclParseCmd_t *pCmd )
   3360          {
   3361            zclDiscoverRspCmd_t *discoverRspCmd;
   3362            uint8 *pBuf = pCmd->pData;
   3363            uint8 numAttr = ZCLDISCRSPCMD_DATALEN(pCmd->dataLen) / ( 2 + 1 ); // Attr ID + Data Type
   3364          
   3365            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof ( zclDiscoverRspCmd_t )
   3366                                                           + ( numAttr * sizeof(zclDiscoverInfo_t) ) );
   3367            if ( discoverRspCmd != NULL )
   3368            {
   3369              discoverRspCmd->discComplete = *pBuf++;
   3370              discoverRspCmd->numAttr = numAttr;
   3371              
   3372              for ( uint8 i = 0; i < numAttr; i++ )
   3373              {
   3374                discoverRspCmd->attrList[i].attrID = BUILD_UINT16( pBuf[0], pBuf[1] );
   3375                pBuf += 2;
   3376                discoverRspCmd->attrList[i].dataType = *pBuf++;;
   3377              }
   3378            }
   3379          
   3380            return ( (void *)discoverRspCmd );
   3381          }
   3382          #endif // ZCL_DISCOVER
   3383          
   3384          #ifdef ZCL_READ
   3385          /*********************************************************************
   3386           * @fn      zclProcessInReadCmd
   3387           *
   3388           * @brief   Process the "Profile" Read Command
   3389           *
   3390           * @param   pInMsg - incoming message to process
   3391           *
   3392           * @return  TRUE if command processed. FALSE, otherwise.
   3393           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   3152         ADD.W   #0x8, SP
   \   000002   7417         POPM.W  #0x8, R11
   \   000004   1001         RETA

   \                                 In  segment CODE, align 2, keep-with-next
   3394          static uint8 zclProcessInReadCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInReadCmd:
   3395          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   084C         MOV.W   R12, R8
   3396            zclReadCmd_t *readCmd;
   3397            zclReadRspCmd_t *readRspCmd;
   3398            zclAttrRec_t attrRec;
   3399            uint16 len;
   3400            
   3401            readCmd = (zclReadCmd_t *)pInMsg->attrCmd;
   \   000006   174C0C00     MOV.W   0xc(R12), R7
   3402          
   3403            // calculate the length of the response status record
   3404            len = sizeof( zclReadRspCmd_t ) + (readCmd->numAttr * sizeof( zclReadRspStatus_t ));
   3405          
   3406            readRspCmd = osal_mem_alloc( len );
   \   00000A   6F47         MOV.B   @R7, R15
   \   00000C   2C43         MOV.W   #0x2, R12
   \   00000E                RPT     #0x6
   \   00000E   45180C5F     ADDX.W  R15, R12
   \   000012   ........     CALLA   #osal_mem_alloc
   \   000016   064C         MOV.W   R12, R6
   3407            if ( readRspCmd == NULL )
   \   000018   0C93         CMP.W   #0x0, R12
   \   00001A   0220         JNE     ??zclProcessInReadCmd_2
   3408            {
   3409              return FALSE; // EMBEDDED RETURN
   \   00001C   4C43         MOV.B   #0x0, R12
   \   00001E   5C3C         JMP     ??zclProcessInReadCmd_3
   3410            }
   3411          
   3412            readRspCmd->numAttr = readCmd->numAttr;
   \                     ??zclProcessInReadCmd_2:
   \   000020   EC470000     MOV.B   @R7, 0(R12)
   3413            for ( uint8 i = 0; i < readCmd->numAttr; i++ )
   \   000024   4443         MOV.B   #0x0, R4
   \   000026   043C         JMP     ??zclProcessInReadCmd_4
   3414            {
   3415              zclReadRspStatus_t *statusRec = &(readRspCmd->attrList[i]);
   3416          
   3417              statusRec->attrID = readCmd->attrID[i];
   3418          
   3419              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3420                                   readCmd->attrID[i], &attrRec ) )
   3421              {
   3422                if ( zcl_AccessCtrlRead( attrRec.attr.accessControl ) )
   3423                {
   3424                  statusRec->status = zclAuthorizeRead( pInMsg->msg->endPoint, 
   3425                                                        &(pInMsg->msg->srcAddr), &attrRec );
   3426                  if ( statusRec->status == ZCL_STATUS_SUCCESS )
   3427                  {
   3428                    statusRec->data = attrRec.attr.dataPtr;
   3429                    statusRec->dataType = attrRec.attr.dataType;
   3430                  }
   3431                }
   3432                else
   3433                {
   3434                  statusRec->status = ZCL_STATUS_WRITE_ONLY;
   3435                }
   3436              }
   3437              else
   3438              {
   3439                statusRec->status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \                     ??zclProcessInReadCmd_0:
   \   000028   F94086000200 MOV.B   #0x86, 0x2(R9)
   3440              }
   \                     ??zclProcessInReadCmd_1:
   \   00002E   5453         ADD.B   #0x1, R4
   \                     ??zclProcessInReadCmd_4:
   \   000030   6497         CMP.B   @R7, R4
   \   000032   3D2C         JC      ??zclProcessInReadCmd_5
   \   000034   4F44         MOV.B   R4, R15
   \   000036   0B4F         MOV.W   R15, R11
   \   000038                RPT     #0x5
   \   000038   44180B5F     ADDX.W  R15, R11
   \   00003C   0946         MOV.W   R6, R9
   \   00003E   095B         ADD.W   R11, R9
   \   000040   2953         ADD.W   #0x2, R9
   \   000042   0F5F         RLA.W   R15
   \   000044   0B47         MOV.W   R7, R11
   \   000046   0B5F         ADD.W   R15, R11
   \   000048   2B53         ADD.W   #0x2, R11
   \   00004A   A94B0000     MOV.W   @R11, 0(R9)
   \   00004E   2A48         MOV.W   @R8, R10
   \   000050   0F41         MOV.W   SP, R15
   \   000052   2E4B         MOV.W   @R11, R14
   \   000054   1D4A0400     MOV.W   0x4(R10), R13
   \   000058   5C4A1400     MOV.B   0x14(R10), R12
   \   00005C   ........     CALLA   #??Subroutine23_0
   \                     ??CrossCallReturnLabel_89:
   \   000060   E327         JEQ     ??zclProcessInReadCmd_0
   \   000062   D1B30500     BIT.B   #0x1, 0x5(SP)
   \   000066   1F28         JNC     ??zclProcessInReadCmd_6
   \   000068   2F48         MOV.W   @R8, R15
   \   00006A   054F         MOV.W   R15, R5
   \   00006C   35500600     ADD.W   #0x6, R5
   \   000070   F1B010000500 BIT.B   #0x10, 0x5(SP)
   \   000076   0B28         JNC     ??zclProcessInReadCmd_7
   \   000078   5C4F1400     MOV.B   0x14(R15), R12
   \   00007C   ........     CALLA   #?Subroutine6
   \                     ??CrossCallReturnLabel_81:
   \   000080   0624         JEQ     ??zclProcessInReadCmd_7
   \   000082   5E43         MOV.B   #0x1, R14
   \   000084   0D41         MOV.W   SP, R13
   \   000086   0C45         MOV.W   R5, R12
   \   000088   ........     CALLA   #?IndCallR11
   \   00008C   013C         JMP     ??zclProcessInReadCmd_8
   \                     ??zclProcessInReadCmd_7:
   \   00008E   4C43         MOV.B   #0x0, R12
   \                     ??zclProcessInReadCmd_8:
   \   000090   C94C0200     MOV.B   R12, 0x2(R9)
   \   000094   4C93         CMP.B   #0x0, R12
   \   000096   CB23         JNE     ??zclProcessInReadCmd_1
   \   000098   994106000400 MOV.W   0x6(SP), 0x4(R9)
   \   00009E   D94104000300 MOV.B   0x4(SP), 0x3(R9)
   \   0000A4   C43F         JMP     ??zclProcessInReadCmd_1
   \                     ??zclProcessInReadCmd_6:
   \   0000A6   F9408F000200 MOV.B   #0x8f, 0x2(R9)
   \   0000AC   C03F         JMP     ??zclProcessInReadCmd_1
   3441            }
   3442          
   3443            // Build and send Read Response command
   3444            zcl_SendReadRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), pInMsg->msg->clusterId,
   3445                             readRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3446                             true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInReadCmd_5:
   \   0000AE   2A48         MOV.W   @R8, R10
   \   0000B0   58120600     PUSH.B  0x6(R8)
   \   0000B4   5312         PUSH.B  #0x1
   \   0000B6   5312         PUSH.B  #0x1
   \   0000B8   0F46         MOV.W   R6, R15
   \   0000BA   1E4A0400     MOV.W   0x4(R10), R14
   \   0000BE   0D4A         MOV.W   R10, R13
   \   0000C0   3D500600     ADD.W   #0x6, R13
   \   0000C4   5C4A1400     MOV.B   0x14(R10), R12
   \   0000C8   ........     CALLA   #zcl_SendReadRsp
   3447            osal_mem_free( readRspCmd );
   \   0000CC   0C46         MOV.W   R6, R12
   \   0000CE   ........     CALLA   #osal_mem_free
   3448          
   3449            return TRUE;
   \   0000D2   5C43         MOV.B   #0x1, R12
   \   0000D4   31500600     ADD.W   #0x6, SP
   \                     ??zclProcessInReadCmd_3:
   \   0000D8   ....         JMP     ?Subroutine3
   \   0000DA   0343         NOP
   3450          }
   3451          #endif // ZCL_READ
   3452          
   3453          #ifdef ZCL_WRITE
   3454          /*********************************************************************
   3455           * @fn      processInWriteCmd
   3456           *
   3457           * @brief   Process the "Profile" Write and Write No Response Commands
   3458           *
   3459           * @param   pInMsg - incoming message to process
   3460           *
   3461           * @return  TRUE if command processed. FALSE, otherwise.
   3462           */

   \                                 In  segment CODE, align 2, keep-with-next
   3463          static uint8 zclProcessInWriteCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteCmd:
   3464          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0B4C         MOV.W   R12, R11
   3465            zclWriteCmd_t *writeCmd;
   3466            zclWriteRspCmd_t *writeRspCmd;
   3467            uint8 sendRsp = FALSE;
   \   000006   4943         MOV.B   #0x0, R9
   3468            uint8 j = 0;
   \   000008   4A43         MOV.B   #0x0, R10
   3469          
   3470            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   00000A   154C0C00     MOV.W   0xc(R12), R5
   3471            if ( pInMsg->hdr.commandID == ZCL_CMD_WRITE )
   \   00000E   EC930700     CMP.B   #0x2, 0x7(R12)
   \   000012   0920         JNE     ??zclProcessInWriteCmd_3
   3472            {
   3473              // We need to send a response back - allocate space for it
   3474              writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t )
   3475                      + sizeof( zclWriteRspStatus_t ) * writeCmd->numAttr );
   \   000014   6C45         MOV.B   @R5, R12
   \   000016   5C06         RLAM.W  #0x2, R12
   \   000018   2C53         ADD.W   #0x2, R12
   \   00001A   ........     CALLA   #??Subroutine28_0
   3476              if ( writeRspCmd == NULL )
   \                     ??CrossCallReturnLabel_107:
   \   00001E   0220         JNE     ??zclProcessInWriteCmd_4
   3477              {
   3478                return FALSE; // EMBEDDED RETURN
   \   000020   4C43         MOV.B   #0x0, R12
   \   000022   5B3C         JMP     ??zclProcessInWriteCmd_5
   3479              }
   3480          
   3481              sendRsp = TRUE;
   \                     ??zclProcessInWriteCmd_4:
   \   000024   5943         MOV.B   #0x1, R9
   3482            }
   3483          
   3484            for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \                     ??zclProcessInWriteCmd_3:
   \   000026   4643         MOV.B   #0x0, R6
   \   000028   093C         JMP     ??zclProcessInWriteCmd_6
   3485            {
   3486              zclAttrRec_t attrRec;
   3487              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   3488              
   3489              if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, 
   3490                                   statusRec->attrID, &attrRec ) )
   3491              {
   3492                if ( statusRec->dataType == attrRec.attr.dataType )
   3493                {
   3494                  uint8 status;
   3495          
   3496                  // Write the new attribute value
   3497                  if ( attrRec.attr.dataPtr != NULL )
   3498                  {
   3499                    status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), 
   3500                                               &attrRec, statusRec );
   3501                  }
   3502                  else // Use CB
   3503                  {
   3504                    status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr), 
   3505                                                      &attrRec, statusRec->attrData );
   3506                  }
   3507          
   3508                  // If successful, a write attribute status record shall NOT be generated
   3509                  if ( sendRsp && status != ZCL_STATUS_SUCCESS )
   3510                  {
   3511                    // Attribute is read only - move on to the next write attribute record
   3512                    writeRspCmd->attrList[j].status = status;
   3513                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3514                  }
   3515                }
   3516                else
   3517                {
   3518                  // Attribute data type is incorrect - move on to the next write attribute record
   3519                  if ( sendRsp )
   3520                  {
   3521                    writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3522                    writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3523                  }
   3524                }
   3525              }
   3526              else
   3527              {
   3528                // Attribute is not supported - move on to the next write attribute record
   3529                if ( sendRsp )
   \                     ??zclProcessInWriteCmd_0:
   \   00002A   59B3         BIT.B   #0x1, R9
   \   00002C   0628         JNC     ??zclProcessInWriteCmd_1
   3530                {
   3531                  writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \   00002E   F74086000200 MOV.B   #0x86, 0x2(R7)
   3532                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   \                     ??zclProcessInWriteCmd_2:
   \   000034   A7440400     MOV.W   @R4, 0x4(R7)
   \   000038   5A53         ADD.B   #0x1, R10
   3533                }
   3534              }
   \                     ??zclProcessInWriteCmd_1:
   \   00003A   5653         ADD.B   #0x1, R6
   \                     ??zclProcessInWriteCmd_6:
   \   00003C   6695         CMP.B   @R5, R6
   \   00003E   2E2C         JC      ??zclProcessInWriteCmd_7
   \   000040   0F46         MOV.W   R6, R15
   \   000042                RPT     #0x5
   \   000042   44180F56     ADDX.W  R6, R15
   \   000046   0445         MOV.W   R5, R4
   \   000048   045F         ADD.W   R15, R4
   \   00004A   2453         ADD.W   #0x2, R4
   \   00004C   4F4A         MOV.B   R10, R15
   \   00004E   5F06         RLAM.W  #0x2, R15
   \   000050   0748         MOV.W   R8, R7
   \   000052   075F         ADD.W   R15, R7
   \   000054   2C4B         MOV.W   @R11, R12
   \   000056   0F41         MOV.W   SP, R15
   \   000058   ........     CALLA   #?Subroutine23
   \                     ??CrossCallReturnLabel_85:
   \   00005C   E627         JEQ     ??zclProcessInWriteCmd_0
   \   00005E   D49104000200 CMP.B   0x4(SP), 0x2(R4)
   \   000064   1520         JNE     ??zclProcessInWriteCmd_8
   \   000066   2C4B         MOV.W   @R11, R12
   \   000068   81930600     CMP.W   #0x0, 0x6(SP)
   \   00006C   0524         JEQ     ??zclProcessInWriteCmd_9
   \   00006E   0F44         MOV.W   R4, R15
   \   000070   0E41         MOV.W   SP, R14
   \   000072   ........     CALLA   #?Subroutine30
   \                     ??CrossCallReturnLabel_33:
   \   000076   053C         JMP     ??zclProcessInWriteCmd_10
   \                     ??zclProcessInWriteCmd_9:
   \   000078   1F440400     MOV.W   0x4(R4), R15
   \   00007C   0E41         MOV.W   SP, R14
   \   00007E   ........     CALLA   #?Subroutine31
   \                     ??zclProcessInWriteCmd_10:
   \   000082   59B3         BIT.B   #0x1, R9
   \   000084   DA2B         JNC     ??zclProcessInWriteCmd_1
   \   000086   4C93         CMP.B   #0x0, R12
   \   000088   D827         JEQ     ??zclProcessInWriteCmd_1
   \   00008A   C74C0200     MOV.B   R12, 0x2(R7)
   \   00008E   D23F         JMP     ??zclProcessInWriteCmd_2
   \                     ??zclProcessInWriteCmd_8:
   \   000090   59B3         BIT.B   #0x1, R9
   \   000092   D32B         JNC     ??zclProcessInWriteCmd_1
   \   000094   F7408D000200 MOV.B   #0x8d, 0x2(R7)
   \   00009A   CC3F         JMP     ??zclProcessInWriteCmd_2
   3535            } // for loop
   3536          
   3537            if ( sendRsp )
   \                     ??zclProcessInWriteCmd_7:
   \   00009C   59B3         BIT.B   #0x1, R9
   \   00009E   1C28         JNC     ??zclProcessInWriteCmd_11
   3538            {
   3539              writeRspCmd->numAttr = j;
   \   0000A0   C84A0000     MOV.B   R10, 0(R8)
   3540              if ( writeRspCmd->numAttr == 0 )
   \   0000A4   4A93         CMP.B   #0x0, R10
   \   0000A6   0420         JNE     ??zclProcessInWriteCmd_12
   3541              {
   3542                // Since all records were written successful, include a single status record
   3543                // in the resonse command with the status field set to SUCCESS and the
   3544                // attribute ID field omitted.
   3545                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   0000A8   C8430200     MOV.B   #0x0, 0x2(R8)
   3546                writeRspCmd->numAttr = 1;
   \   0000AC   D8430000     MOV.B   #0x1, 0(R8)
   3547              }
   3548          
   3549              zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3550                                pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3551                                true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteCmd_12:
   \   0000B0   274B         MOV.W   @R11, R7
   \   0000B2   5B120600     PUSH.B  0x6(R11)
   \   0000B6   5312         PUSH.B  #0x1
   \   0000B8   5312         PUSH.B  #0x1
   \   0000BA   0F48         MOV.W   R8, R15
   \   0000BC   1E470400     MOV.W   0x4(R7), R14
   \   0000C0   0D47         MOV.W   R7, R13
   \   0000C2   3D500600     ADD.W   #0x6, R13
   \   0000C6   5C471400     MOV.B   0x14(R7), R12
   \   0000CA   ........     CALLA   #zcl_SendWriteRsp
   3552              osal_mem_free( writeRspCmd );
   \   0000CE   0C48         MOV.W   R8, R12
   \   0000D0   ........     CALLA   #osal_mem_free
   \   0000D4   31500600     ADD.W   #0x6, SP
   3553            }
   3554          
   3555            return TRUE;
   \                     ??zclProcessInWriteCmd_11:
   \   0000D8   5C43         MOV.B   #0x1, R12
   \                     ??zclProcessInWriteCmd_5:
   \   0000DA                REQUIRE ?Subroutine3
   \   0000DA                // Fall through to label ?Subroutine3
   3556          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine31:
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   3D500600     ADD.W   #0x6, R13
   \   000006   5C4C1400     MOV.B   0x14(R12), R12
   \   00000A   ........     BRA     #zclWriteAttrDataUsingCB

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine30:
   \   000000   0D4C         MOV.W   R12, R13
   \   000002   3D500600     ADD.W   #0x6, R13
   \   000006   5C4C1400     MOV.B   0x14(R12), R12
   \   00000A   ........     BRA     #zclWriteAttrData

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine23:
   \   000000   2E44         MOV.W   @R4, R14
   \   000002                REQUIRE ??Subroutine60_0
   \   000002                // Fall through to label ??Subroutine60_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine60_0:
   \   000000   1D4C0400     MOV.W   0x4(R12), R13
   \   000004   5C4C1400     MOV.B   0x14(R12), R12
   \   000008                REQUIRE ??Subroutine23_0
   \   000008                // Fall through to label ??Subroutine23_0
   3557          
   3558          /*********************************************************************
   3559           * @fn      zclRevertWriteUndividedCmd
   3560           *
   3561           * @brief   Revert the "Profile" Write Undevided Command
   3562           *
   3563           * @param   pInMsg - incoming message to process
   3564           * @param   curWriteRec - old data
   3565           * @param   numAttr - number of attributes to be reverted
   3566           *
   3567           * @return  none
   3568           */

   \                                 In  segment CODE, align 2, keep-with-next
   3569          static void zclRevertWriteUndividedCmd( zclIncoming_t *pInMsg,
   \                     zclRevertWriteUndividedCmd:
   3570                                              zclWriteRec_t *curWriteRec, uint16 numAttr )
   3571          {
   \   000000   5B15         PUSHM.W #0x6, R11
   \   000002   3182         SUB.W   #0x8, SP
   \   000004   0B4C         MOV.W   R12, R11
   \   000006   084D         MOV.W   R13, R8
   \   000008   094E         MOV.W   R14, R9
   3572            for ( uint8 i = 0; i < numAttr; i++ )
   \   00000A   4A43         MOV.B   #0x0, R10
   \   00000C   0B3C         JMP     ??zclRevertWriteUndividedCmd_2
   3573            {
   3574              zclAttrRec_t attrRec;
   3575              zclWriteRec_t *statusRec = &(curWriteRec[i]);
   3576          
   3577              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3578                                    statusRec->attrID, &attrRec ) )
   3579              {
   3580                break; // should never happen
   3581              }
   3582          
   3583              if ( attrRec.attr.dataPtr != NULL )
   3584              {
   3585                // Just copy the old data back - no need to validate the data
   3586                uint16 dataLen = zclGetAttrDataLength( attrRec.attr.dataType, statusRec->attrData );
   3587                osal_memcpy( attrRec.attr.dataPtr, statusRec->attrData, dataLen );
   3588              }
   3589              else // Use CB
   3590              {
   3591                // Write the old data back
   3592                zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3593                                         &attrRec, statusRec->attrData );
   \                     ??zclRevertWriteUndividedCmd_0:
   \   00000E   264B         MOV.W   @R11, R6
   \   000010   0F4D         MOV.W   R13, R15
   \   000012   0E41         MOV.W   SP, R14
   \   000014   0D46         MOV.W   R6, R13
   \   000016   3D500600     ADD.W   #0x6, R13
   \   00001A   5C461400     MOV.B   0x14(R6), R12
   \   00001E   ........     CALLA   #zclWriteAttrDataUsingCB
   3594              }
   \                     ??zclRevertWriteUndividedCmd_1:
   \   000022   5A53         ADD.B   #0x1, R10
   \                     ??zclRevertWriteUndividedCmd_2:
   \   000024   0A99         CMP.W   R9, R10
   \   000026   1C2C         JC      ??zclRevertWriteUndividedCmd_3
   \   000028   0F4A         MOV.W   R10, R15
   \   00002A                RPT     #0x5
   \   00002A   44180F5A     ADDX.W  R10, R15
   \   00002E   0648         MOV.W   R8, R6
   \   000030   065F         ADD.W   R15, R6
   \   000032   2C4B         MOV.W   @R11, R12
   \   000034   0F41         MOV.W   SP, R15
   \   000036   2E46         MOV.W   @R6, R14
   \   000038   ........     CALLA   #??Subroutine60_0
   \                     ??CrossCallReturnLabel_86:
   \   00003C   1124         JEQ     ??zclRevertWriteUndividedCmd_3
   \   00003E   1D460400     MOV.W   0x4(R6), R13
   \   000042   17410600     MOV.W   0x6(SP), R7
   \   000046   0793         CMP.W   #0x0, R7
   \   000048   E227         JEQ     ??zclRevertWriteUndividedCmd_0
   \   00004A   5C410400     MOV.B   0x4(SP), R12
   \   00004E   ........     CALLA   #zclGetAttrDataLength
   \   000052   0E4C         MOV.W   R12, R14
   \   000054   1D460400     MOV.W   0x4(R6), R13
   \   000058   0C47         MOV.W   R7, R12
   \   00005A   ........     CALLA   #osal_memcpy
   \   00005E   E13F         JMP     ??zclRevertWriteUndividedCmd_1
   3595            } // for loop
   3596          }
   \                     ??zclRevertWriteUndividedCmd_3:
   \   000060   3152         ADD.W   #0x8, SP
   \   000062   5617         POPM.W  #0x6, R11
   \   000064   1001         RETA
   3597          
   3598          /*********************************************************************
   3599           * @fn      zclProcessInWriteUndividedCmd
   3600           *
   3601           * @brief   Process the "Profile" Write Undivided Command
   3602           *
   3603           * @param   pInMsg - incoming message to process
   3604           *
   3605           * @return  TRUE if command processed. FALSE, otherwise.
   3606           */

   \                                 In  segment CODE, align 2, keep-with-next
   3607          static uint8 zclProcessInWriteUndividedCmd( zclIncoming_t *pInMsg )
   \                     zclProcessInWriteUndividedCmd:
   3608          {
   \   000000   7B15         PUSHM.W #0x8, R11
   \   000002   31800C00     SUB.W   #0xc, SP
   \   000006   084C         MOV.W   R12, R8
   3609            zclWriteCmd_t *writeCmd;
   3610            zclWriteRspCmd_t *writeRspCmd;
   3611            zclAttrRec_t attrRec;
   3612            uint16 dataLen;
   3613            uint16 curLen = 0;
   \   000008   0743         MOV.W   #0x0, R7
   3614            uint8 j = 0;
   \   00000A   4A43         MOV.B   #0x0, R10
   3615          
   3616            writeCmd = (zclWriteCmd_t *)pInMsg->attrCmd;
   \   00000C   154C0C00     MOV.W   0xc(R12), R5
   3617          
   3618            // Allocate space for Write Response Command
   3619            writeRspCmd = (zclWriteRspCmd_t *)osal_mem_alloc( sizeof( zclWriteRspCmd_t )
   3620                             + sizeof( zclWriteRspStatus_t )* writeCmd->numAttr );
   \   000010   6C45         MOV.B   @R5, R12
   \   000012   5C06         RLAM.W  #0x2, R12
   \   000014   2C53         ADD.W   #0x2, R12
   \   000016   ........     CALLA   #osal_mem_alloc
   \   00001A   094C         MOV.W   R12, R9
   3621            if ( writeRspCmd == NULL )
   \   00001C   0C93         CMP.W   #0x0, R12
   \   00001E   3724         JEQ     ??zclProcessInWriteUndividedCmd_6
   3622            {
   3623              return FALSE; // EMBEDDED RETURN
   3624            }
   3625          
   3626            // If any attribute cannot be written, no attribute values are changed. Hence,
   3627            // make sure all the attributes are supported and writable
   3628            for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   000020   4B43         MOV.B   #0x0, R11
   \   000022   0C3C         JMP     ??zclProcessInWriteUndividedCmd_9
   3629            {
   3630              zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   3631          
   3632              if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3633                                    statusRec->attrID, &attrRec ) )
   3634              {
   3635                // Attribute is not supported - stop here
   3636                writeRspCmd->attrList[j].status = ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   3637                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3638                break;
   3639              }
   3640          
   3641              if ( statusRec->dataType != attrRec.attr.dataType )
   3642              {
   3643                // Attribute data type is incorrect - stope here
   3644                writeRspCmd->attrList[j].status = ZCL_STATUS_INVALID_DATA_TYPE;
   3645                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3646                break;
   3647              }
   3648          
   3649              if ( !zcl_AccessCtrlWrite( attrRec.attr.accessControl ) )
   3650              {
   3651                // Attribute is not writable - stop here
   3652                writeRspCmd->attrList[j].status = ZCL_STATUS_READ_ONLY;
   3653                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3654                break;
   3655              }
   3656          
   3657              if ( zcl_AccessCtrlAuthWrite( attrRec.attr.accessControl ) )
   3658              {
   3659                // Not authorized to write - stop here
   3660                writeRspCmd->attrList[j].status = ZCL_STATUS_NOT_AUTHORIZED;
   3661                writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3662                break;
   3663              }
   3664          
   3665              // Attribute Data length
   3666              if ( attrRec.attr.dataPtr != NULL )
   3667              {
   3668                dataLen = zclGetAttrDataLength( attrRec.attr.dataType, attrRec.attr.dataPtr );
   3669              }
   3670              else // Use CB
   3671              {
   3672                dataLen = zclGetAttrDataLengthUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3673                                                       statusRec->attrID );
   \                     ??zclProcessInWriteUndividedCmd_1:
   \   000024   2F48         MOV.W   @R8, R15
   \   000026   2E46         MOV.W   @R6, R14
   \   000028   1D4F0400     MOV.W   0x4(R15), R13
   \   00002C   5C4F1400     MOV.B   0x14(R15), R12
   \   000030   ........     CALLA   #zclGetAttrDataLengthUsingCB
   \                     ??zclProcessInWriteUndividedCmd_17:
   \   000034   814C0000     MOV.W   R12, 0(SP)
   3674              }
   3675          
   3676              // add padding if needed
   3677              if ( PADDING_NEEDED( dataLen ) )
   \   000038   ........     CALLA   #?Subroutine37
   \                     ??zclProcessInWriteUndividedCmd_9:
   \   00003C   6B95         CMP.B   @R5, R11
   \   00003E   172C         JC      ??zclProcessInWriteUndividedCmd_0
   \   000040   0F4B         MOV.W   R11, R15
   \   000042                RPT     #0x5
   \   000042   44180F5B     ADDX.W  R11, R15
   \   000046   0645         MOV.W   R5, R6
   \   000048   065F         ADD.W   R15, R6
   \   00004A   2653         ADD.W   #0x2, R6
   \   00004C   2448         MOV.W   @R8, R4
   \   00004E   0F41         MOV.W   SP, R15
   \   000050   2F52         ADD.W   #0x4, R15
   \   000052   2E46         MOV.W   @R6, R14
   \   000054   1D440400     MOV.W   0x4(R4), R13
   \   000058   5C441400     MOV.B   0x14(R4), R12
   \   00005C   ........     CALLA   #??Subroutine23_0
   \                     ??CrossCallReturnLabel_88:
   \   000060   1820         JNE     ??zclProcessInWriteUndividedCmd_10
   \   000062   F94086000200 MOV.B   #0x86, 0x2(R9)
   \                     ??zclProcessInWriteUndividedCmd_4:
   \   000068   A9460400     MOV.W   @R6, 0x4(R9)
   \   00006C   5A43         MOV.B   #0x1, R10
   3678              {
   3679                dataLen++;
   3680              }
   3681          
   3682              curLen += dataLen;
   3683            } // for loop
   3684          
   3685            writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_0:
   \   00006E   C94A0000     MOV.B   R10, 0(R9)
   3686            if ( writeRspCmd->numAttr == 0 ) // All attributes can be written
   \   000072   4A93         CMP.B   #0x0, R10
   \   000074   8D20         JNE     ??zclProcessInWriteUndividedCmd_11
   3687            {
   3688              uint8 *curDataPtr;
   3689              zclWriteRec_t *curWriteRec;
   3690          
   3691              // calculate the length of the current data header
   3692              uint8 hdrLen = j * sizeof( zclWriteRec_t );
   \   000076   4B4A         MOV.B   R10, R11
   \   000078                RPT     #0x5
   \   000078   44184B5A     ADDX.B  R10, R11
   3693          
   3694              // Allocate space to keep a copy of the current data
   3695              curWriteRec = (zclWriteRec_t *) osal_mem_alloc( hdrLen + curLen );
   \   00007C   4C4B         MOV.B   R11, R12
   \   00007E   0C57         ADD.W   R7, R12
   \   000080   ........     CALLA   #osal_mem_alloc
   \   000084   064C         MOV.W   R12, R6
   3696              if ( curWriteRec == NULL )
   \   000086   0C93         CMP.W   #0x0, R12
   \   000088   2320         JNE     ??zclProcessInWriteUndividedCmd_12
   3697              {
   3698                osal_mem_free(writeRspCmd );
   \   00008A   ........     CALLA   #??Subroutine34_0
   3699                return FALSE; // EMBEDDED RETURN
   \                     ??zclProcessInWriteUndividedCmd_6:
   \   00008E   4C43         MOV.B   #0x0, R12
   \   000090   8E3C         JMP     ??zclProcessInWriteUndividedCmd_13
   3700              }
   \                     ??zclProcessInWriteUndividedCmd_10:
   \   000092   5C410800     MOV.B   0x8(SP), R12
   \   000096   C69C0200     CMP.B   R12, 0x2(R6)
   \   00009A   0424         JEQ     ??zclProcessInWriteUndividedCmd_14
   \   00009C   F9408D000200 MOV.B   #0x8d, 0x2(R9)
   \   0000A2   E23F         JMP     ??zclProcessInWriteUndividedCmd_4
   \                     ??zclProcessInWriteUndividedCmd_14:
   \   0000A4   E1B30900     BIT.B   #0x2, 0x9(SP)
   \   0000A8   042C         JC      ??zclProcessInWriteUndividedCmd_15
   \   0000AA   F94088000200 MOV.B   #0x88, 0x2(R9)
   \   0000B0   DB3F         JMP     ??zclProcessInWriteUndividedCmd_4
   \                     ??zclProcessInWriteUndividedCmd_15:
   \   0000B2   F1B020000900 BIT.B   #0x20, 0x9(SP)
   \   0000B8   0428         JNC     ??zclProcessInWriteUndividedCmd_16
   \   0000BA   F9407E000200 MOV.B   #0x7e, 0x2(R9)
   \   0000C0   D33F         JMP     ??zclProcessInWriteUndividedCmd_4
   \                     ??zclProcessInWriteUndividedCmd_16:
   \   0000C2   1D410A00     MOV.W   0xa(SP), R13
   \   0000C6   0D93         CMP.W   #0x0, R13
   \   0000C8   AD27         JEQ     ??zclProcessInWriteUndividedCmd_1
   \   0000CA   ........     CALLA   #zclGetAttrDataLength
   \   0000CE   B23F         JMP     ??zclProcessInWriteUndividedCmd_17
   3701          
   3702              curDataPtr = (uint8 *)((uint8 *)curWriteRec + hdrLen);
   \                     ??zclProcessInWriteUndividedCmd_12:
   \   0000D0   4B4B         MOV.B   R11, R11
   \   0000D2   074C         MOV.W   R12, R7
   \   0000D4   075B         ADD.W   R11, R7
   3703          
   3704              // Write the new data over
   3705              for ( uint8 i = 0; i < writeCmd->numAttr; i++ )
   \   0000D6   4B43         MOV.B   #0x0, R11
   \   0000D8   023C         JMP     ??zclProcessInWriteUndividedCmd_18
   3706              {
   3707                uint8 status;
   3708                zclWriteRec_t *statusRec = &(writeCmd->attrList[i]);
   3709                zclWriteRec_t *curStatusRec = &(curWriteRec[i]);
   3710          
   3711                if ( !zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3712                                      statusRec->attrID, &attrRec ) )
   3713                {
   3714                  break; // should never happen
   3715                }
   3716          
   3717                // Keep a copy of the current data before before writing the new data over
   3718                curStatusRec->attrID = statusRec->attrID;
   3719                curStatusRec->attrData = curDataPtr;
   3720          
   3721                if ( attrRec.attr.dataPtr != NULL )
   3722                {
   3723                  // Read the current value
   3724                  zclReadAttrData( curDataPtr, &attrRec, &dataLen );
   3725          
   3726                  // Write the new attribute value
   3727                  status = zclWriteAttrData( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3728                                             &attrRec, statusRec );
   3729                }
   3730                else // Use CBs
   3731                {
   3732                  // Read the current value
   3733                  zclReadAttrDataUsingCB( pInMsg->msg->endPoint, pInMsg->msg->clusterId,
   3734                                          statusRec->attrID, curDataPtr, &dataLen );
   3735                  // Write the new attribute value
   3736                  status = zclWriteAttrDataUsingCB( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3737                                                    &attrRec, statusRec->attrData );
   3738                }
   3739          
   3740                // If successful, a write attribute status record shall NOT be generated
   3741                if ( status != ZCL_STATUS_SUCCESS )
   3742                {
   3743                  writeRspCmd->attrList[j].status = status;
   3744                  writeRspCmd->attrList[j++].attrID = statusRec->attrID;
   3745          
   3746                  // Since this write failed, we need to revert all the pervious writes
   3747                  zclRevertWriteUndividedCmd( pInMsg, curWriteRec, i);
   3748                  break;
   3749                }
   3750          
   3751                // add padding if needed
   3752                if ( PADDING_NEEDED( dataLen ) )
   \                     ??zclProcessInWriteUndividedCmd_3:
   \   0000DA   ........     CALLA   #?Subroutine37
   \                     ??zclProcessInWriteUndividedCmd_18:
   \   0000DE   6B95         CMP.B   @R5, R11
   \   0000E0   4C2C         JC      ??zclProcessInWriteUndividedCmd_19
   \   0000E2   0F4B         MOV.W   R11, R15
   \   0000E4                RPT     #0x5
   \   0000E4   44180F5B     ADDX.W  R11, R15
   \   0000E8   0445         MOV.W   R5, R4
   \   0000EA   045F         ADD.W   R15, R4
   \   0000EC   2453         ADD.W   #0x2, R4
   \   0000EE   0E46         MOV.W   R6, R14
   \   0000F0   0E5F         ADD.W   R15, R14
   \   0000F2   814E0200     MOV.W   R14, 0x2(SP)
   \   0000F6   2C48         MOV.W   @R8, R12
   \   0000F8   0F41         MOV.W   SP, R15
   \   0000FA   2F52         ADD.W   #0x4, R15
   \   0000FC   ........     CALLA   #?Subroutine23
   \                     ??CrossCallReturnLabel_84:
   \   000100   3C24         JEQ     ??zclProcessInWriteUndividedCmd_19
   \   000102   1F410200     MOV.W   0x2(SP), R15
   \   000106   AF440000     MOV.W   @R4, 0(R15)
   \   00010A   1F410200     MOV.W   0x2(SP), R15
   \   00010E   8F470400     MOV.W   R7, 0x4(R15)
   \   000112   81930A00     CMP.W   #0x0, 0xa(SP)
   \   000116   0D24         JEQ     ??zclProcessInWriteUndividedCmd_20
   \   000118   0E41         MOV.W   SP, R14
   \   00011A   0D41         MOV.W   SP, R13
   \   00011C   2D52         ADD.W   #0x4, R13
   \   00011E   0C47         MOV.W   R7, R12
   \   000120   ........     CALLA   #zclReadAttrData
   \   000124   2C48         MOV.W   @R8, R12
   \   000126   0F44         MOV.W   R4, R15
   \   000128   0E41         MOV.W   SP, R14
   \   00012A   2E52         ADD.W   #0x4, R14
   \   00012C   ........     CALLA   #?Subroutine30
   \                     ??CrossCallReturnLabel_34:
   \   000130   143C         JMP     ??zclProcessInWriteUndividedCmd_21
   \                     ??zclProcessInWriteUndividedCmd_20:
   \   000132   2C48         MOV.W   @R8, R12
   \   000134   0F41         MOV.W   SP, R15
   \   000136   0F12         PUSH.W  R15
   \   000138   0F47         MOV.W   R7, R15
   \   00013A   2E44         MOV.W   @R4, R14
   \   00013C   1D4C0400     MOV.W   0x4(R12), R13
   \   000140   5C4C1400     MOV.B   0x14(R12), R12
   \   000144   ........     CALLA   #zclReadAttrDataUsingCB
   \   000148   2C48         MOV.W   @R8, R12
   \   00014A   1F440400     MOV.W   0x4(R4), R15
   \   00014E   0E41         MOV.W   SP, R14
   \   000150   3E500600     ADD.W   #0x6, R14
   \   000154   ........     CALLA   #?Subroutine31
   \                     ??CrossCallReturnLabel_35:
   \   000158   2153         ADD.W   #0x2, SP
   \                     ??zclProcessInWriteUndividedCmd_21:
   \   00015A   4C93         CMP.B   #0x0, R12
   \   00015C   BE27         JEQ     ??zclProcessInWriteUndividedCmd_3
   \   00015E   474A         MOV.B   R10, R7
   \   000160   5706         RLAM.W  #0x2, R7
   \   000162   0F49         MOV.W   R9, R15
   \   000164   0F57         ADD.W   R7, R15
   \   000166   CF4C0200     MOV.B   R12, 0x2(R15)
   \   00016A   AF440400     MOV.W   @R4, 0x4(R15)
   \   00016E   5A53         ADD.B   #0x1, R10
   \   000170   4E4B         MOV.B   R11, R14
   \   000172   0D46         MOV.W   R6, R13
   \   000174   0C48         MOV.W   R8, R12
   \   000176   ........     CALLA   #zclRevertWriteUndividedCmd
   3753                {
   3754                  dataLen++;
   3755                }
   3756          
   3757                curDataPtr += dataLen;
   3758              } // for loop
   3759          
   3760              writeRspCmd->numAttr = j;
   \                     ??zclProcessInWriteUndividedCmd_19:
   \   00017A   C94A0000     MOV.B   R10, 0(R9)
   3761              if ( writeRspCmd->numAttr  == 0 )
   \   00017E   4A93         CMP.B   #0x0, R10
   \   000180   0420         JNE     ??zclProcessInWriteUndividedCmd_22
   3762              {
   3763                // Since all records were written successful, include a single status record
   3764                // in the resonse command with the status field set to SUCCESS and the
   3765                // attribute ID field omitted.
   3766                writeRspCmd->attrList[0].status = ZCL_STATUS_SUCCESS;
   \   000182   C9430200     MOV.B   #0x0, 0x2(R9)
   3767                writeRspCmd->numAttr = 1;
   \   000186   D9430000     MOV.B   #0x1, 0(R9)
   3768              }
   3769          
   3770              osal_mem_free( curWriteRec );
   \                     ??zclProcessInWriteUndividedCmd_22:
   \   00018A   0C46         MOV.W   R6, R12
   \   00018C   ........     CALLA   #osal_mem_free
   3771            }
   3772          
   3773            zcl_SendWriteRsp( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   3774                              pInMsg->msg->clusterId, writeRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3775                              true, pInMsg->hdr.transSeqNum );
   \                     ??zclProcessInWriteUndividedCmd_11:
   \   000190   2B48         MOV.W   @R8, R11
   \   000192   58120600     PUSH.B  0x6(R8)
   \   000196   5312         PUSH.B  #0x1
   \   000198   5312         PUSH.B  #0x1
   \   00019A   0F49         MOV.W   R9, R15
   \   00019C   ........     CALLA   #?Subroutine53
   \                     ??CrossCallReturnLabel_57:
   \   0001A0   ........     CALLA   #zcl_SendWriteRsp
   3776            osal_mem_free( writeRspCmd );
   \   0001A4   ........     CALLA   #??Subroutine34_0
   3777          
   3778            return TRUE;
   \                     ??CrossCallReturnLabel_77:
   \   0001A8   5C43         MOV.B   #0x1, R12
   \   0001AA   31500600     ADD.W   #0x6, SP
   \                     ??zclProcessInWriteUndividedCmd_13:
   \   0001AE   31500C00     ADD.W   #0xc, SP
   \   0001B2   7417         POPM.W  #0x8, R11
   \   0001B4   1001         RETA
   3779          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine37:
   \   000000   91B30400     BIT.W   #0x1, 0x4(SP)
   \   000004   0228         JNC     ??zclProcessInWriteUndividedCmd_7
   \   000006   91530400     ADD.W   #0x1, 0x4(SP)
   \                     ??zclProcessInWriteUndividedCmd_7:
   \   00000A   17510400     ADD.W   0x4(SP), R7
   \   00000E   5B53         ADD.B   #0x1, R11
   \   000010   1001         RETA
   3780          #endif // ZCL_WRITE
   3781          
   3782          #ifdef ZCL_DISCOVER
   3783          /*********************************************************************
   3784           * @fn      zclProcessInDiscCmd
   3785           *
   3786           * @brief   Process the "Profile" Discover Command
   3787           *
   3788           * @param   pInMsg - incoming message to process
   3789           *
   3790           * @return  TRUE if command processed. FALSE, otherwise.
   3791           */
   3792          static uint8 zclProcessInDiscCmd( zclIncoming_t *pInMsg )
   3793          {
   3794            zclDiscoverCmd_t *discoverCmd;
   3795            zclDiscoverRspCmd_t *discoverRspCmd;
   3796            uint8 discComplete = TRUE;
   3797            zclAttrRec_t attrRec;
   3798            uint16 attrID;
   3799            uint8 i;
   3800          
   3801            discoverCmd = (zclDiscoverCmd_t *)pInMsg->attrCmd;
   3802          
   3803            // Find out the number of attributes supported within the specified range
   3804            for ( i = 0, attrID = discoverCmd->startAttr; i < discoverCmd->maxAttrIDs; i++, attrID++ )
   3805            {
   3806              if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3807              {
   3808                break;
   3809              }
   3810            }
   3811          
   3812            // Allocate space for the response command
   3813            discoverRspCmd = (zclDiscoverRspCmd_t *)osal_mem_alloc( sizeof (zclDiscoverRspCmd_t)
   3814                                                                   + sizeof ( zclDiscoverInfo_t ) * i );
   3815            if ( discoverRspCmd == NULL )
   3816            {
   3817              return FALSE; // EMEDDED RETURN
   3818            }
   3819          
   3820            discoverRspCmd->numAttr = i;
   3821            if ( discoverRspCmd->numAttr != 0 )
   3822            {
   3823              for ( i = 0, attrID = discoverCmd->startAttr; i < discoverRspCmd->numAttr; i++, attrID++ )
   3824              {
   3825                if ( !zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3826                {
   3827                  break; // Attribute not supported
   3828                }
   3829          
   3830                discoverRspCmd->attrList[i].attrID = attrRec.attr.attrId;
   3831                discoverRspCmd->attrList[i].dataType = attrRec.attr.dataType;
   3832              }
   3833          
   3834              // Are there more attributes to be discovered?
   3835              if ( zclFindNextAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, &attrID, &attrRec ) )
   3836              {
   3837                discComplete = FALSE;
   3838              }
   3839            }
   3840          
   3841            discoverRspCmd->discComplete = discComplete;
   3842            zcl_SendDiscoverRspCmd( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   3843                                    pInMsg->msg->clusterId, discoverRspCmd, ZCL_FRAME_SERVER_CLIENT_DIR,
   3844                                    true, pInMsg->hdr.transSeqNum );
   3845            osal_mem_free( discoverRspCmd );
   3846          
   3847            return TRUE;
   3848          }
   3849          #endif // ZCL_DISCOVER
   3850          
   3851          /*********************************************************************
   3852           * @fn      zclSendMsg
   3853           *
   3854           * @brief   Send an incoming message to the Application
   3855           *
   3856           * @param   pInMsg - incoming message to process
   3857           *
   3858           * @return  TRUE
   3859           */

   \                                 In  segment CODE, align 2
   3860          static uint8 zclSendMsg( zclIncoming_t *pInMsg )
   \                     zclSendMsg:
   3861          {
   \   000000   1B15         PUSHM.W #0x2, R11
   \   000002   0A4C         MOV.W   R12, R10
   3862            zclIncomingMsg_t *pCmd;
   3863          
   3864            if ( zcl_RegisteredMsgTaskID == TASK_NO_TASK )
   \   000004   F293....     CMP.B   #0xff, &zcl_RegisteredMsgTaskID
   \   000008   2924         JEQ     ??zclSendMsg_0
   3865            {
   3866              return ( TRUE );
   3867            }
   3868          
   3869            pCmd = (zclIncomingMsg_t *)osal_msg_allocate( sizeof ( zclIncomingMsg_t ) );
   \   00000A   3C401A00     MOV.W   #0x1a, R12
   \   00000E   ........     CALLA   #osal_msg_allocate
   \   000012   0B4C         MOV.W   R12, R11
   3870            if ( pCmd != NULL )
   \   000014   0C93         CMP.W   #0x0, R12
   \   000016   2224         JEQ     ??zclSendMsg_0
   3871            {
   3872              // fill in the message
   3873              pCmd->hdr.event = ZCL_INCOMING_MSG;
   \   000018   FC4034000000 MOV.B   #0x34, 0(R12)
   3874              pCmd->zclHdr    = pInMsg->hdr;
   \   00001E   0F4A         MOV.W   R10, R15
   \   000020   2F53         ADD.W   #0x2, R15
   \   000022   BC4F0200     MOV.W   @R15+, 0x2(R12)
   \   000026   BC4F0400     MOV.W   @R15+, 0x4(R12)
   \   00002A   BC4F0600     MOV.W   @R15+, 0x6(R12)
   3875              pCmd->clusterId = pInMsg->msg->clusterId;
   \   00002E   2E4A         MOV.W   @R10, R14
   \   000030   9C4E04000800 MOV.W   0x4(R14), 0x8(R12)
   3876              pCmd->srcAddr   = pInMsg->msg->srcAddr;
   \   000036   3C500A00     ADD.W   #0xa, R12
   \   00003A   3E500600     ADD.W   #0x6, R14
   \   00003E   3D400600     MOV.W   #0x6, R13
   \   000042   ........     CALLA   #?CopyMemoryWords
   3877              pCmd->endPoint  = pInMsg->msg->endPoint;
   \   000046   2F4A         MOV.W   @R10, R15
   \   000048   DB4F14001600 MOV.B   0x14(R15), 0x16(R11)
   3878              pCmd->attrCmd   = pInMsg->attrCmd;
   \   00004E   9B4A0C001800 MOV.W   0xc(R10), 0x18(R11)
   3879          
   3880              // Application will free the attrCmd buffer
   3881              pInMsg->attrCmd = NULL;
   \   000054   8A430C00     MOV.W   #0x0, 0xc(R10)
   3882          
   3883              /* send message through task message */
   3884              osal_msg_send( zcl_RegisteredMsgTaskID, (uint8 *)pCmd );
   \   000058   ........     CALLA   #?Subroutine11
   3885            }
   3886          
   3887            return ( TRUE );
   \                     ??zclSendMsg_0:
   \   00005C   5C43         MOV.B   #0x1, R12
   \   00005E   1A17         POPM.W  #0x2, R11
   \   000060   1001         RETA
   3888          }

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for zcl_RegisteredMsgTaskID>`:
   \   000000   FF           DC8 255
   3889          
   3890          /*********************************************************************
   3891          *********************************************************************/

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       4  zclAnalogDataType
      12  zclAuthorizeWrite
            12 -- Indirect call
            12 -> zclGetAuthorizeCB
       4  zclBuildHdr
      12  zclFindAttrRec
            12 -> zclFindAttrRecsList
       4  zclFindAttrRecsList
       8  zclFindClusterOption
       4  zclGetAttrDataLength
             4 -> zclGetDataTypeLength
      16  zclGetAttrDataLengthUsingCB
            16 -- Indirect call
            14 -> zclGetReadWriteCB
       4  zclGetAuthorizeCB
             4 -> zclFindAttrRecsList
       4  zclGetClusterOption
             4 -> zclFindClusterOption
       4  zclGetDataTypeLength
       4  zclGetReadWriteCB
             4 -> zclFindAttrRecsList
       8  zclParseHdr
             8 -> osal_memset
      16  zclParseInConfigReportCmd
            16 -> osal_mem_alloc
            16 -> osal_memset
            16 -> zclAnalogDataType
            16 -> zclGetDataTypeLength
            16 -> zcl_BuildAnalogData
       8  zclParseInConfigReportRspCmd
             8 -> osal_mem_alloc
       6  zclParseInDefaultRspCmd
             6 -> osal_mem_alloc
       8  zclParseInReadCmd
             8 -> osal_mem_alloc
       8  zclParseInReadReportCfgCmd
             8 -> osal_mem_alloc
      16  zclParseInReadReportCfgRspCmd
            16 -> osal_mem_alloc
            16 -> zclAnalogDataType
            16 -> zclGetDataTypeLength
            16 -> zcl_BuildAnalogData
      20  zclParseInReadRspCmd
            20 -> osal_mem_alloc
            20 -> osal_memcpy
            20 -> zclGetAttrDataLength
      20  zclParseInReportCmd
            20 -> osal_mem_alloc
            20 -> osal_memcpy
            20 -> zclGetAttrDataLength
      20  zclParseInWriteCmd
            20 -> osal_mem_alloc
            20 -> osal_memcpy
            20 -> zclGetAttrDataLength
      12  zclParseInWriteRspCmd
            12 -> osal_mem_alloc
      34  zclProcessInReadCmd
            28 -- Indirect call
            28 -> osal_mem_alloc
            34 -> osal_mem_free
            28 -> zclFindAttrRec
            28 -> zclGetAuthorizeCB
            34 -> zcl_SendReadRsp
      34  zclProcessInWriteCmd
            28 -> osal_mem_alloc
            34 -> osal_mem_free
            28 -> zclFindAttrRec
            28 -> zclWriteAttrData
            28 -> zclWriteAttrDataUsingCB
            34 -> zcl_SendWriteRsp
      38  zclProcessInWriteUndividedCmd
            32 -> osal_mem_alloc
            32 -> osal_mem_free
            38 -> osal_mem_free
            32 -> zclFindAttrRec
            32 -> zclGetAttrDataLength
            32 -> zclGetAttrDataLengthUsingCB
            32 -> zclReadAttrData
            34 -> zclReadAttrDataUsingCB
            32 -> zclRevertWriteUndividedCmd
            32 -> zclWriteAttrData
            34 -> zclWriteAttrDataUsingCB
            38 -> zcl_SendWriteRsp
      50  zclProcessMessageMSG
            42 -- Indirect call
            42 -> StubAPS_InterPan
            42 -> afFindEndPointDesc
            42 -> osal_mem_free
            42 -> zclGetClusterOption
            42 -> zclParseHdr
            42 -> zclSetSecurityOption
            44 -> zcl_DeviceOperational
            50 -> zcl_SendDefaultRspCmd
      12  zclReadAttrData
            12 -> osal_memcpy
            12 -> zclGetAttrDataLength
      18  zclReadAttrDataUsingCB
            18 -- Indirect call
            16 -> zclGetReadWriteCB
      24  zclRevertWriteUndividedCmd
            24 -> osal_memcpy
            24 -> zclFindAttrRec
            24 -> zclGetAttrDataLength
            24 -> zclWriteAttrDataUsingCB
       8  zclSendMsg
             8 -> osal_msg_allocate
             8 -> osal_msg_send
       4  zclSerializeData
             4 -> osal_buffer_uint32
             4 -> osal_memcpy
       6  zclSetSecurityOption
             6 -> zclFindClusterOption
      12  zclWriteAttrData
            12 -- Indirect call
            12 -> osal_memcpy
            12 -> zclAuthorizeWrite
            12 -> zclGetAttrDataLength
      14  zclWriteAttrDataUsingCB
            14 -- Indirect call
            12 -> zclAuthorizeWrite
            12 -> zclGetReadWriteCB
       6  zcl_BuildAnalogData
             6 -> osal_build_uint32
      14  zcl_DeviceOperational
            14 -> zclFindAttrRec
            14 -> zclReadAttrData
       4  zcl_Init
      34  zcl_SendCommand
            34 -> AF_DataRequest
            26 -> StubAPS_InterPan
            26 -> afFindEndPointDesc
            26 -> osal_mem_alloc
            34 -> osal_mem_free
            26 -> osal_memcpy
            26 -> osal_memset
            26 -> zclBuildHdr
            26 -> zclGetClusterOption
            28 -> zcl_DeviceOperational
      34  zcl_SendConfigReportCmd
            20 -> osal_mem_alloc
            34 -> osal_mem_free
            20 -> zclAnalogDataType
            20 -> zclGetDataTypeLength
            20 -> zclSerializeData
            34 -> zcl_SendCommand
      30  zcl_SendConfigReportRspCmd
            16 -> osal_mem_alloc
            30 -> osal_mem_free
            30 -> zcl_SendCommand
      20  zcl_SendDefaultRspCmd
            20 -> zcl_SendCommand
      30  zcl_SendRead
            16 -> osal_mem_alloc
            30 -> osal_mem_free
            30 -> zcl_SendCommand
      30  zcl_SendReadReportCfgCmd
            16 -> osal_mem_alloc
            30 -> osal_mem_free
            30 -> zcl_SendCommand
      34  zcl_SendReadReportCfgRspCmd
            20 -> osal_mem_alloc
            34 -> osal_mem_free
            20 -> zclAnalogDataType
            20 -> zclGetDataTypeLength
            20 -> zclSerializeData
            34 -> zcl_SendCommand
      36  zcl_SendReadRsp
            22 -> osal_mem_alloc
            36 -> osal_mem_free
            22 -> zclGetAttrDataLength
            22 -> zclGetAttrDataLengthUsingCB
            24 -> zclReadAttrDataUsingCB
            22 -> zclSerializeData
            36 -> zcl_SendCommand
      34  zcl_SendReportCmd
            20 -> osal_mem_alloc
            34 -> osal_mem_free
            20 -> zclGetAttrDataLength
            20 -> zclSerializeData
            34 -> zcl_SendCommand
      34  zcl_SendWriteRequest
            20 -> osal_mem_alloc
            34 -> osal_mem_free
            20 -> zclGetAttrDataLength
            20 -> zclSerializeData
            34 -> zcl_SendCommand
      30  zcl_SendWriteRsp
            16 -> osal_mem_alloc
            30 -> osal_mem_free
            30 -> zcl_SendCommand
       8  zcl_event_loop
             8 -> osal_msg_deallocate
             8 -> osal_msg_receive
             8 -> osal_msg_send
             8 -> zclProcessMessageMSG
       4  zcl_getRawAFMsg
      12  zcl_registerAttrList
            12 -> osal_mem_alloc
      12  zcl_registerClusterOptionList
            12 -> osal_mem_alloc
       4  zcl_registerForMsg
      12  zcl_registerPlugin
            12 -> osal_mem_alloc
       8  zcl_registerReadWriteCB
             8 -> zclFindAttrRecsList
       4  zcl_registerValidateAttrData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for zcl_RegisteredMsgTaskID>
       2  ??Subroutine14_0
       8  ??Subroutine23_0
      10  ??Subroutine28_0
       6  ??Subroutine34_0
       8  ??Subroutine50_0
       8  ??Subroutine60_0
      12  ??Subroutine6_0
      68  ?Subroutine0
       6  ?Subroutine1
      18  ?Subroutine10
      10  ?Subroutine11
      28  ?Subroutine12
      28  ?Subroutine13
       4  ?Subroutine14
      22  ?Subroutine15
      18  ?Subroutine16
      12  ?Subroutine17
      32  ?Subroutine18
      28  ?Subroutine19
       6  ?Subroutine2
      10  ?Subroutine20
      28  ?Subroutine21
      22  ?Subroutine22
       2  ?Subroutine23
      14  ?Subroutine24
       8  ?Subroutine25
       4  ?Subroutine26
       8  ?Subroutine27
      10  ?Subroutine28
      12  ?Subroutine29
       6  ?Subroutine3
      14  ?Subroutine30
      14  ?Subroutine31
       8  ?Subroutine32
      22  ?Subroutine33
       2  ?Subroutine34
      10  ?Subroutine36
      18  ?Subroutine37
      14  ?Subroutine38
       6  ?Subroutine39
       6  ?Subroutine4
      48  ?Subroutine40
      16  ?Subroutine41
      22  ?Subroutine42
      14  ?Subroutine43
      12  ?Subroutine44
       6  ?Subroutine45
      12  ?Subroutine46
      14  ?Subroutine47
      18  ?Subroutine48
      14  ?Subroutine49
       6  ?Subroutine5
       6  ?Subroutine50
      16  ?Subroutine51
       8  ?Subroutine52
      16  ?Subroutine53
      14  ?Subroutine54
      18  ?Subroutine55
       8  ?Subroutine56
       6  ?Subroutine57
       4  ?Subroutine6
      18  ?Subroutine7
      44  ?Subroutine8
      34  ?Subroutine9
       2  attrList
       2  clusterOptionList
       2  plugins
       2  rawAFMsg
     102  zclAnalogDataType
      38  zclAuthorizeWrite
      80  zclBuildHdr
     112  zclCmdTable
      72  zclFindAttrRec
      26  zclFindAttrRecsList
      58  zclFindClusterOption
      54  zclGetAttrDataLength
      48  zclGetAttrDataLengthUsingCB
      24  zclGetAuthorizeCB
      22  zclGetClusterOption
     216  zclGetDataTypeLength
      20  zclGetReadWriteCB
     138  zclParseHdr
     126  zclParseInConfigReportCmd
      46  zclParseInConfigReportRspCmd
      26  zclParseInDefaultRspCmd
      68  zclParseInReadCmd
      50  zclParseInReadReportCfgCmd
     126  zclParseInReadReportCfgRspCmd
      82  zclParseInReadRspCmd
       0  zclParseInReportCmd
       4  zclParseInWriteCmd
      84  zclParseInWriteRspCmd
     220  zclProcessInReadCmd
     218  zclProcessInWriteCmd
     438  zclProcessInWriteUndividedCmd
     608  zclProcessMessageMSG
      48  zclReadAttrData
      62  zclReadAttrDataUsingCB
     102  zclRevertWriteUndividedCmd
      98  zclSendMsg
     240  zclSerializeData
      38  zclSetSecurityOption
      90  zclWriteAttrData
      68  zclWriteAttrDataUsingCB
     122  zcl_BuildAnalogData
      70  zcl_DeviceOperational
      18  zcl_Init
       1  zcl_RegisteredMsgTaskID
     290  zcl_SendCommand
     132  zcl_SendConfigReportCmd
     122  zcl_SendConfigReportRspCmd
      50  zcl_SendDefaultRspCmd
      94  zcl_SendRead
      66  zcl_SendReadReportCfgCmd
     154  zcl_SendReadReportCfgRspCmd
     242  zcl_SendReadRsp
      82  zcl_SendReportCmd
      82  zcl_SendWriteRequest
      80  zcl_SendWriteRsp
       1  zcl_SeqNum
       1  zcl_TaskID
       1  zcl_TransID
       4  zcl_ValidateAttrDataCB
      78  zcl_event_loop
       6  zcl_getRawAFMsg
      80  zcl_registerAttrList
      72  zcl_registerClusterOptionList
      18  zcl_registerForMsg
      78  zcl_registerPlugin
      42  zcl_registerReadWriteCB
      12  zcl_registerValidateAttrData

 
 6 676 bytes in segment CODE
   112 bytes in segment DATA16_C
     1 byte  in segment DATA16_I
     1 byte  in segment DATA16_ID
    15 bytes in segment DATA16_Z
 
 6 676 bytes of CODE  memory
   113 bytes of CONST memory
    16 bytes of DATA  memory

Errors: none
Warnings: none
